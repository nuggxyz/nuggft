// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

import '../src/erc721/ERC721.sol';
import '../src/interfaces/INuggSwap.sol';

// import '../src/interfaces/IERC721Nuggable.sol';

/**
 * @title Nugg Labs NFT Collection 0 - "NuggFT"
 * @author Nugg Labs - @danny7even & @dub6ix - 2021
 * @notice entrily onchain generative NFT
 * @dev this is art
 *
 * Note: epochs correlate directly to tokenIDs
 * Note: no images are stored in their final form - they are generated by view/pure functions at query time completly onchain
 * Note: the block hash corresponding to the start of an epoch is used as the "random" seed
 * Note: epochs are 256 blocks long as block hashes only exist for 256 blocks
 */
contract MockERC721Mintable is ERC721 {
    INuggSwap public nuggswap;
    uint256 public epochOffset;
    address public owner;

    constructor(address royalty, address _nuggswap) ERC721('Mock ERC721 Mintable', 'MockERC721Mintable') {
        nuggswap = INuggSwap(_nuggswap);
        // epochOffset = nuggswap.currentEpochId();
        owner = royalty;
    }

    function ownerOf(uint256 tokenId) public view virtual override returns (address res) {
        res = _owners[tokenId];
        if (res == address(0)) {
            if (msg.sender == address(nuggswap)) return address(nuggswap);
            require(false, 'ERC721: owner query for nonexistent token');
        }
    }

    function _isApprovedOrOwner(address sender, uint256 tokenId) internal view override returns (bool) {
        require(_exists(tokenId), 'ERC721: operator query for nonexistent token');
        return sender == address(nuggswap);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public override {
        if (msg.sender == address(nuggswap) && !_exists(tokenId)) {
            // this will only be called if nuggswap "minted" it
            if (from == address(nuggswap)) {
                _safeMint(to, tokenId);
            } else {
                require(_data.length > 0, 'STG:721:0');
                // uint48 currentEpoch = abi.decode(_data, (uint48));
                require(to == address(nuggswap), 'STG:721:1');
                require(from == address(0), 'STG:721:2');
                // require(tokenId == epochToTokenId(currentEpoch), 'STG:721:3');
            }
            return;
        }

        super.safeTransferFrom(from, to, tokenId, _data);
    }

    function epochToTokenId(uint256 epoch) internal view returns (uint256 tokenId) {
        tokenId = epoch - epochOffset;
    }

    function currentTokenId() public view returns (uint256 tokenId) {
        // tokenId = epochToTokenId(nuggswap.currentEpochId());
    }

    /**
     * @inheritdoc ERC721
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory res) {}
}
