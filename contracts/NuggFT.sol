// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

import './libraries/Base64.sol';
import './libraries/SeedMath.sol';
import './libraries/Uint.sol';

import './common/Launchable.sol';
import './core/Seedable.sol';
import './core/Epochable.sol';

import './erc721/ERC721.sol';
import './interfaces/IDotNuggFileResolver.sol';
import './interfaces/IDotNuggColorResolver.sol';

import './interfaces/IDotNugg.sol';
import './interfaces/INuggFT.sol';
import './NuggSwap.sol';
import './NuggETH.sol';

/**
 * @title Nugg Labs NFT Collection 0 - "NuggFT"
 * @author Nugg Labs - @danny7even & @dub6ix - 2021
 * @notice entrily onchain generative NFT and stakable auction contract
 * @dev this is art
 *
 * Note: epochs correlate directly to tokenIDs
 * Note: no images are stored in their final form - they are generated by view/pure functions at query time completly onchain
 * Note: the block hash corresponding to the start of an epoch is used as the "random" seed
 * Note: epochs are 256 blocks long as block hashes only exist for 256 blocks
 */
contract NuggFT is INuggFT, ERC721, Seedable {
    using SeedMath for bytes32;
    using Uint256 for uint256;

    IDotNugg internal _DOTNUGG;
    NuggETH internal _NUGGETH;
    NuggSwap internal _NUGGSWAP;
    IDotNuggFileResolver internal _DEFAULT_NUGGIN;

    constructor(
        address nuggeth,
        address nuggswap,
        address dotnugg,
        address nuggin
    ) ERC721('Nugg Fungable Token', 'NuggFT') Epochable(250) {
        _DOTNUGG = IDotNugg(dotnugg);
        _NUGGSWAP = NuggSwap(nuggswap);
        _NUGGETH = NuggETH(nuggeth);
        _DEFAULT_NUGGIN = IDotNuggFileResolver(nuggin);

        require(_DEFAULT_NUGGIN.supportsInterface(type(IDotNuggFileResolver).interfaceId), 'NUG:LAUNCH:0');
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {
        return
            interfaceId == type(INuggMintable).interfaceId ||
            interfaceId == type(INuggSwapable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function mint() external override {
        setSeed();
        _safeMint(address(_NUGGSWAP), currentEpochId());
    }

    function currentEpoch() external override returns (uint32) {
        return uint32(currentEpochId());
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256
    ) internal view override {
        require(msg_sender() == address(_NUGGSWAP), 'NFT:BTT:0');
    }

    /**
     * @inheritdoc ERC721
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory res) {
        res = _generateTokenURI(tokenId, getSeed(tokenId).toUint256(), address(_DEFAULT_NUGGIN));
    }

    function tokenURI(uint256 tokenId, address resolver) public view returns (string memory res) {
        res = _generateTokenURI(tokenId, getSeed(tokenId).toUint256(), resolver);
    }

    /**
     * @notice calcualtes the token uri for a given epoch
     */
    function _generateTokenURI(
        uint256 epoch,
        uint256 seed,
        address resolver
    ) internal view returns (string memory) {
        string memory uriName = string(abi.encodePacked('NuggFT #', epoch.toString()));
        string memory uriDesc = seed.toHexString();

        string memory uriImage = _DOTNUGG.nuggify(collection_, _getItems(seed), resolver, '');

        return
            string(
                abi.encodePacked(
                    Base64.encodeJson(
                        bytes(
                            abi.encodePacked(
                                '{"name":"',
                                uriName,
                                '","description":"',
                                uriDesc,
                                '", "image": "',
                                uriImage,
                                '"}'
                            )
                        )
                    )
                )
            );
    }

    // collection_
    bytes private collection_;

    // bases_
    bytes[] internal items_;

    /**
     * @notice gets unique attribtues based on given epoch and converts encoded bytes to object that can be merged
     */
    function _getItems(uint256 seed) internal view returns (bytes[] memory res) {
        res = new bytes[](5);
        for (uint8 i = 0; i < res.length * 2; i++) {
            res[i] = items_[uint16((seed >> i) % items_.length)];
        }
    }
}
