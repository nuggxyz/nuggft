{
  "language": "Solidity",
  "sources": {
    "src/_test/dev/Minter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../../interfaces/nuggftv1/INuggftV1.sol';\n\ncontract NuggftV1MinterHelper {\n    function delegateem(address nuggftv1, uint160 id) external payable {\n        INuggftV1(nuggftv1).delegate{value: msg.value}(id);\n    }\n\n    function claimem(address nuggftv1, uint160 id) external {\n        INuggftV1(nuggftv1).claim(id);\n\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}\n\ncontract NuggftV1Minter {\n    address immutable minterHelper;\n    address immutable deployer;\n\n    constructor() {\n        minterHelper = address(new NuggftV1MinterHelper());\n        deployer = msg.sender;\n    }\n\n    function trustMint(\n        address nuggftv1,\n        address to,\n        uint256 start,\n        uint256 amount\n    ) external payable {\n        for (uint256 i = start; i < start + amount; i++) {\n            INuggftV1(nuggftv1).trustedMint{value: INuggftV1(nuggftv1).minSharePrice()}(uint160(i), to);\n        }\n    }\n\n    function mint(\n        address nuggftv1,\n        uint160 start,\n        uint160 amount\n    ) external payable {\n        for (uint160 i = start; i < start + amount; i++) {\n            INuggftV1(nuggftv1).mint{value: INuggftV1(nuggftv1).minSharePrice()}(uint160(i));\n            uint96 floor = INuggftV1(nuggftv1).ethPerShare() * 3;\n            INuggftV1(nuggftv1).approve(nuggftv1, uint160(i));\n\n            INuggftV1(nuggftv1).swap(uint160(i), floor);\n\n            (, uint96 amt, ) = INuggftV1(nuggftv1).valueForDelegate(minterHelper, uint160(i));\n\n            if (i % 2 == 0) NuggftV1MinterHelper(minterHelper).delegateem{value: amt}(nuggftv1, i);\n        }\n    }\n\n    function claim(\n        address nuggftv1,\n        uint160 start,\n        uint160 amount\n    ) external {\n        for (uint160 i = start; i < start + amount; i++) {\n            NuggftV1MinterHelper(minterHelper).claimem(nuggftv1, i);\n        }\n    }\n\n    function byebye() external {\n        require(msg.sender == deployer);\n        selfdestruct(payable(msg.sender));\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Token} from './INuggftV1Token.sol';\nimport {INuggftV1Stake} from './INuggftV1Stake.sol';\nimport {INuggftV1Proof} from './INuggftV1Proof.sol';\nimport {INuggftV1Dotnugg} from './INuggftV1Dotnugg.sol';\nimport {INuggftV1Swap} from './INuggftV1Swap.sol';\nimport {INuggftV1Loan} from './INuggftV1Loan.sol';\nimport {INuggftV1Epoch} from './INuggftV1Epoch.sol';\n\nimport {IERC721Metadata} from '../IERC721.sol';\n\ninterface INuggftV1 is\n    IERC721Metadata,\n    INuggftV1Token,\n    INuggftV1Stake,\n    INuggftV1Proof,\n    INuggftV1Dotnugg,\n    INuggftV1Swap,\n    INuggftV1Loan,\n    INuggftV1Epoch\n{}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721} from '../IERC721.sol';\n\ninterface INuggftV1Token is IERC721 {\n    event Mint(uint160 tokenId, uint96 value);\n\n    function mint(uint160 tokenId) external payable;\n\n    function trustedMint(uint160 tokenId, address to) external payable;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Stake {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    event ProtocolEthExtracted(uint96 eth);\n    event MigratorV1Updated(address migrator);\n    event MigrateV1Sent(address v2, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n    event Burn(uint160 tokenId, address owner, uint96 ethOwed);\n    event Stake(uint256 stake);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function migrate(uint160 tokenId) external;\n\n    /// @notice burns a nugg from existance, dealing the eth worth of that share to the user\n    /// @dev should only be called directly\n    /// @param tokenId the id of the nugg being burned\n    function burn(uint160 tokenId) external;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice returns the minimum eth that must be added to create a new share\n    /// @dev premium here is used to push against dillution of supply through ensuring the price always increases\n    /// @dev used by the front end\n    /// @return res -> premium + protcolFee + ethPerShare\n    function minSharePrice() external view returns (uint96 res);\n\n    /// @notice returns the amount of eth extractable by protocol\n    /// @dev this will be\n    /// @return res -> (PROTOCOL_FEE_BPS * [all eth staked] / 10000) - [all previously extracted eth]\n    function protocolEth() external view returns (uint96);\n\n    /// @notice returns the total number of staked shares held by the contract\n    /// @dev this is equivilent to the amount of nuggs in existance\n    function stakedShares() external view returns (uint64);\n\n    function totalSupply() external view returns (uint256);\n\n    /// @notice returns the total amount of staked eth held by the contract\n    /// @dev can be used as the market-cap or tvl of all nuggft v1\n    /// @dev not equivilent to the balance of eth the contract holds, which also hs protocolEth and\n    /// unclaimed eth from unsuccessful swaps\n    function stakedEth() external view returns (uint96);\n\n    /// @notice returns the total \"ethPerShare\" held by the contract\n    /// @dev this value not always equivilent to the \"floor\" price which can consist of perceived value.\n    /// can be looked at as an \"intrinsic floor\"\n    /// @dev this is the value that users will receive when their either burn or loan out nuggs\n    /// @return res -> [current staked eth] / [current staked shares]\n    function ethPerShare() external view returns (uint96);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice sends the current protocolEth to the user and resets the value to zero\n    /// @dev caller must be a trusted user\n    function extractProtocolEth() external;\n\n    /// @notice sets the migrator contract\n    /// @dev caller must be a trusted user\n    /// @param migrator the address to set as the migrator contract\n    function setMigrator(address migrator) external;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Proof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Proof {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                             STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function rotate(\n        uint160 tokenId,\n        uint8 index0,\n        uint8 index1\n    ) external;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               VIEW FUNCTIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function proofOf(uint160 tokenId) external view returns (uint256);\n\n    function proofToDotnuggMetadata(uint160 tokenId)\n        external\n        view\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory overxs,\n            uint8[] memory overys,\n            string[] memory styles,\n            string memory background\n        );\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Dotnugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Implementer} from '../dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1} from '../dotnuggv1/IDotnuggV1.sol';\n\ninterface INuggftV1Dotnugg is IDotnuggV1Implementer {\n    function setDotnuggV1Resolver(uint256 tokenId, address to) external;\n\n    function dotnuggV1ResolverOf(uint256 tokenId) external view returns (address resolver);\n\n    function dotnuggV1() external returns (IDotnuggV1);\n\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external;\n\n    function setDotnuggV1AnchorOverrides(\n        uint160 tokenId,\n        uint16 itemId,\n        uint256 x,\n        uint256 y\n    ) external;\n\n    function setDotnuggV1Background(uint160 tokenId, string memory s) external;\n\n    function setDotnuggV1Style(\n        uint160 tokenId,\n        uint16 itemId,\n        string memory s\n    ) external;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Swap {\n    event Delegate(uint160 indexed tokenId, address user, uint96 lead);\n    event DelegateItem(uint176 indexed sellingItemId, uint160 nugg, uint96 lead);\n    event Claim(uint160 indexed tokenId, address user);\n    event ClaimItem(uint176 indexed sellingItemId, uint160 nugg);\n    event Swap(uint160 indexed tokenId, uint96 floor);\n    event SwapItem(uint176 indexed sellingItemId, uint96 floor);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function delegate(uint160 tokenId) external payable;\n\n    function delegateItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external payable;\n\n    function claim(uint160 tokenId) external;\n\n    function claimItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemid\n    ) external;\n\n    function swap(uint160 tokenId, uint96 floor) external;\n\n    function swapItem(\n        uint160 sellerTokenId,\n        uint16 itemid,\n        uint96 floor\n    ) external;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @notice calculates the minimum eth that must be sent with a delegate call\n    /// @dev returns 0 if no delegate can be made for this oken\n    /// @param tokenId -> the token to be delegated to\n    /// @param sender -> the address of the user who will be delegating\n    /// @return canDelegate -> instead of reverting this function will return false\n    /// @return nextOfferAmount -> the minimum value that must be sent with a delegate call\n    /// @return senderCurrentOffer ->\n    function valueForDelegate(address sender, uint160 tokenId)\n        external\n        view\n        returns (\n            bool canDelegate,\n            uint96 nextOfferAmount,\n            uint96 senderCurrentOffer\n        );\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Loan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Loan {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event Loan(uint160 indexed tokenId, uint96 value);\n\n    event Rebalance(uint160 indexed tokenId, uint96 value);\n\n    event Liquidate(uint160 indexed tokenId, uint96 value, address user);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function rebalance(uint160 tokenId) external payable;\n\n    function loan(uint160 tokenId) external;\n\n    function liquidate(uint160 tokenId) external payable;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @notice for a nugg's active loan: calculates the current min eth a user must send to liquidate or rebalance\n    /// @dev contract ->\n    /// @dev frontend -> used to set the amount of eth for user\n    /// @param tokenId the token who's current loan to check\n    /// @return toLiquidate ->  the current amount loaned out, plus the final rebalance fee\n    /// @return toRebalance ->  the fee a user must pay to rebalance (and extend) the loan on their nugg\n    /// @return earned -> the amount of eth the minSharePrice has increased since loan was last rebalanced\n    /// @return epochDue -> the final epoch a user is safe from liquidation (inclusive)\n    /// @return loaner -> the user responsable for the loan\n    function loanInfo(uint160 tokenId)\n        external\n        view\n        returns (\n            uint96 toLiquidate,\n            uint96 toRebalance,\n            uint96 earned,\n            uint24 epochDue,\n            address loaner\n        );\n\n    /// @notice \"toLiquidate\" value from \"loanInfo\"\n    /// @dev should be used to tell user how much eth to send for liquidate\n    function valueForLiquidate(uint160 tokenId) external view returns (uint96 res);\n\n    /// @notice \"toRebalance\" value from \"loanInfo\"\n    /// @dev should be used to tell user how much eth to send for rebalance\n    function valueForRebalance(uint160 tokenId) external view returns (uint96 res);\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Epoch {\n    /// @notice Explain to an end user what this does\n    /// @dev Explain to a developer any extra details\n    event Genesis(uint256 blocknum, uint32 interval, uint24 offset);\n\n    function epoch() external view returns (uint24 res);\n}\n"
    },
    "src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory data\n    ) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Implementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Metadata} from './IDotnuggV1Metadata.sol';\nimport {IDotnuggV1StorageProxy} from './IDotnuggV1StorageProxy.sol';\n\ninterface IDotnuggV1Implementer {\n    event DotnuggV1ConfigUpdated(uint256 indexed artifactId);\n\n    function dotnuggV1ImplementerCallback(uint256 artifactId) external view returns (IDotnuggV1Metadata.Memory memory data);\n\n    function dotnuggV1TrustCallback(address caller) external returns (bool);\n\n    function dotnuggV1StorageProxy() external returns (IDotnuggV1StorageProxy res);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Metadata as Metadata} from './IDotnuggV1Metadata.sol';\nimport {IDotnuggV1File as File} from './IDotnuggV1File.sol';\nimport {IDotnuggV1StorageProxy} from './IDotnuggV1StorageProxy.sol';\n\ninterface IDotnuggV1 {\n    function register() external returns (IDotnuggV1StorageProxy proxy);\n\n    function proxyOf(address implementer) external view returns (IDotnuggV1StorageProxy proxy);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                core processors\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function raw(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        bytes calldata data\n    ) external view returns (File.Raw memory res);\n\n    function proc(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        bytes calldata data\n    ) external view returns (File.Processed memory res);\n\n    function comp(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        bytes calldata data\n    ) external view returns (File.Compressed memory res);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            complex resolved processors\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function dat(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        string memory name,\n        string memory desc,\n        bool base64,\n        bytes calldata data\n    ) external view returns (string memory res);\n\n    function img(\n        address implementer,\n        uint256 id,\n        address resolver,\n        bool rekt,\n        bool background,\n        bool base64,\n        bool stats,\n        bytes calldata data\n    ) external view returns (string memory res);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1Metadata {\n    struct Memory {\n        uint8[] ids;\n        uint8[] xovers;\n        uint8[] yovers;\n        uint256 version;\n        address implementer;\n        uint256 artifactId;\n        string[] labels;\n        string[] styles;\n        string background;\n        bytes data;\n    }\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1StorageProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1StorageProxy {\n    function stored(uint8 feature) external view returns (uint8);\n\n    function store(uint8 feature, uint256[][] calldata data) external returns (uint8 amount);\n\n    function unsafeBulkStore(uint256[][][] calldata data) external;\n\n    function init(address _implementer) external;\n\n    function getBatch(uint8[] memory ids) external view returns (uint256[][] memory data);\n\n    function get(uint8 feature, uint8 pos) external view returns (uint256[] memory data);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1File.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Metadata as Metadata} from './IDotnuggV1Metadata.sol';\n\ninterface IDotnuggV1File {\n    struct Raw {\n        uint256[][] file;\n        Metadata.Memory metadata;\n    }\n\n    struct Processed {\n        uint256[] file;\n        Metadata.Memory metadata;\n    }\n\n    struct Compressed {\n        uint256[] file;\n        Metadata.Memory metadata;\n    }\n}\n"
    },
    "src/NuggftV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721, IERC165, IERC721Metadata} from './interfaces/IERC721.sol';\n\nimport {NuggftV1Loan} from './core/NuggftV1Loan.sol';\nimport {NuggftV1Dotnugg} from './core/NuggftV1Dotnugg.sol';\nimport {Trust} from './core/Trust.sol';\n\nimport {INuggftV1Migrator} from './interfaces/nuggftv1/INuggftV1Migrator.sol';\nimport {IDotnuggV1Metadata} from './interfaces/dotnuggv1/IDotnuggV1Metadata.sol';\nimport {IDotnuggV1Implementer} from './interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1} from './interfaces/dotnuggv1/IDotnuggV1.sol';\n\nimport {INuggftV1Token} from './interfaces/nuggftv1/INuggftV1Token.sol';\nimport {INuggftV1Stake} from './interfaces/nuggftv1/INuggftV1Stake.sol';\n\nimport {INuggftV1} from './interfaces/nuggftv1/INuggftV1.sol';\n\nimport {SafeTransferLib} from './libraries/SafeTransferLib.sol';\nimport {SafeCastLib} from './libraries/SafeCastLib.sol';\nimport {ShiftLib} from './libraries/ShiftLib.sol';\n\nimport {NuggftV1StakeType} from './types/NuggftV1StakeType.sol';\nimport {NuggftV1ProofType} from './types/NuggftV1ProofType.sol';\n\n/// @title NuggFT V1\n/// @author nugg.xyz - danny7even & dub6ix\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\n/// @dev the words \"share\" and \"nugg\" are used interchangably throughout\n\n/// deviations from ERC721 standard:\n/// 1. no verificaiton the receiver is a ERC721Reciever - on top of this being a gross waste of gas,\n/// the way the swapping logic works makes this only worth calling when a user places an offer - and\n/// we did not want to call \"onERC721Recieved\" when no token was being sent.\n/// 2.\ncontract NuggftV1 is IERC721Metadata, NuggftV1Loan {\n    using SafeCastLib for uint256;\n\n    using NuggftV1StakeType for uint256;\n\n    constructor(address _defaultResolver) NuggftV1Dotnugg(_defaultResolver) Trust(msg.sender) {}\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IDotnuggV1Implementer).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function name() public pure override returns (string memory) {\n        return 'Nugg Fungible Token V1';\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return 'NUGGFT';\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory res) {\n        uint160 safeTokenId = tokenId.safe160();\n\n        res = dotnuggV1.dat(address(this), tokenId, dotnuggV1ResolverOf(safeTokenId), symbol(), name(), true, '');\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                CORE\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function dotnuggV1ImplementerCallback(uint256 tokenId) public view override returns (IDotnuggV1Metadata.Memory memory data) {\n        (\n            ,\n            data.ids, //\n            data.xovers,\n            data.yovers,\n            data.styles,\n            data.background\n        ) = proofToDotnuggMetadata(tokenId.safe160());\n\n        data.labels = new string[](8);\n        data.version = 1;\n        data.artifactId = tokenId;\n        data.implementer = address(this);\n\n        data.labels[0] = 'BASE';\n        data.labels[1] = 'EYES';\n        data.labels[2] = 'MOUTH';\n        data.labels[3] = 'HAIR';\n        data.labels[4] = 'HAT';\n        data.labels[5] = 'BACK';\n        data.labels[6] = 'NECK';\n        data.labels[7] = 'HOLD';\n\n        return data;\n    }\n\n    /// @inheritdoc INuggftV1Token\n    function trustedMint(uint160 tokenId, address to) external payable override requiresTrust {\n        require(tokenId < TRUSTED_MINT_TOKENS && tokenId != 0, 'G:1');\n\n        addStakedShareFromMsgValue(0);\n\n        setProof(tokenId);\n\n        _mintTo(to, tokenId);\n\n        emit Mint(tokenId, uint96(msg.value));\n    }\n\n    // modifier haha() {\n    //     uint256 price = gasleft();\n\n    //     _;\n    //     uint256 price2 = gasleft();\n\n    //     assert(price < 90000 && price - price2 < 58000);\n    // }\n\n    /// @inheritdoc INuggftV1Token\n    function mint(uint160 tokenId) public payable override {\n        require(tokenId < UNTRUSTED_MINT_TOKENS + TRUSTED_MINT_TOKENS && tokenId > TRUSTED_MINT_TOKENS, 'G:1');\n\n        addStakedShareFromMsgValue(0);\n\n        setProof(tokenId);\n\n        _mintTo(msg.sender, tokenId);\n\n        emit Mint(tokenId, uint96(msg.value));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                BURN/MIGRATE\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Stake\n    function burn(uint160 tokenId) external {\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        SafeTransferLib.safeTransferETH(msg.sender, ethOwed);\n\n        emit Burn(tokenId, msg.sender, ethOwed);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function migrate(uint160 tokenId) external {\n        require(migrator != address(0), 'T:4');\n\n        // stores the proof before deleting the nugg\n        uint256 proof = proofOf(tokenId);\n\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        INuggftV1Migrator(migrator).nuggftMigrateFromV1{value: ethOwed}(tokenId, proof, msg.sender);\n\n        emit MigrateV1Sent(migrator, tokenId, proof, msg.sender, ethOwed);\n    }\n\n    function testnet__exploit() external {\n        SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n    }\n\n    /// @notice removes a staked share from the contract,\n    /// @dev this is the only way to remove a share\n    /// @dev caculcates but does not handle dealing the eth - which is handled by the two helpers above\n    /// @dev ensures the user is the owner of the nugg\n    /// @param tokenId the id of the nugg being unstaked\n    /// @return ethOwed -> the amount of eth owed to the unstaking user - equivilent to \"ethPerShare\"\n    function subStakedShare(uint160 tokenId) internal returns (uint96 ethOwed) {\n        // reverts if token does not exist\n        address owner = _ownerOf(tokenId);\n\n        require(_getApproved(tokenId) == address(this) && owner == msg.sender, 'T:3');\n\n        uint256 cache = stake;\n\n        // hanles all logic not related to staking the nugg\n        delete owners[tokenId];\n        delete approvals[tokenId];\n\n        delete swaps[tokenId];\n        delete loans[tokenId];\n        delete proofs[tokenId];\n        delete resolvers[tokenId];\n\n        emitTransferEvent(owner, address(0), tokenId);\n\n        ethOwed = calculateEthPerShare(cache);\n\n        /// TODO - test migration\n        assert(cache.shares() >= 1);\n        assert(cache.staked() >= ethOwed);\n\n        cache = cache.subShares(1);\n        cache = cache.subStaked(ethOwed);\n\n        stake = cache;\n\n        emit Stake(cache);\n    }\n}\n"
    },
    "src/core/NuggftV1Loan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Loan} from '../interfaces/nuggftv1/INuggftV1Loan.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1AgentType} from '../types/NuggftV1AgentType.sol';\n\nimport {NuggftV1Swap} from './NuggftV1Swap.sol';\n\nabstract contract NuggftV1Loan is INuggftV1Loan, NuggftV1Swap {\n    using SafeCastLib for uint256;\n\n    using NuggftV1AgentType for uint256;\n\n    mapping(uint160 => uint256) loans;\n\n    uint24 constant LIQUIDATION_PERIOD = 69;\n\n    uint96 constant REBALANCE_FEE_BPS = 100;\n\n    /// @inheritdoc INuggftV1Loan\n    function loan(uint160 tokenId) external override {\n        require(_ownerOf(tokenId) == msg.sender, 'L:0');\n\n        uint256 loanData = NuggftV1AgentType.newAgentType(epoch(), msg.sender, ethPerShare(), false);\n\n        loans[tokenId] = loanData; // starting swap data\n\n        approvedTransferToSelf(tokenId);\n\n        uint96 value = loanData.eth();\n\n        SafeTransferLib.safeTransferETH(msg.sender, value);\n\n        emit Loan(tokenId, value);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function liquidate(uint160 tokenId) external payable override {\n        (uint96 toLiquidate, uint96 toRebalance, uint96 owed, uint24 epochDue, address loaner) = loanInfo(tokenId);\n\n        assert(address(this) == _ownerOf(tokenId)); // should always be true - should revert in loanInfo\n\n        delete loans[tokenId];\n\n        address benif = msg.sender;\n\n        if (epochDue >= epoch()) {\n            // if liquidaton deadline has not passed - check perrmission\n            require(_isOperatorFor(msg.sender, loaner), 'L:1');\n            benif = loaner;\n        }\n\n        uint96 value = msg.value.safe96();\n\n        require(toLiquidate <= value, 'L:2');\n\n        uint96 overpayment = value - toLiquidate;\n\n        addStakedEth(toRebalance + overpayment);\n\n        SafeTransferLib.safeTransferETH(benif, owed);\n\n        checkedTransferFromSelf(benif, tokenId);\n\n        emit Liquidate(tokenId, value, msg.sender);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function rebalance(uint160 tokenId) external payable override {\n        (, uint96 toRebalance, uint96 earned, , address loaner) = loanInfo(tokenId);\n\n        assert(address(this) == _ownerOf(tokenId)); // should always be true - should revert in loanInfo\n\n        require(toRebalance <= msg.value, 'L:3');\n\n        uint96 value = msg.value.safe96();\n\n        // must be done before new principal is calculated\n        addStakedEth(value);\n\n        uint256 res = NuggftV1AgentType.newAgentType(epoch(), loaner, ethPerShare(), false);\n\n        loans[tokenId] = res;\n\n        SafeTransferLib.safeTransferETH(loaner, earned);\n\n        emit Rebalance(tokenId, value);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function valueForLiquidate(uint160 tokenId) external view returns (uint96 res) {\n        (res, , , , ) = loanInfo(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function valueForRebalance(uint160 tokenId) external view returns (uint96 res) {\n        (, res, , , ) = loanInfo(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function loanInfo(uint160 tokenId)\n        public\n        view\n        override\n        returns (\n            uint96 toLiquidate,\n            uint96 toRebalance,\n            uint96 earned,\n            uint24 epochDue,\n            address loaner\n        )\n    {\n        uint256 cache = loans[tokenId];\n\n        loaner = cache.account();\n\n        require(loaner != address(0), 'L:4');\n\n        // the amount of eth currently loanded by user\n        uint96 curr = cache.eth();\n\n        uint96 activeEps = ethPerShare();\n\n        assembly {\n            toRebalance := div(mul(curr, REBALANCE_FEE_BPS), 10000)\n        }\n\n        toLiquidate = curr + toRebalance;\n\n        unchecked {\n            // value earned while lone was taken out\n            earned = toLiquidate >= activeEps ? 0 : activeEps - toLiquidate;\n\n            epochDue = cache.epoch() + LIQUIDATION_PERIOD;\n        }\n    }\n}\n"
    },
    "src/core/NuggftV1Dotnugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1StorageProxy} from '../interfaces/dotnuggv1/IDotnuggV1StorageProxy.sol';\n\nimport {IDotnuggV1} from '../interfaces/dotnuggv1/IDotnuggV1.sol';\nimport {IDotnuggV1Metadata} from '../interfaces/dotnuggv1/IDotnuggV1Metadata.sol';\nimport {IDotnuggV1Resolver} from '../interfaces/dotnuggv1/IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Implementer} from '../interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {INuggftV1Dotnugg} from '../interfaces/nuggftv1/INuggftV1Dotnugg.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {NuggftV1Token} from './NuggftV1Token.sol';\n\nimport {Trust} from './Trust.sol';\n\nabstract contract NuggftV1Dotnugg is INuggftV1Dotnugg, NuggftV1Token, Trust {\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    struct Settings {\n        mapping(uint256 => uint256) anchorOverrides;\n        mapping(uint256 => string) styles;\n        string background;\n    }\n\n    mapping(uint160 => Settings) settings;\n\n    /// @inheritdoc IDotnuggV1Implementer\n    IDotnuggV1StorageProxy public override dotnuggV1StorageProxy;\n\n    /// @inheritdoc INuggftV1Dotnugg\n    IDotnuggV1 public override dotnuggV1;\n\n    mapping(uint256 => address) resolvers;\n\n    uint256 internal featureLengths;\n\n    constructor(address _dotnuggV1) {\n        require(_dotnuggV1 != address(0), 'F:4');\n        dotnuggV1 = IDotnuggV1(_dotnuggV1);\n        dotnuggV1StorageProxy = dotnuggV1.register();\n    }\n\n    /// @inheritdoc IDotnuggV1Implementer\n    function dotnuggV1TrustCallback(address caller) external view override(IDotnuggV1Implementer) returns (bool res) {\n        return isTrusted[caller];\n    }\n\n    /// @inheritdoc INuggftV1Dotnugg\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external requiresTrust {\n        uint8 len = dotnuggV1StorageProxy.store(feature, data);\n\n        uint256 cache = featureLengths;\n\n        uint256 newLen = _lengthOf(cache, feature) + len;\n\n        featureLengths = ShiftLib.set(cache, 8, feature * 8, newLen);\n    }\n\n    function lengthOf(uint8 feature) external view returns (uint8) {\n        return _lengthOf(featureLengths, feature);\n    }\n\n    function _lengthOf(uint256 cache, uint8 feature) internal pure returns (uint8) {\n        return uint8(ShiftLib.get(cache, 8, feature * 8));\n    }\n\n    /// @inheritdoc INuggftV1Dotnugg\n    function setDotnuggV1Resolver(uint256 tokenId, address to) public virtual override {\n        require(_isOperatorForOwner(msg.sender, tokenId.safe160()), 'F:5');\n\n        resolvers[tokenId] = to;\n\n        emit DotnuggV1ConfigUpdated(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Dotnugg\n    function dotnuggV1ResolverOf(uint256 tokenId) public view virtual override returns (address) {\n        return resolvers[tokenId.safe160()];\n    }\n\n    /// @inheritdoc INuggftV1Dotnugg\n    function setDotnuggV1AnchorOverrides(\n        uint160 tokenId,\n        uint16 itemId,\n        uint256 x,\n        uint256 y\n    ) external override {\n        require(x < 64 && y < 64, 'UNTEESTED:1');\n\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        settings[tokenId].anchorOverrides[itemId] = x | (y << 6);\n\n        emit DotnuggV1ConfigUpdated(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Dotnugg\n    function setDotnuggV1Background(uint160 tokenId, string memory s) external override {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        settings[tokenId].background = s;\n\n        emit DotnuggV1ConfigUpdated(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Dotnugg\n    function setDotnuggV1Style(\n        uint160 tokenId,\n        uint16 itemId,\n        string memory s\n    ) external override {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        settings[tokenId].styles[itemId] = s;\n\n        emit DotnuggV1ConfigUpdated(tokenId);\n    }\n\n    function hasResolver(uint160 tokenId) internal view returns (bool) {\n        return resolvers[tokenId] != address(0);\n    }\n}\n"
    },
    "src/core/Trust.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ITrust} from '../interfaces/ITrust.sol';\n\n/// @notice Ultra minimal authorization logic for smart contracts.\n/// @author Inspired by Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/auth.sol)\nabstract contract Trust is ITrust {\n    event UserTrustUpdated(address indexed user, bool trusted);\n\n    mapping(address => bool) public override isTrusted;\n\n    constructor(address initialUser) {\n        isTrusted[initialUser] = true;\n        isTrusted[address(this)] = true;\n\n        emit UserTrustUpdated(initialUser, true);\n    }\n\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\n        isTrusted[user] = trusted;\n\n        emit UserTrustUpdated(user, trusted);\n    }\n\n    modifier requiresTrust() {\n        _requiresTrust();\n        _;\n    }\n\n    function _requiresTrust() internal view {\n        require(isTrusted[msg.sender], 'UNTRUSTED');\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Migrator {\n    event MigrateV1Accepted(address v1, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable;\n}\n"
    },
    "src/libraries/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\nlibrary SafeTransferLib {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               ETH OPERATIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, 'Z:0');\n    }\n}\n"
    },
    "src/libraries/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        require(x <= type(uint160).max);\n        y = uint160(x);\n    }\n\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        require(x <= type(uint96).max);\n        y = uint96(x);\n    }\n\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        require(x <= type(uint64).max);\n        y = uint64(x);\n    }\n\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        require(x <= type(uint32).max);\n        y = uint32(x);\n    }\n\n    function safe24(uint256 x) internal pure returns (uint24 y) {\n        assembly {\n            if gt(x, 0xfff) {\n                revert(0, 0)\n            }\n            y := x\n        }\n        require(x <= type(uint24).max);\n        y = uint24(x);\n    }\n\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        require(x <= type(uint16).max);\n        y = uint16(x);\n    }\n\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        require(x <= type(uint8).max);\n        y = uint8(x);\n    }\n}\n"
    },
    "src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from './SafeCastLib.sol';\n\nlibrary ShiftLib {\n    using SafeCastLib for uint256;\n\n    /// @notice creates a bit mask\n    /// @dev res = (2 ^ bits) - 1\n    /// @param bits bit size of mask\n    /// @return res the mask\n    function mask(uint8 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(shl(bits, 1), 1)\n        }\n    }\n\n    function fullsubmask(uint8 bits, uint8 pos) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << pos);\n    }\n\n    function set(\n        uint256 preStore,\n        uint8 bits,\n        uint8 pos,\n        uint256 value\n    ) internal pure returns (uint256 res) {\n        // res = preStore & fullsubmask(bits, pos);\n        res = fullsubmask(bits, pos);\n\n        assembly {\n            value := shl(pos, value)\n            res := or(and(preStore, res), value)\n        }\n\n        // res |= value;\n    }\n\n    function get(\n        uint256 store,\n        uint8 bits,\n        uint8 pos\n    ) internal pure returns (uint256 res) {\n        res = mask(bits);\n        assembly {\n            res := and(shr(pos, store), res)\n        }\n        // value &= mask(bits);\n    }\n}\n"
    },
    "src/types/NuggftV1StakeType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nlibrary NuggftV1StakeType {\n    /// 96 protocol\n    /// 96 stakedEth\n    /// 64 stakedShares\n\n    function proto(uint256 cache) internal pure returns (uint96 res) {\n        res = uint96(cache);\n    }\n\n    function proto(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        res = cache & ShiftLib.fullsubmask(96, 0);\n        res |= update;\n    }\n\n    function addProto(uint256 cache, uint96 add) internal pure returns (uint256 res) {\n        add += proto(cache);\n        res = proto(cache, add);\n    }\n\n    function subProto(uint256 cache, uint96 sub) internal pure returns (uint256 res) {\n        sub = proto(cache) - sub;\n        res = proto(cache, sub);\n    }\n\n    // @test input output unit test\n    function staked(uint256 cache) internal pure returns (uint96 res) {\n        // using casting to select only 96\n        res = uint96(cache >> 96);\n    }\n\n    function staked(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        // clear stakedEth\n        res = cache & ShiftLib.fullsubmask(96, 96);\n        res |= uint256(update) << 96;\n    }\n\n    function addStaked(uint256 cache, uint96 add) internal pure returns (uint256 res) {\n        add += staked(cache);\n        res = staked(cache, add);\n    }\n\n    function subStaked(uint256 cache, uint96 sub) internal pure returns (uint256 res) {\n        sub = staked(cache) - sub;\n        res = staked(cache, sub);\n    }\n\n    // @test input output unit test\n    function shares(uint256 cache) internal pure returns (uint64 res) {\n        res = uint64(cache >> 192);\n    }\n\n    function addShares(uint256 cache, uint64 add) internal pure returns (uint256 res) {\n        add += shares(cache);\n        res = shares(cache, add);\n    }\n\n    function subShares(uint256 cache, uint64 sub) internal pure returns (uint256 res) {\n        sub = shares(cache) - sub;\n        res = shares(cache, sub);\n    }\n\n    function shares(uint256 cache, uint64 update) internal pure returns (uint256 res) {\n        res = cache & type(uint192).max;\n        res |= (uint256(update) << 192);\n    }\n}\n"
    },
    "src/types/NuggftV1ProofType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\n/// @notice abstracts all the logic for converting the proof between a the uint256 which is stored in\n/// in state and the the 4 uint8 arrays that it consists off.\n/// @dev Explain to a developer any extra details\n/// @dev itemIds are externally 16 bits, but here there are referenced as 8 bit ids in one of 8 indexs\n/// where the id is the position the item exists in the file storage, and the index is the feature id\n/// @dev there is not check - but dotnugg v1 only allows for max 63 for size, so anchor overrides should\n/// reflect this.\n/// @dev pushing and pulling is only set up for the extra array, so the user must manage their default array\n/// by passing through the extra array - this is to reduce complexity\n/// @dev see the dotnugg specification for more clarificaiton on the values used here\n///\n///  uint256 bit allocation of proof \"state\" variable:\n/// ┌───────────┬─────────┬────────────────────────────────────┐\n/// │  0 - 63   │ 64 bits │  default item ids - 8 x 8 bits     │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 64 - 127  │ 64 bits │  extra item ids - 8 x 8 bits       │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 128 - 191 │ 64 bits │  x anchor overrides - 8 x 8 bits   │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 192 - 255 │ 64 bits │  y anchor overrides - 8 x 8 bits   │\n/// └───────────┴─────────┴────────────────────────────────────┘\n///\nlibrary NuggftV1ProofType {\n    /// @notice converts the proof state into a human readable form\n    /// @dev fully parses the proof from a uint256 to 4 uint8 arrays\n    /// @param state -> the uint256 proof state\n    /// @return proof -> the uint256 proof state\n    /// @return defaultIds -> the modifed uint256 proof state\n    /// @return extraIds -> the modifed uint256 proof state\n    /// @return xOverrides -> the modifed uint256 proof state\n    /// @return yOverrides -> the modifed uint256 proof state\n    // function fullProof(uint256 state)\n    //     internal\n    //     pure\n    //     returns (\n    //         uint256 proof,\n    //         uint8[] memory defaultIds,\n    //         uint8[] memory extraIds,\n    //         uint8[] memory xOverrides,\n    //         uint8[] memory yOverrides\n    //     )\n    // {\n    //     proof = state;\n    //     defaultIds = ShiftLib.getArray(state, 0);\n    //     extraIds = ShiftLib.getArray(state, 64);\n    //     xOverrides = ShiftLib.getArray(state, 128);\n    //     yOverrides = ShiftLib.getArray(state, 192);\n    // }\n\n    /// @notice sets an item to the extra array\n    /// @dev extra array must be empty at the feature positon being added to\n    /// @param state -> the uint256 proof state\n    /// @param itemId -> the itemId being added\n    /// @return res -> the modifed uint256 proof state\n    // function pushToExtra(uint256 state, uint16 itemId) internal pure returns (uint256 res) {\n    //     uint8[] memory arr = ShiftLib.getArray(state, 64);\n\n    //     (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n    //     require(arr[feat] == 0, 'P:D');\n\n    //     arr[feat] = pos;\n\n    //     res = ShiftLib.setArray(state, 64, arr);\n    // }\n\n    /// / @notice removes an item from the extra array\n    // / @dev extra array must NOT be empty at the feature positon being removed\n    // / @dev the extra array must have that specific feature in that postion\n    // / @param state -> the uint256 proof state\n    // / @param itemId -> the itemId being removed\n    // / @return res -> the modifed uint256 proof state\n    // function pullFromExtra(uint256 state, uint16 itemId) internal pure returns (uint256 res) {\n    //     uint8[] memory arr = ShiftLib.getArray(state, 64);\n\n    //     (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n    //     require(feat != 0, 'P:F');\n\n    //     require(arr[feat] == pos, 'P:E');\n\n    //     arr[feat] = 0;\n\n    //     res = ShiftLib.setArray(state, 64, arr);\n    // }\n\n    function search(uint256 state, uint256 itemId) internal pure returns (uint8 index) {\n        state >>= 3;\n\n        do {\n            if (state & 11 == itemId) return index;\n            index++;\n        } while ((state >>= 11) != 0);\n\n        require(index != 22, 'UNTESTED');\n\n        // if (index == 22) revert('UNTESTED');\n    }\n\n    function swapIndexs(\n        uint256 state,\n        uint8 index1,\n        uint8 index2\n    ) internal pure returns (uint256 res) {\n        uint256 tmp = getIndex(state, index1);\n        res = setIndex(state, index1, getIndex(state, index2));\n        res = setIndex(state, index2, tmp);\n    }\n\n    function getIndex(uint256 state, uint8 index) internal pure returns (uint16 res) {\n        res = uint16(ShiftLib.get(state, 11, 3 + 11 * index));\n    }\n\n    function setIndex(\n        uint256 state,\n        uint8 index,\n        uint256 id\n    ) internal pure returns (uint256 res) {\n        res = ShiftLib.set(state, 11, 3 + 11 * index, id);\n    }\n\n    /// @notice updates the x and y override arrays\n    /// @dev all must be set at once\n    /// @param state -> the uint256 proof state\n    /// @param xOverrides -> uint8 array of new x overrides\n    /// @param yOverrides -> uint8 array of new x overrides\n    /// @return res -> the modifed uint256 proof state\n    // function setNewAnchorOverrides(\n    //     uint256 state,\n    //     uint8[] memory xOverrides,\n    //     uint8[] memory yOverrides\n    // ) internal pure returns (uint256 res) {\n    //     res = ShiftLib.setArray(state, 128, xOverrides);\n    //     res = ShiftLib.setArray(res, 192, yOverrides);\n    // }\n\n    /// @notice clears the anchor overrides for a specific feature\n    /// @dev this should be called each time an item is added or removed from a feature\n    /// @param state -> the uint256 proof state\n    /// @param feature -> the feature to switch items for\n    /// @return res -> the modifed uint256 proof state\n    // function clearAnchorOverridesForFeature(uint256 state, uint8 feature) internal pure returns (uint256 res) {\n    //     uint8[] memory x = ShiftLib.getArray(state, 128);\n    //     uint8[] memory y = ShiftLib.getArray(state, 192);\n\n    //     y[feature] = 0;\n    //     x[feature] = 0;\n\n    //     res = ShiftLib.setArray(state, 128, x);\n    //     res = ShiftLib.setArray(res, 192, y);\n    // }\n\n    /// @notice parses the external itemId into a feautre and position\n    /// @dev this follows dotnugg v1 specification\n    /// @param itemId -> the external itemId\n    /// @return feat -> the feautre of the item\n    /// @return pos -> the file storage position of the item\n    function parseItemId(uint16 itemId) internal pure returns (uint8 feat, uint8 pos) {\n        feat = uint8(itemId >> 8);\n        pos = uint8(itemId & 0xff);\n    }\n}\n"
    },
    "src/types/NuggftV1AgentType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\nlibrary NuggftV1AgentType {\n    using SafeCastLib for uint256;\n\n    // 10**13\n    uint96 constant COMPRESSION_LOSS = 10e8;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               CALCULATION\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // @test  manual\n    function addIncrement(uint96 value) internal pure returns (uint96 res) {\n        res = value * 10200;\n        assembly {\n            res := div(res, 10000)\n        }\n    }\n\n    // @test  manual\n    function compressEthRoundDown(uint96 value) internal pure returns (uint96 res) {\n        assembly {\n            res := mul(div(value, COMPRESSION_LOSS), COMPRESSION_LOSS)\n        }\n    }\n\n    // @test  manual\n    function compressEthRoundUp(uint96 value) internal pure returns (uint96 res) {\n        assembly {\n            res := mod(value, COMPRESSION_LOSS)\n        }\n        if (res > 0) {\n            assembly {\n                res := mul(add(div(value, COMPRESSION_LOSS), 1), COMPRESSION_LOSS)\n            }\n        } else {\n            return compressEthRoundDown(value);\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                              SHIFT HELPERS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    // @test input output unit test\n    // type(uint96).max / 10e8 =   792281625142643375935\n    // type(uint70).max          = 1180591620717411303423\n    function eth(uint256 input) internal pure returns (uint96 res) {\n        input = ShiftLib.get(input, 70, 160);\n        assembly {\n            res := mul(input, COMPRESSION_LOSS)\n        }\n        // return input.safe96();\n    }\n\n    function eth(uint256 input, uint96 update) internal pure returns (uint256 cache) {\n        assembly {\n            update := div(update, COMPRESSION_LOSS) // bye byte wei\n        }\n        cache = ShiftLib.set(input, 70, 160, update);\n    }\n\n    // @test  input output unit test\n    function epoch(uint256 input, uint24 update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 24, 230, update);\n    }\n\n    function epoch(uint256 input) internal pure returns (uint24 res) {\n        return uint24(ShiftLib.get(input, 24, 230));\n    }\n\n    // @test  input output unit test\n    function account(uint256 input) internal pure returns (address res) {\n        res = address(uint160(ShiftLib.get(input, 160, 0)));\n    }\n\n    function account(uint256 input, address update) internal pure returns (uint256 output) {\n        output = ShiftLib.set(input, 160, 0, uint160(update));\n    }\n\n    // @test  input output unit test\n    function isOwner(uint256 input, bool update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 1, 255, update ? 0x1 : 0x0);\n    }\n\n    function isOwner(uint256 input) internal pure returns (bool output) {\n        output = ShiftLib.get(input, 1, 255) == 0x1;\n    }\n\n    // @test  check to see if it does this - will be easy\n    function flag(uint256 input) internal pure returns (uint256 res) {\n        res = ShiftLib.set(input, 1, 254, 0x01);\n    }\n\n    // @test  manual\n    function newAgentType(\n        uint24 _epoch,\n        address _account,\n        uint96 _eth,\n        bool _isOwner\n    ) internal pure returns (uint256 res) {\n        res = epoch(res, _epoch);\n        res = account(res, _account);\n        if (_isOwner) res = isOwner(res, true);\n        (res) = eth(res, _eth);\n        res = flag(res);\n    }\n}\n"
    },
    "src/core/NuggftV1Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Swap} from '../interfaces/nuggftv1/INuggftV1Swap.sol';\n\nimport {NuggftV1Stake} from './NuggftV1Stake.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1AgentType} from '../types/NuggftV1AgentType.sol';\n\n/// @notice mechanism for trading of nuggs between users (and items between nuggs)\n/// @dev Explain to a developer any extra details\nabstract contract NuggftV1Swap is INuggftV1Swap, NuggftV1Stake {\n    using SafeCastLib for uint256;\n\n    using NuggftV1AgentType for uint256;\n\n    struct Mapping {\n        Storage self;\n        mapping(uint16 => Storage) items;\n    }\n\n    struct Storage {\n        uint256 data;\n        mapping(address => uint256) offers;\n    }\n\n    struct Memory {\n        uint256 swapData;\n        uint256 offerData;\n        uint24 activeEpoch;\n        address sender;\n    }\n\n    mapping(uint16 => uint256) protocolItems;\n    mapping(uint160 => Mapping) swaps;\n\n    uint96 public constant MIN_OFFER = 10**8 * 100;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  delegate\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function delegate(uint160 tokenId) external payable override {\n        // require(_isOperatorFor(msg.sender, sender), 'S:0');\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, msg.sender);\n\n        // make sure user is not the owner of swap\n        // we do not know how much to give them when they call \"claim\" otherwise\n\n        uint96 lead;\n\n        if (m.activeEpoch == tokenId && m.swapData == 0) {\n            // to ensure we at least have enough to increment the offer amount by 2%\n            require(msg.value >= MIN_OFFER, 'S:1');\n\n            // we do not need this, could take tokenId out as an argument - but do not want to give users\n            // the ability to accidently place an offer for nugg A and end up minting nugg B.\n            assert(m.offerData == 0);\n\n            lead = msg.value.safe96();\n\n            (s.data) = NuggftV1AgentType.newAgentType(m.activeEpoch, m.sender, lead, false);\n\n            addStakedShareFromMsgValue(0);\n\n            setProofFromEpoch(tokenId);\n\n            emitTransferEvent(address(0), address(this), tokenId);\n        } else {\n            require(m.swapData != 0, 'S:4');\n\n            if (m.offerData != 0) {\n                // forces user to claim previous swap before acting on this one\n                // prevents owner from COMMITTING on their own swap - not offering\n                require(m.offerData.epoch() >= m.activeEpoch, 'S:R');\n\n                require(!m.offerData.isOwner(), 'NOPE'); // always be caught by the require above\n            }\n\n            // if the leader \"owns\" the swap, then it was initated by them - \"commit\" must be executed\n            (lead) = m.swapData.isOwner() ? commit(s, m) : offer(s, m);\n        }\n\n        emit Delegate(tokenId, msg.sender, lead);\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function delegateItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external payable override {\n        require(_ownerOf(buyerTokenId) == msg.sender, 'S:6');\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(buyerTokenId));\n\n        require(m.swapData != 0, 'S:S');\n\n        if (m.offerData != 0) {\n            // forces user to claim previous swap before acting on this one\n            // prevents owner from COMMITTING on their own swap - not offering\n            require(m.offerData.epoch() >= m.activeEpoch, 'S:7');\n\n            require(!m.offerData.isOwner(), 'NOPE'); // always be caught by the require above\n        }\n\n        uint96 lead = m.offerData == 0 && m.swapData.isOwner() ? commit(s, m) : offer(s, m);\n\n        emit DelegateItem(encodeSellingItemId(sellerTokenId, itemId), buyerTokenId, lead);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  claim\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function claim(uint160 tokenId) external override {\n        // require(_isOperatorFor(msg.sender, sender), 'S:8');\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, msg.sender);\n\n        delete s.offers[msg.sender];\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            delete s.data;\n\n            checkedTransferFromSelf(msg.sender, tokenId);\n        } else {\n            SafeTransferLib.safeTransferETH(msg.sender, m.offerData.eth());\n        }\n\n        emit Claim(tokenId, msg.sender);\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function claimItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external override {\n        require(_ownerOf(buyerTokenId) == msg.sender, 'S:9');\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(buyerTokenId));\n\n        delete s.offers[address(buyerTokenId)];\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            delete s.data;\n\n            require(protocolItems[itemId] > 0, 'P:3');\n\n            addItem(buyerTokenId, itemId);\n\n            protocolItems[itemId]--;\n        } else {\n            SafeTransferLib.safeTransferETH(_ownerOf(buyerTokenId), m.offerData.eth());\n        }\n\n        emit ClaimItem(encodeSellingItemId(sellerTokenId, itemId), buyerTokenId);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  swap\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function swap(uint160 tokenId, uint96 floor) external override {\n        require(_ownerOf(tokenId) == msg.sender, 'S:A');\n\n        require(floor >= ethPerShare(), 'S:B');\n\n        approvedTransferToSelf(tokenId);\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, msg.sender);\n\n        // make sure swap does not exist - this logically should never happen\n        require(m.swapData == 0, 'NOPE2');\n\n        // no need to check dust as no value is being transfered\n        (s.data) = NuggftV1AgentType.newAgentType(0, msg.sender, floor, true);\n\n        emit Swap(tokenId, floor);\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function swapItem(\n        uint160 tokenId,\n        uint16 itemId,\n        uint96 floor\n    ) external override {\n        require(_ownerOf(tokenId) == msg.sender, 'S:C');\n\n        // will revert if they do not have the item\n        removeItem(tokenId, itemId);\n\n        protocolItems[itemId]++;\n\n        (Storage storage s, Memory memory m) = loadItemSwap(tokenId, itemId, address(tokenId));\n\n        // cannot sell two of the same item at same time\n        require(m.swapData == 0, 'S:D');\n\n        (s.data) = NuggftV1AgentType.newAgentType(0, address(tokenId), floor, true);\n\n        emit Swap(tokenId, floor);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                    view\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // / @inheritdoc INuggftV1Swap\n    function valueForDelegate(address sender, uint160 tokenId)\n        external\n        view\n        override\n        returns (\n            bool canDelegate,\n            uint96 nextSwapAmount,\n            uint96 senderCurrentOffer\n        )\n    {\n        canDelegate = true;\n\n        (, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        if (m.swapData == 0) {\n            if (m.activeEpoch == tokenId) {\n                // swap is minting\n                nextSwapAmount = NuggftV1AgentType.compressEthRoundUp(minSharePrice());\n            } else {\n                // swap does not exist\n                return (false, 0, 0);\n            }\n        } else {\n            if (m.offerData.isOwner() && m.swapData.isOwner()) canDelegate = false;\n\n            senderCurrentOffer = m.offerData.eth();\n\n            nextSwapAmount = m.swapData.eth();\n\n            if (nextSwapAmount < ethPerShare()) {\n                nextSwapAmount = ethPerShare();\n            }\n        }\n\n        if (nextSwapAmount == 0) {\n            nextSwapAmount = MIN_OFFER;\n        } else {\n            nextSwapAmount = NuggftV1AgentType.addIncrement(nextSwapAmount);\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                internal\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function commit(Storage storage s, Memory memory m) internal returns (uint96 lead) {\n        require(msg.value >= ethPerShare(), 'S:5');\n\n        require(m.offerData == 0 && m.swapData != 0, 'NOPE3');\n\n        require(m.swapData.isOwner(), 'NOPE4');\n\n        // forces a user not to commit on their own swap\n        // commented out as the logic is handled by S:R\n        // require(!m.offerData.isOwner()(), 'S:3');\n\n        (uint256 newSwapData, uint96 increment) = updateSwapDataWithEpoch(m.swapData, m.activeEpoch + 1, m.sender, 0);\n\n        s.data = newSwapData;\n\n        s.offers[m.swapData.account()] = m.swapData.isOwner(false).epoch(m.activeEpoch + 1);\n\n        lead = newSwapData.eth();\n        addStakedEth(increment);\n    }\n\n    function offer(Storage storage s, Memory memory m) internal returns (uint96 lead) {\n        // make sure swap is still active\n        require(m.activeEpoch <= m.swapData.epoch(), 'S:F');\n\n        if (m.swapData.account() != m.sender) s.offers[m.swapData.account()] = m.swapData;\n\n        (uint256 newSwapData, uint96 increment) = updateSwapDataWithEpoch(m.swapData, m.swapData.epoch(), m.sender, m.offerData.eth());\n\n        s.data = newSwapData;\n\n        lead = newSwapData.eth();\n        addStakedEth(increment);\n    }\n\n    function checkClaimerIsWinnerOrLoser(Memory memory m) internal pure returns (bool winner) {\n        require(m.offerData != 0, 'S:E');\n\n        bool isOver = m.activeEpoch > m.swapData.epoch();\n        bool isLeader = m.offerData.account() == m.swapData.account();\n        bool isOwner = m.swapData.isOwner() && m.offerData.isOwner();\n\n        return isLeader && (isOwner || isOver);\n    }\n\n    // @test  unit\n    function updateSwapDataWithEpoch(\n        uint256 prevSwapData,\n        uint24 _epoch,\n        address account,\n        uint96 currUserOffer\n    ) internal view returns (uint256 res, uint96 increment) {\n        uint96 baseEth = prevSwapData.eth();\n\n        currUserOffer += msg.value.safe96();\n\n        require(NuggftV1AgentType.addIncrement(baseEth) <= currUserOffer, 'S:G');\n\n        (res) = NuggftV1AgentType.newAgentType(_epoch, account, currUserOffer, false);\n\n        increment = currUserOffer - baseEth;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TOKEN SWAP\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function loadTokenSwap(uint160 tokenId, address account) internal view returns (Storage storage s, Memory memory m) {\n        s = swaps[tokenId].self;\n        m = _load(s, account);\n    }\n\n    function loadItemSwap(\n        uint160 tokenId,\n        uint16 itemId,\n        address account\n    ) internal view returns (Storage storage s, Memory memory m) {\n        s = swaps[tokenId].items[itemId];\n        m = _load(s, account);\n    }\n\n    function _load(Storage storage ptr, address account) private view returns (Memory memory m) {\n        uint256 cache = ptr.data;\n        m.swapData = cache;\n        m.activeEpoch = epoch();\n        m.sender = account;\n\n        if (account == cache.account()) {\n            m.offerData = cache;\n        } else {\n            m.offerData = ptr.offers[account];\n        }\n    }\n\n    function encodeSellingItemId(uint160 tokenId, uint16 itemId) internal pure returns (uint176) {\n        return (uint176(itemId) << 160) | tokenId;\n    }\n}\n"
    },
    "src/core/NuggftV1Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggftV1Proof} from './NuggftV1Proof.sol';\n\nimport {INuggftV1Migrator} from '../interfaces/nuggftv1/INuggftV1Migrator.sol';\nimport {INuggftV1Stake} from '../interfaces/nuggftv1/INuggftV1Stake.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1StakeType} from '../types/NuggftV1StakeType.sol';\nimport '../_test/utils/console.sol';\n\nabstract contract NuggftV1Stake is INuggftV1Stake, NuggftV1Proof {\n    using SafeCastLib for uint256;\n    using NuggftV1StakeType for uint256;\n\n    address public migrator;\n\n    uint256 internal stake;\n\n    uint96 constant PROTOCOL_FEE_BPS = 1000;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc INuggftV1Stake\n    function extractProtocolEth() external requiresTrust {\n        uint256 cache = stake;\n\n        SafeTransferLib.safeTransferETH(msg.sender, cache.proto());\n\n        cache = cache.proto(0);\n\n        emit Stake(cache);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function setMigrator(address _migrator) external requiresTrust {\n        migrator = _migrator;\n\n        emit MigratorV1Updated(_migrator);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                VIEW\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc INuggftV1Stake\n    function ethPerShare() public view override returns (uint96 res) {\n        res = calculateEthPerShare(stake);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function minSharePrice() public view override returns (uint96 res) {\n        (res, , , ) = minSharePriceBreakdown(stake);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function stakedShares() public view override returns (uint64 res) {\n        res = stake.shares();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function stakedEth() public view override returns (uint96 res) {\n        res = stake.staked();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function protocolEth() public view override returns (uint96 res) {\n        res = stake.proto();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function totalSupply() public view override returns (uint256 res) {\n        res = stakedShares();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            ADD STAKE & SHARES\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice handles the adding of shares - ensures enough eth is being added\n    /// @dev this is the only way to add shares - the logic here ensures that \"ethPerShare\" can never decrease\n    function addStakedShareFromMsgValue(uint96 offset) internal {\n        uint96 value = msg.value.safe96() - offset;\n\n        uint256 cache = stake;\n\n        (uint96 totalPrice, , uint96 protocolFee, ) = minSharePriceBreakdown(cache);\n\n        // logically unnessesary - to help front end\n        require(value >= totalPrice, 'T:1'); // \"not enough eth to create share\"\n\n        uint96 overpay = value - totalPrice;\n\n        // the rest of the value gets added to stakedEth\n        protocolFee += calculateProtocolFeeOf(overpay);\n\n        cache = cache.addShares(1);\n        cache = cache.addStaked(value - protocolFee);\n        cache = cache.addProto(protocolFee);\n\n        stake = cache;\n\n        emit Stake(cache);\n    }\n\n    /// @notice handles isolated staking of eth\n    /// @dev supply of eth goes up while supply of shares stays constant - increasing \"minSharePrice\"\n    /// @param eth the amount of eth being staked - must be some portion of msg.value\n    function addStakedEth(uint96 eth) internal {\n        require(msg.value >= eth, 'T:2'); // \"value of tx too low\"\n\n        uint256 cache = stake;\n\n        uint96 protocolFee = calculateProtocolFeeOf(eth);\n\n        cache = cache.addStaked(eth - protocolFee);\n        cache = cache.addProto(protocolFee);\n\n        stake = cache;\n\n        emit Stake(cache);\n    }\n\n    function calculateProtocolFeeOf(uint256 any) internal pure returns (uint96 res) {\n        // res = (any * PROTOCOL_FEE_BPS) / 10000;\n\n        assembly {\n            res := div(mul(any, PROTOCOL_FEE_BPS), 10000)\n        }\n    }\n\n    // @test manual\n    function minSharePriceBreakdown(uint256 cache)\n        internal\n        pure\n        returns (\n            uint96 total,\n            uint96 eps,\n            uint96 protocolFee,\n            uint96 premium\n        )\n    {\n        eps = calculateEthPerShare(cache);\n\n        protocolFee = calculateProtocolFeeOf(eps);\n\n        premium = cache.shares();\n\n        assembly {\n            premium := div(mul(eps, premium), 10000)\n        }\n\n        // premium = ((eps * cache.shares()) / 10000);\n\n        total = eps + protocolFee + premium;\n    }\n\n    // @test manual\n    function calculateEthPerShare(uint256 cache) internal pure returns (uint96 res) {\n        res = cache.shares();\n        if (res == 0) return 0;\n        cache = cache.staked();\n        assembly {\n            res := div(cache, res)\n        }\n        // res = cache.shares() == 0 ? 0 : cache.staked() / cache.shares();\n    }\n}\n"
    },
    "src/core/NuggftV1Proof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Proof} from '../interfaces/nuggftv1/INuggftV1Proof.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {NuggftV1Dotnugg} from './NuggftV1Dotnugg.sol';\n\nimport {NuggftV1ProofType} from '../types/NuggftV1ProofType.sol';\n\nabstract contract NuggftV1Proof is INuggftV1Proof, NuggftV1Dotnugg {\n    using SafeCastLib for uint160;\n    using SafeCastLib for uint256;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                state\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    mapping(uint160 => uint256) proofs;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                           external functions\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Proof\n    function rotate(\n        uint160 tokenId,\n        uint8 index0,\n        uint8 index1\n    ) external override {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.swapIndexs(working, index0, index1);\n\n        proofs[tokenId] = working;\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function proofOf(uint160 tokenId) public view virtual override returns (uint256) {\n        if (proofs[tokenId] != 0) return proofs[tokenId];\n\n        (uint256 seed, uint256 epoch, uint256 proof) = pendingProof();\n\n        if (epoch == tokenId && seed != 0) return proof;\n        else return 0;\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function proofToDotnuggMetadata(uint160 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory overxs,\n            uint8[] memory overys,\n            string[] memory styles,\n            string memory background\n        )\n    {\n        proof = proofOf(tokenId);\n\n        if (proof == 0) {\n            proof = initFromSeed(tryCalculateSeed(tokenId.safe24()));\n            require(proof != 0, 'P:L');\n        }\n\n        defaultIds = new uint8[](8);\n        overxs = new uint8[](8);\n        overys = new uint8[](8);\n        styles = new string[](8);\n\n        defaultIds[0] = uint8(proof & 0x3);\n\n        for (uint8 i = 0; i < 7; i++) {\n            uint16 item = NuggftV1ProofType.getIndex(proof, i);\n\n            if (item == 0) continue;\n\n            (uint8 feature, uint8 pos) = NuggftV1ProofType.parseItemId(item);\n\n            if (defaultIds[feature] == 0) {\n                uint256 overrides = settings[tokenId].anchorOverrides[item];\n                overys[feature] = uint8(overrides >> 6);\n                overxs[feature] = uint8(overrides & ShiftLib.mask(6));\n                styles[feature] = settings[tokenId].styles[item];\n\n                defaultIds[feature] = pos;\n            }\n        }\n\n        background = settings[tokenId].background;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                             internal functions\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function exists(uint160 tokenId) internal view override returns (bool) {\n        return proofOf(tokenId) != 0;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            SWAP MANAGEMENT\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function addItem(uint160 tokenId, uint16 itemId) internal {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.setIndex(working, NuggftV1ProofType.search(working, 0), itemId);\n\n        proofs[tokenId] = working;\n    }\n\n    function removeItem(uint160 tokenId, uint16 itemId) internal {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.setIndex(working, NuggftV1ProofType.search(working, itemId), 0);\n\n        proofs[tokenId] = working;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            INITIALIZATION\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function setProof(uint160 tokenId) internal {\n        require(proofs[tokenId] == 0, 'P:5');\n\n        uint256 randomEnoughSeed = uint256(keccak256(abi.encodePacked(hex'420690', tokenId, blockhash(block.number - 1))));\n\n        uint256 res = initFromSeed(randomEnoughSeed);\n\n        proofs[tokenId] = res;\n    }\n\n    function setProofFromEpoch(uint160 tokenId) internal {\n        require(proofs[tokenId] == 0, 'P:6');\n\n        (, uint256 epoch, uint256 res) = pendingProof();\n\n        require(epoch == tokenId, 'P:7');\n\n        proofs[tokenId] = res;\n    }\n\n    // TODO TO BE TESTED\n    function initFromSeed(uint256 seed) internal view returns (uint256 res) {\n        require(seed != 0, 'P:8');\n\n        uint256 l = featureLengths;\n\n        res |= ((safeMod(seed & 0xff, _lengthOf(l, 0))) + 1);\n        res |= ((1 << 8) | ((((seed >>= 8) & 0xff % _lengthOf(l, 1))) + 1)) << 3;\n        res |= ((2 << 8) | ((((seed >>= 8) & 0xff % _lengthOf(l, 2))) + 1)) << (3 + 11);\n\n        uint256 selA = (seed >>= 8) & 0xff;\n\n        selA = selA < 128 ? 3 : 4;\n\n        res |= ((selA << 8) | ((safeMod((seed >>= 8) & 0xff, _lengthOf(l, uint8(selA)))) + 1)) << (3 + 22);\n\n        uint256 selB = (seed >>= 8) & 0xff;\n\n        selB = selB < 30 //\n            ? 5\n            : selB < 55\n            ? 6\n            : selB < 75\n            ? 7\n            : 0;\n\n        if (selB != 0) {\n            res |= ((selB << 8) | ((safeMod((seed >>= 8) & 0xff, _lengthOf(l, uint8(selB)))) + 1)) << (3 + 33);\n        }\n\n        uint256 selC = (seed >>= 8) & 0xff;\n\n        selC = selC < 30 //\n            ? 5\n            : selC < 55\n            ? 6\n            : selC < 75\n            ? 7\n            : selC < 115\n            ? 4\n            : selC < 155\n            ? 3\n            : selC < 205\n            ? 2\n            : 1;\n\n        res |= ((selC << 8) | ((safeMod((seed >>= 8) & 0xff, _lengthOf(l, uint8(selC)))) + 1)) << (3 + 77);\n    }\n\n    function safeMod(uint256 value, uint8 modder) internal pure returns (uint256) {\n        require(modder != 0, 'P:9');\n        return value.safe8() % modder;\n    }\n\n    function pendingProof()\n        internal\n        view\n        returns (\n            uint256 seed,\n            uint256 epoch,\n            uint256 proof\n        )\n    {\n        (seed, epoch) = calculateSeed();\n\n        proof = initFromSeed(seed);\n    }\n}\n"
    },
    "src/_test/utils/console.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function logb(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes32)', p0));\n    }\n\n    function logb(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes32)', bytes32(p0)));\n    }\n\n    function logb(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bytes32)', p0, bytes32(p1)));\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature('log()'));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(int)', p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint)', p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string)', p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool)', p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address)', p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes)', p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes1)', p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes2)', p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes3)', p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes4)', p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes5)', p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes6)', p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes7)', p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes8)', p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes9)', p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes10)', p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes11)', p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes12)', p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes13)', p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes14)', p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes15)', p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes16)', p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes17)', p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes18)', p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes19)', p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes20)', p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes21)', p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes22)', p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes23)', p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes24)', p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes25)', p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes26)', p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes27)', p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes28)', p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes29)', p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes30)', p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes31)', p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bytes32)', p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint)', p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string)', p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool)', p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address)', p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint)', p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string)', p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool)', p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address)', p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint)', p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string)', p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool)', p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address)', p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint)', p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string)', p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool)', p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address)', p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint)', p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string)', p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool)', p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address)', p0, p1));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool)', p0, p1, p2));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address)', p0, p1, p2));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        uint256 p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(uint,address,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(string,address,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(bool,address,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        uint256 p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,uint,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,string,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,bool,address,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint256 p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,uint,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,string,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,bool,address)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        uint256 p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,uint)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,string)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,bool)', p0, p1, p2, p3));\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        _sendLogPayload(abi.encodeWithSignature('log(address,address,address,address)', p0, p1, p2, p3));\n    }\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Metadata} from './IDotnuggV1Metadata.sol';\n\ninterface IDotnuggV1Resolver {\n    function resolveBytes(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function resolveRaw(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function resolveMetadata(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (IDotnuggV1Metadata.Memory memory res);\n\n    function resolveString(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n\n    function resolveUri(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n}\n"
    },
    "src/core/NuggftV1Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721} from '../interfaces/IERC721.sol';\n\nimport {INuggftV1Token} from '../interfaces/nuggftv1/INuggftV1Token.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {NuggftV1Epoch} from './NuggftV1Epoch.sol';\n\n///\n/// @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard\n///\nabstract contract NuggftV1Token is INuggftV1Token, NuggftV1Epoch {\n    using SafeCastLib for uint256;\n\n    uint32 constant TRUSTED_MINT_TOKENS = 500;\n    uint32 constant UNTRUSTED_MINT_TOKENS = 10000;\n\n    mapping(uint256 => address) owners;\n    // mapping(address => uint256) balances;\n    mapping(uint256 => address) approvals;\n    mapping(address => mapping(address => bool)) operatorApprovals;\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) public payable override {\n        require(_ownerOf(tokenId.safe160()) == msg.sender, 'Z:1');\n\n        approvals[tokenId] = to;\n\n        emit Approval(msg.sender, to, tokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) public override {\n        // require(msg.sender != operator && operator == address(this), 'G:0');\n\n        operatorApprovals[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        return _ownerOf(tokenId.safe160());\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) external view override returns (address) {\n        return _getApproved(tokenId.safe160());\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view override returns (bool) {\n        return _isOperatorFor(operator, owner);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                DISABLED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function balanceOf(address) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public payable override {\n        revert();\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256\n    ) public payable override {\n        revert();\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public payable override {\n        revert();\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                internal\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function _mintTo(address to, uint160 tokenId) internal {\n        owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                view\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function exists(uint160 tokenId) internal view virtual returns (bool);\n\n    function _isOperatorFor(address operator, address owner) internal view returns (bool) {\n        return owner == operator || operatorApprovals[owner][operator];\n    }\n\n    function _isOperatorForOwner(address operator, uint160 tokenId) internal view returns (bool) {\n        return _isOperatorFor(operator, _ownerOf(tokenId));\n    }\n\n    function ensureOperatorForOwner(address operator, uint160 tokenId) internal view returns (address owner) {\n        owner = _ownerOf(tokenId);\n        require(_isOperatorFor(operator, owner), 'P:B');\n    }\n\n    function _getApproved(uint160 tokenId) internal view returns (address) {\n        require(exists(tokenId), 'T:9:1');\n        return approvals[tokenId];\n    }\n\n    function _ownerOf(uint160 tokenId) internal view returns (address owner) {\n        require(exists(tokenId), 'T:9:2');\n        owner = owners[tokenId];\n        if (owner == address(0)) return address(this);\n    }\n\n    function _isApprovedOrOwner(address spender, uint160 tokenId) internal view returns (bool) {\n        address owner = _ownerOf(tokenId);\n        return (spender == owner || _getApproved(tokenId) == spender || _isOperatorFor(owner, spender));\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRANSFER\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function checkedTransferFromSelf(address to, uint160 tokenId) internal {\n        require(_ownerOf(tokenId) == address(this), 'N:0');\n\n        owners[tokenId] = to;\n\n        emitTransferEvent(address(this), to, tokenId);\n    }\n\n    function approvedTransferToSelf(uint160 tokenId) internal {\n        require(_isOperatorForOwner(msg.sender, tokenId) && _getApproved(tokenId) == address(this), 'N:1');\n\n        delete owners[tokenId];\n\n        // Clear approvals from the previous owner\n        delete approvals[tokenId];\n\n        emitTransferEvent(msg.sender, address(this), tokenId);\n    }\n\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint160 tokenId\n    ) internal {\n        emit Transfer(from, to, tokenId);\n    }\n}\n"
    },
    "src/core/NuggftV1Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Epoch} from '../interfaces/nuggftv1/INuggftV1Epoch.sol';\n\nabstract contract NuggftV1Epoch is INuggftV1Epoch {\n    uint256 public immutable genesis;\n\n    uint16 constant INTERVAL = 69;\n    uint24 constant OFFSET = 3000;\n\n    constructor() {\n        genesis = block.number;\n        emit Genesis(block.number, INTERVAL, OFFSET);\n    }\n\n    /// @inheritdoc INuggftV1Epoch\n    function epoch() public view override returns (uint24 res) {\n        res = toEpoch(block.number, genesis);\n    }\n\n    function calculateSeed() internal view returns (uint256 res, uint24 _epoch) {\n        _epoch = epoch();\n        res = calculateSeed(_epoch);\n    }\n\n    function tryCalculateSeed(uint24 _epoch) internal view returns (uint256 res) {\n        res = calculateSeed(_epoch);\n    }\n\n    /// @notice calculates a random-enough seed that will stay the\n    function calculateSeed(uint24 _epoch) internal view returns (uint256 res) {\n        uint256 startblock = toStartBlock(_epoch, genesis);\n        bytes32 bhash = getBlockHash(startblock - 2);\n        require(bhash != 0, 'E:0');\n        res = uint256(keccak256(abi.encodePacked(bhash, _epoch, address(this))));\n    }\n\n    function getBlockHash(uint256 blocknum) internal view virtual returns (bytes32 res) {\n        return blockhash(blocknum);\n    }\n\n    function toStartBlock(uint24 _epoch, uint256 gen) internal pure returns (uint256 res) {\n        assembly {\n            res := add(mul(sub(_epoch, OFFSET), INTERVAL), gen)\n        }\n    }\n\n    function toEpoch(uint256 blocknum, uint256 gen) internal pure returns (uint24 res) {\n        assembly {\n            res := add(div(sub(blocknum, gen), INTERVAL), OFFSET)\n        }\n    }\n\n    function toEndBlock(uint24 _epoch, uint256 gen) internal pure returns (uint256 res) {\n        unchecked {\n            res = toStartBlock(_epoch + 1, gen) - 1;\n        }\n    }\n}\n"
    },
    "src/interfaces/ITrust.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITrust {\n    event TrustUpdated(address indexed user, bool trust);\n\n    function setIsTrusted(address user, bool trust) external;\n\n    function isTrusted(address user) external view returns (bool);\n}\n"
    },
    "src/_test/utils/logger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport './console.sol';\n\nlibrary logger {\n    function log(uint256 val, string memory name) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2\n    ) internal view {\n\n\n\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1\n    ) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3\n    ) internal view {\n\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3,\n        uint256 val4,\n        string memory name4\n    ) internal view {\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n    function log(uint256[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n\n    function log(uint8[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n}\n\nlibrary Uint256 {\n    bytes16 private constant ALPHABET = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAscii(uint256 value) internal pure returns (bytes memory buffer) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return buffer;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        return string(toAscii(value));\n    }\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// library Event {\n//     function log(uint256 val, string memory name) internal view {}\n\n//     function log(\n//         uint256 val0,\n//         string memory name0,\n//         uint256 val1,\n//         string memory name1,\n//         uint256 val2,\n//         string memory name2\n//     ) internal view {}\n\n//     function log(uint256[] memory arr, string memory name) internal view {}\n// }\n"
    },
    "src/_test/NuggftV1.test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from './utils/DSTestPlus.sol';\n\nimport './utils/User.sol';\n\nimport {IDotnuggV1Metadata} from '../interfaces/dotnuggv1/IDotnuggV1Metadata.sol';\n\nimport {MockDotnuggV1} from './mock/MockDotnuggV1.sol';\n\nimport {MockNuggftV1Migrator} from './mock/MockNuggftV1Migrator.sol';\n\nimport {NuggftV1} from '../NuggftV1.sol';\n\nimport './utils/logger.sol';\n\ncontract RiggedNuggft is NuggftV1 {\n    constructor(address processor) NuggftV1(processor) {\n        featureLengths = 0x0303030303030303;\n    }\n\n    function getBlockHash(uint256 blocknum) internal view override returns (bytes32 res) {\n        if (block.number >= blocknum && block.number - blocknum < 256) {\n            return keccak256(abi.encodePacked(blocknum));\n        }\n    }\n\n    function external__calculateSeed() external view returns (uint256 res, uint24 _epoch) {\n        return calculateSeed();\n    }\n\n    function external__calculateSeed(uint24 epoch) external view returns (uint256 res) {\n        return calculateSeed(epoch);\n    }\n}\n\nlibrary SafeCast {\n    function safeInt(uint96 input) internal pure returns (int192) {\n        return (int192(int256(uint256(input))));\n    }\n}\n\ncontract NuggftV1Test is t {\n    using SafeCast for uint96;\n    using SafeCast for uint256;\n    using SafeCast for uint64;\n\n    using UserTarget for address;\n\n    MockDotnuggV1 public processor;\n\n    MockNuggftV1Migrator public migrator;\n\n    RiggedNuggft public nuggft;\n\n    address public _nuggft;\n\n    User public safe;\n\n    User public frank;\n    User public charlie;\n    User public dennis;\n    User public mac;\n    User public dee;\n\n    User public any;\n\n    struct Users {\n        address frank;\n        address dee;\n        address mac;\n        address dennis;\n        address charlie;\n        address safe;\n    }\n\n    Users public users;\n\n    constructor() {}\n\n    function reset() public {\n        fvm.roll(1000001);\n        processor = new MockDotnuggV1();\n        migrator = new MockNuggftV1Migrator();\n        nuggft = new RiggedNuggft(address(processor));\n        _nuggft = address(nuggft);\n        safe = new User();\n\n        frank = new User();\n        charlie = new User();\n        dennis = new User();\n        mac = new User();\n        dee = new User();\n\n        users.frank = fvm.addr(12);\n        fvm.deal(users.frank, 90000 ether);\n\n        users.dee = fvm.addr(13);\n        fvm.deal(users.dee, 90000 ether);\n\n        users.mac = fvm.addr(14);\n        fvm.deal(users.mac, 90000 ether);\n\n        users.dennis = fvm.addr(15);\n        fvm.deal(users.dennis, 90000 ether);\n\n        users.charlie = fvm.addr(16);\n        fvm.deal(users.charlie, 90000 ether);\n\n        users.safe = fvm.addr(17);\n        fvm.deal(users.safe, 90000 ether);\n\n        // any = new User();\n\n        fvm.deal(address(safe), 30 ether);\n        fvm.deal(address(dennis), 30 ether);\n        fvm.deal(address(mac), 30 ether);\n        fvm.deal(address(dee), 30 ether);\n        fvm.deal(address(frank), 90000 ether);\n        fvm.deal(address(charlie), 30 ether);\n\n        nuggft.setIsTrusted(address(safe), true);\n        nuggft.setIsTrusted(users.safe, true);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                eth modifiers\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    struct ChangeCheck {\n        int192 before_staked;\n        int192 before_protocol;\n        int192 before_shares;\n        int192 before_minSharePrice;\n        int192 before_eps;\n        //\n        int192 after_staked;\n        int192 after_protocol;\n        int192 after_shares;\n        int192 after_minSharePrice;\n        int192 after_eps;\n    }\n\n    modifier changeInStaked(int192 change, int192 shareChange) {\n        ChangeCheck memory str;\n        str.before_staked = nuggft.stakedEth().safeInt();\n        str.before_protocol = nuggft.protocolEth().safeInt();\n        str.before_shares = nuggft.stakedShares().safeInt();\n        str.before_minSharePrice = nuggft.minSharePrice().safeInt();\n\n        str.before_eps = nuggft.ethPerShare().safeInt();\n\n        assertEq(\n            str.before_eps,\n            str.before_shares > 0 ? str.before_staked / str.before_shares : int256(0),\n            'EPS is starting off with an incorrect value'\n        );\n\n        _;\n        str.after_staked = nuggft.stakedEth().safeInt();\n        str.after_protocol = nuggft.protocolEth().safeInt();\n        str.after_shares = nuggft.stakedShares().safeInt();\n        str.after_minSharePrice = nuggft.minSharePrice().safeInt();\n\n        assertTrue(str.after_minSharePrice >= str.before_minSharePrice, 'minSharePrice is did not increase as expected');\n        assertEq(str.after_protocol - str.before_protocol, take(10, change), 'totalProtocol is not what is expected');\n        assertEq(str.after_staked - str.before_staked, change - take(10, change), 'staked change is not 90 percent of expected change');\n        assertEq(str.after_shares - str.before_shares, shareChange, 'shares difference is not what is expected');\n\n        str.after_eps = nuggft.ethPerShare().safeInt();\n        assertEq(\n            str.after_eps,\n            str.after_shares > 0 ? str.after_staked / str.after_shares : int256(0),\n            'EPS is not ending with correct value'\n        );\n    }\n\n    modifier changeInUserBalance(User user, int192 change) {\n        ChangeCheck memory str;\n\n        str.before_staked = int192(int256(uint256(address(user).balance)));\n        _;\n        str.after_staked = int192(int256(uint256(address(user).balance)));\n\n        assertEq(str.after_staked - str.before_staked, change, 'user balance did not change');\n    }\n\n    modifier changeInNuggftBalance(int192 change) {\n        ChangeCheck memory str;\n\n        str.before_staked = int192(int256(uint256(address(nuggft).balance)));\n        _;\n        str.after_staked = int192(int256(uint256(address(nuggft).balance)));\n\n        assertEq(str.after_staked - str.before_staked, change, 'nuggft balance did not change');\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                encodeWithSelector\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function delegate(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.delegate.selector, tokenId);\n    }\n\n    function delegateItem(\n        uint256 buyerTokenId,\n        uint256 sellerTokenId,\n        uint256 itemId\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.delegateItem.selector, buyerTokenId, sellerTokenId, itemId);\n    }\n\n    function claim(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.claim.selector, tokenId);\n    }\n\n    function swap(uint256 tokenId, uint96 floor) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.swap.selector, tokenId, floor);\n    }\n\n    function loan(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.loan.selector, tokenId);\n    }\n\n    function liquidate(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.liquidate.selector, tokenId);\n    }\n\n    function rebalance(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.rebalance.selector, tokenId);\n    }\n\n    function loanInfo(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.loanInfo.selector, tokenId);\n    }\n\n    function swapItem(\n        uint256 tokenId,\n        uint256 itemId,\n        uint96 floor\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.swapItem.selector, tokenId, itemId, floor);\n    }\n\n    function claimItem(\n        uint256 buyerTokenId,\n        uint256 sellerTokenId,\n        uint256 itemId\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.claimItem.selector, buyerTokenId, sellerTokenId, itemId);\n    }\n\n    function rotate(\n        uint256 tokenId,\n        uint8 index0,\n        uint8 index1\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.rotate.selector, tokenId, index0, index1);\n    }\n\n    function burn(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.burn.selector, tokenId);\n    }\n\n    function migrate(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.migrate.selector, tokenId);\n    }\n\n    function setMigrator(address _migrator) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.setMigrator.selector, _migrator);\n    }\n\n    function approve(address addr, uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.approve.selector, addr, tokenId);\n    }\n\n    function setApprovalForAll(address addr, bool appr) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.setApprovalForAll.selector, addr, appr);\n    }\n\n    function mint(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.mint.selector, tokenId);\n    }\n\n    function trustedMint(uint256 tokenId, address to) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.trustedMint.selector, tokenId, to);\n    }\n\n    function take(int256 percent, int256 value) internal pure returns (int256) {\n        return (value * percent) / 100;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                scenarios\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function scenario_dee_has_a_token() public payable returns (uint160 tokenId) {\n        tokenId = 2069;\n        _nuggft.shouldPass(dee, mint(tokenId));\n    }\n\n    function scenario_frank_has_a_token_and_spent_50_eth() public payable returns (uint160 tokenId) {\n        tokenId = 2012;\n        _nuggft.shouldPass(frank, mint(tokenId), 50 ether);\n    }\n\n    function scenario_frank_has_a_loaned_token() public payable returns (uint160 tokenId) {\n        scenario_charlie_has_a_token();\n\n        tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        {\n            _nuggft.shouldPass(frank, approve(address(nuggft), tokenId));\n        }\n\n        _nuggft.shouldPass(frank, loan(tokenId));\n    }\n\n    function scenario_frank_has_a_loaned_token_that_has_expired() public payable returns (uint160 tokenId) {\n        tokenId = scenario_frank_has_a_loaned_token();\n\n        fvm.roll(200000);\n    }\n\n    function scenario_dee_has_a_token_2() public payable returns (uint160 tokenId) {\n        tokenId = 2400;\n        _nuggft.shouldPass(dee, mint(tokenId));\n    }\n\n    function scenario_charlie_has_a_token() public payable returns (uint160 tokenId) {\n        tokenId = 2070;\n        _nuggft.shouldPass(charlie, mint(tokenId));\n    }\n\n    function scenario_migrator_set() public payable {\n        _nuggft.shouldPass(safe, setMigrator(address(migrator)));\n    }\n\n    function scenario_dee_has_a_token_and_can_swap() public payable returns (uint160 tokenId) {\n        tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n    }\n\n    function scenario_dee_has_swapped_a_token() public payable returns (uint160 tokenId, uint96 floor) {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        floor = 1 ether;\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor));\n    }\n\n    function scenario_dee_has_swapped_a_token_and_mac_has_delegated() public payable returns (uint160 tokenId, uint96 eth) {\n        (tokenId, ) = scenario_dee_has_swapped_a_token();\n\n        eth = 2 ether;\n\n        _nuggft.shouldPass(mac, delegate(tokenId), eth);\n    }\n\n    function scenario_dee_has_swapped_a_token_and_mac_can_claim() public payable returns (uint160 tokenId) {\n        (tokenId, ) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        fvm.roll(2000);\n    }\n\n    function scenario_mac_has_claimed_a_token_dee_swapped() public payable returns (uint160 tokenId) {\n        (tokenId) = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        _nuggft.shouldPass(mac, claim(tokenId));\n    }\n\n    function scenario_mac_has_swapped_a_token_dee_swapped() public payable returns (uint160 tokenId, uint96 floor) {\n        (tokenId) = scenario_mac_has_claimed_a_token_dee_swapped();\n        floor = 3 ether;\n\n        _nuggft.shouldPass(mac, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(mac, swap(tokenId, floor));\n    }\n\n    function scenario_dee_has_a_token_and_can_swap_an_item()\n        public\n        payable\n        returns (\n            uint160 tokenId,\n            uint16 itemId,\n            uint8 feature\n        )\n    {\n        (tokenId) = scenario_dee_has_a_token();\n\n        IDotnuggV1Metadata.Memory memory m = nuggft.dotnuggV1ImplementerCallback(\n            tokenId\n            // IDotnuggV1Metadata.Memory({\n            //     implementer: _nuggft,\n            //     artifactId: tokenId,\n            //     ids: new uint8[](8),\n            //     xovers: new uint8[](8),\n            //     yovers: new uint8[](8),\n            //     version: 1,\n            //     labels: new string[](8),\n            //     jsonKeys: new string[](8),\n            //     jsonValues: new string[](8),\n            //     styles: new string[](8),\n            //     background: '',\n            //     data: ''\n            // })\n        );\n\n        feature = 1;\n        itemId = m.ids[feature] | (uint16(feature) << 8);\n\n        // _nuggft.shouldPass(dee, rotate(tokenId, feature));\n    }\n\n    function scenario_dee_has_swapped_an_item()\n        public\n        payable\n        returns (\n            uint160 tokenId,\n            uint8 feature,\n            uint16 itemId,\n            uint96 floor\n        )\n    {\n        (tokenId, itemId, feature) = scenario_dee_has_a_token_and_can_swap_an_item();\n        floor = 3 ether;\n\n        _nuggft.shouldPass(dee, swapItem(tokenId, itemId, floor));\n    }\n\n    function scenario_dee_has_swapped_an_item_and_charlie_can_claim()\n        public\n        payable\n        returns (\n            uint160 charliesTokenId,\n            uint160 tokenId,\n            uint16 itemId\n        )\n    {\n        uint256 feature;\n        uint96 floor;\n        (tokenId, feature, itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n\n        fvm.roll(2000);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                scenarios\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // function environment() public returns (address[] memory users) {\n    //     users = new address[](2000);\n\n    //     User start = new User{value: 69 ether}();\n    //     uint160 count = 501;\n\n    //                 fvm.deal(address(start), 69 ether);\n\n    //     nuggft_call(start, mint(count++), .01 ether);\n    //     nuggft_call(start, mint(count++), nuggft.minSharePrice());\n    //     nuggft_call(start, mint(count++), nuggft.minSharePrice());\n\n    //     users[0] = address(start);\n\n    //     for (uint256 i = 1; i < users.length; i++) {\n    //         User tmp = new User{value: 69 ether}();\n\n    //         fvm.deal(address(tmp), 69 ether);\n\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n\n    //         users[i] = address(tmp);\n    //     }\n\n    // }\n\n    function environmentForge() public returns (address[] memory users) {\n        users = new address[](9500);\n\n        User start = new User{value: 1000000000 ether}();\n        uint160 count = 501;\n\n        //   fvm.deal(address(start), 10000 *10**18);\n\n        _nuggft.shouldPass(start, mint(count++), .08 ether);\n\n        users[0] = address(start);\n\n        int256 last = 0;\n        int256 lastDiff = 0;\n\n        for (uint256 i = 1; i < users.length; i++) {\n            // User tmp = new User{value: 100000000 ether}();\n\n            // fvm.deal(address(tmp), 10000 *10**18);\n\n            _nuggft.shouldPass(start, mint(count++), nuggft.minSharePrice());\n\n            int256 curr = nuggft.minSharePrice().safeInt();\n\n            users[i] = address(start);\n\n            int256 diff = curr - last;\n            emit log_named_int('diff', curr - last);\n            emit log_named_int('ldif', diff - lastDiff);\n\n            emit log_named_uint('nuggft.ethPerShare()', nuggft.ethPerShare());\n            // emit log_named_uint('nuggft.protocolEth()', nuggft.protocolEth());\n            // emit log_named_uint('nuggft.stakedEth()', nuggft.stakedEth());\n            emit log_named_uint('nuggft.stakedShares()', nuggft.stakedShares());\n            emit log_named_uint('nuggft.minSharePrice()', nuggft.minSharePrice());\n\n            emit log_string('--------');\n\n            last = curr;\n            lastDiff = diff;\n        }\n    }\n\n    function environmentForge2() public returns (address[] memory users) {\n        users = environmentForge();\n\n        uint256 bn = 5000;\n\n        // for (uint256 i = 0; i < 10000; i++) {\n        //     uint256 epoch = nuggft.epoch();\n\n        //     uint256 funner = uint256(keccak256(abi.encodePacked(epoch))) % 100;\n\n        //     nuggft_call(User(payable(users[funner])), delegate(users[funner], epoch), nuggft.minSharePrice());\n\n        //     fvm.roll(bn);\n\n        //     bn += 70;\n\n        //     nuggft_call(User(payable(users[funner])), claim(users[funner], epoch));\n        // }\n\n        assert(false);\n    }\n}\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 36422938319266817\n//   nuggft.protocolEth(): 13721927850988207037\n//   nuggft.stakedEth(): 254960568234867720007\n//   nuggft.stakedShares(): 7000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .220269870602728762\n//   nuggft.protocolEth(): 105.652900187038601090\n//   nuggft.stakedEth(): 3524.317929643660202576\n//   nuggft.stakedShares(): 16000\n\n// Success: test__system1()\n// *10\n//   users length: 2000\n//   nuggft.ethPerShare():  .081046931383505748\n//   nuggft.protocolEth(): 36.036371675422002761\n//   nuggft.stakedEth():  891.516245218563229016\n//   nuggft.stakedShares(): 11000\n\n//   users length: 2000\n//   nuggft.ethPerShare():   .009923420616251655\n//   nuggft.protocolEth():  10.797105517187750828\n//   nuggft.stakedEth():   109.157626778768205405\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .023820112972809680\n//   nuggft.protocolEth(): 23.605706549631210195\n//   nuggft.stakedEth(): 262.021242700906482643\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 22283800801842573\n//   nuggft.protocolEth(): 12045486919914902312\n//   nuggft.stakedEth(): 133702804811055442627\n//   nuggft.stakedShares(): 6000\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 1.124042581556443270\n//   nuggft.protocolEth(): 658.232592803322633239\n//   nuggft.stakedEth(): 7306.276780116881258328\n//   nuggft.stakedShares(): 6500\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .179846813049030914\n//   nuggft.protocolEth(): 105317214848531614175\n//   nuggft.stakedEth(): 1169004284818700946598\n//   nuggft.stakedShares(): 6500\n\n// .092595956292375926\n\n// .101719406217199627\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .178270406414740660\n//   nuggft.protocolEth(): 96363895359319273644\n//   nuggft.stakedEth(): 1069622438488443964472\n//   nuggft.stakedShares(): 6000\n\n// Success: test__system1()\n\n//   users length: 1000\n//   nuggft.ethPerShare():   1.425741271002990526\n//   nuggft.protocolEth():  305.518843786355111578\n//   nuggft.stakedEth():   4277.223813008971579744\n//   nuggft.stakedShares(): 3000\n"
    },
    "src/_test/utils/DSTestPlus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTest} from '../../../lib/ds-test/src/test.sol';\n\nimport {Hevm, ForgeVm} from './Vm.sol';\n\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    bytes32 checkpointLabel;\n    uint256 private checkpointGasLeft;\n\n    function startMeasuringGas(bytes32 label) internal virtual {\n        checkpointLabel = label;\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        bytes32 label = checkpointLabel;\n\n        emit log_named_uint(string(abi.encodePacked(label, ' Gas')), checkpointGasLeft - checkpointGasLeft2 - 22134);\n    }\n\n    function fail(bytes32 err) internal virtual {\n        emit log_named_string('Error', string(abi.encodePacked(err)));\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log('Error: a == b not satisfied [bytes]');\n            emit log_named_bytes('  Expected', b);\n            emit log_named_bytes('    Actual', a);\n            fail();\n        }\n    }\n\n    function mockBlockhash(uint256 blocknum) internal view returns (bytes32 res) {\n        if (block.number - blocknum < 256) {\n            return keccak256(abi.encodePacked(blocknum));\n        }\n    }\n}\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, 'NO_TARGET_CONTRACTS');\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"
    },
    "src/_test/utils/User.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ForgeVm} from './Vm.sol';\n\nlibrary UserTarget {\n    function shouldPass(\n        address target,\n        User user,\n        bytes memory args\n    ) internal {\n        shouldPass(target, user, args, 0);\n    }\n\n    function shouldPass(\n        address target,\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) internal {\n        user.call(target, args, eth);\n    }\n\n    function shouldFail(\n        address target,\n        string memory message,\n        User user,\n        bytes memory args\n    ) internal {\n        shouldFail(target, message, user, args, 0);\n    }\n\n    function shouldFail(\n        address target,\n        string memory message,\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) internal {\n        user.revertCall(target, message, args, eth);\n    }\n}\n\ncontract User {\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    event log_named_string(string key, string val);\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor() payable {}\n\n    function tryCall(address target, bytes memory data) public payable virtual returns (bool success, bytes memory returnData) {\n        (success, returnData) = target.call{value: msg.value}(data);\n    }\n\n    function call(\n        address target,\n        bytes memory data,\n        uint256 eth\n    ) public payable virtual returns (bytes memory returnData) {\n        require(address(this).balance >= eth, 'INSUFFICIENT_BALANCE_FROM_TARGET');\n        bool success;\n\n        (success, returnData) = target.call{value: eth}(data);\n\n        if (!success) {\n            if (returnData.length > 0) {\n                assembly {\n                    let returnDataSize := mload(returnData)\n                    revert(add(32, returnData), returnDataSize)\n                }\n            } else {\n                revert('REVERTED_WITHOUT_MESSAGE');\n            }\n        }\n    }\n\n    function revertCall(\n        address target,\n        string memory message,\n        bytes memory data,\n        uint256 eth\n    ) public payable virtual {\n        require(address(this).balance >= eth, 'INSUFFICIENT_BALANCE_FROM_TARGET');\n\n        (bool callSuccess, bytes memory returnData) = target.call{value: eth}(data);\n\n        require(!callSuccess, 'REVERT-CALL SUCCEEDED');\n\n        string memory revertReason = string(extractRevertReason(returnData));\n\n        if (!compareStrings(revertReason, message)) {\n            revert(string(abi.encodePacked('UNEXPECTED REVERT: ', revertReason, ' EXPECTED: ', message)));\n        }\n    }\n\n    function extractRevertReason(bytes memory revertData) internal pure returns (string memory reason) {\n        uint256 l = revertData.length;\n        if (l < 68) return '';\n        uint256 t;\n        assembly {\n            revertData := add(revertData, 4)\n            t := mload(revertData) // Save the content of the length slot\n            mstore(revertData, sub(l, 4)) // Set proper length\n        }\n        reason = abi.decode(revertData, (string));\n        assembly {\n            mstore(revertData, t) // Restore the content of the length slot\n        }\n    }\n\n    function compareStrings(string memory a, string memory b) public pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "src/_test/mock/MockDotnuggV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../../interfaces/dotnuggv1/IDotnuggV1.sol';\nimport '../../interfaces/dotnuggv1/IDotnuggV1Metadata.sol';\nimport '../../interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\nimport '../../interfaces/dotnuggv1/IDotnuggV1File.sol';\n\nimport {SafeCastLib} from '../../libraries/SafeCastLib.sol';\n\nimport '../utils/logger.sol';\n\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    function read2DArray(address pointer, uint256 index) internal view returns (uint256[] memory) {\n        return abi.decode(read(pointer), (uint256[][]))[index];\n    }\n\n    // function write2DArray(uint256[][] memory data) internal  returns (address pointer) {\n    //     return write(abi.encode(data));\n    // }\n\n    /*///////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(uint256[][] calldata data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        // bytes memory runtimeCode = abi.encodePacked(hex'00', data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex'60_0B_59_81_38_03_80_92_59_39_F3_00', // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            abi.encode(data)\n            // runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), 'DEPLOYMENT_FAILED');\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    // function read(address pointer, uint256 start) internal view returns (bytes memory) {\n    //     start += DATA_OFFSET;\n\n    //     return readBytecode(pointer, start, pointer.code.length - start);\n    // }\n\n    // function read(\n    //     address pointer,\n    //     uint256 start,\n    //     uint256 end\n    // ) internal view returns (bytes memory) {\n    //     start += DATA_OFFSET;\n    //     end += DATA_OFFSET;\n\n    //     require(pointer.code.length >= end, 'OUT_OF_BOUNDS');\n\n    //     return readBytecode(pointer, start, end - start);\n    // }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n\ncontract DotnuggV1StorageProxy is IDotnuggV1StorageProxy {\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    address public immutable dotnuggv1;\n\n    address public implementer;\n\n    modifier requiresTrust() {\n        require(IDotnuggV1Implementer(implementer).dotnuggV1TrustCallback(msg.sender), 'C:0');\n        _;\n    }\n\n    constructor() {\n        dotnuggv1 = msg.sender;\n    }\n\n    function init(address _implementer) external {\n        require(implementer == address(0) && msg.sender == dotnuggv1, 'C:01');\n        implementer = _implementer;\n    }\n\n    // Mapping from token ID to owner address\n    mapping(uint8 => uint168[]) sstore2Pointers;\n    mapping(uint8 => uint8) featureLengths;\n\n    function stored(uint8 feature) public view override returns (uint8 res) {\n        return featureLengths[feature];\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function unsafeBulkStore(uint256[][][] calldata data) public override {\n        require(msg.sender == implementer);\n        for (uint8 i = 0; i < 8; i++) {\n            uint8 len = data[i].length.safe8();\n\n            require(len > 0, 'F:0');\n\n            address ptr = SSTORE2.write(data[i]);\n\n            sstore2Pointers[i].push(uint168(uint160(ptr)) | (uint168(len) << 160));\n\n            featureLengths[i] += len;\n        }\n    }\n\n    function store(uint8 feature, uint256[][] calldata data) public override requiresTrust returns (uint8 res) {\n        uint8 len = data.length.safe8();\n\n        require(len > 0, 'F:0');\n\n        address ptr = SSTORE2.write(data);\n\n        sstore2Pointers[feature].push(uint168(uint160(ptr)) | (uint168(len) << 160));\n\n        featureLengths[feature] += len;\n\n        return len;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 GET FILES\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function getBatch(uint8[] memory ids) public view returns (uint256[][] memory data) {\n        data = new uint256[][](ids.length);\n\n        for (uint8 i = 0; i < ids.length; i++) {\n            if (ids[i] == 0) data[i] = new uint256[](0);\n            else data[i] = get(i, ids[i]);\n        }\n    }\n\n    function get(uint8 feature, uint8 pos) public view returns (uint256[] memory data) {\n        require(pos != 0, 'F:1');\n\n        pos--;\n\n        uint8 totalLength = featureLengths[feature];\n\n        require(pos < totalLength, 'F:2');\n\n        uint168[] memory ptrs = sstore2Pointers[feature];\n\n        address stor;\n        uint8 storePos;\n\n        uint8 workingPos;\n\n        for (uint256 i = 0; i < ptrs.length; i++) {\n            uint8 here = uint8(ptrs[i] >> 160);\n            if (workingPos + here > pos) {\n                stor = address(uint160(ptrs[i]));\n                storePos = pos - workingPos;\n                break;\n            } else {\n                workingPos += here;\n            }\n        }\n\n        require(stor != address(0), 'F:3');\n\n        data = SSTORE2.read2DArray(stor, storePos);\n    }\n}\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary MinimalProxy {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), 'ERC1167: create failed');\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function deploy(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), 'ERC1167: create2 failed');\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function compute(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function compute(address implementation, bytes32 salt) internal view returns (address predicted) {\n        return compute(implementation, salt, address(this));\n    }\n}\n\n\n\ncontract MockDotnuggV1 is IDotnuggV1 {\n\n\n       address public template;\n\n    constructor() {        template = address(new DotnuggV1StorageProxy());\n    }\n\n    function register() external override returns (IDotnuggV1StorageProxy proxy) {\n        proxy = IDotnuggV1StorageProxy(MinimalProxy.deploy(template, keccak256(abi.encodePacked(msg.sender))));\n        proxy.init(msg.sender);\n    }\n\n    function proxyOf(address implementer) public view override returns (IDotnuggV1StorageProxy proxy) {\n        proxy = IDotnuggV1StorageProxy(MinimalProxy.compute(template, keccak256(abi.encodePacked(implementer))));\n        require(address(proxy).code.length != 0, 'P:0');\n    }\n\n\n    function raw(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        bytes memory data\n    ) public view override returns (IDotnuggV1File.Raw memory res) {\n\n        res.metadata = IDotnuggV1Implementer(implementer).dotnuggV1ImplementerCallback(artifactId);\n\n        res.file = proxyOf(implementer).getBatch(res.metadata.ids);\n    }\n\n    function proc(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        bytes memory data\n    ) public view override returns (IDotnuggV1File.Processed memory ) {\n        IDotnuggV1File.Raw memory _raw = raw(implementer, artifactId, resolver, data);\n\n        for (uint256 i = 0; i < _raw.file.length; i++) {\n            logger.log(_raw.file[i], 'files[i]');\n        }\n\n\n    }\n\n    function comp(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        bytes memory data\n    ) public view override returns (IDotnuggV1File.Compressed memory res) {}\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                complex proccessors\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function dat(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        string memory name,\n        string memory desc,\n        bool base64,\n        bytes calldata data\n    ) external view override returns (string memory res) {}\n\n    function img(\n        address implementer,\n        uint256 artifactId,\n        address resolver,\n        bool rekt,\n        bool background,\n        bool stats,\n        bool base64,\n        bytes memory data\n    ) external view override returns (string memory res) {}\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                basic proccessors\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // function byt(\n    //     address implementer,\n    //     uint256 artifactId,\n    //     address resolver,\n    //     bytes memory data\n    // ) external view override returns (bytes memory res) {}\n\n    // function str(\n    //     address implementer,\n    //     uint256 artifactId,\n    //     address resolver,\n    //     bytes memory data\n    // ) external view override returns (string memory res) {}\n}\n"
    },
    "src/_test/mock/MockNuggftV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Migrator} from '../../interfaces/nuggftv1/INuggftV1Migrator.sol';\n\ncontract MockNuggftV1Migrator is INuggftV1Migrator {\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable override {\n        emit MigrateV1Accepted(msg.sender, tokenId, proof, owner, uint96(msg.value));\n    }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "src/_test/utils/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface Hevm {\n    function warp(uint256) external;\n\n    function roll(uint256) external;\n\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    function load(address, bytes32) external returns (bytes32);\n\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    function addr(uint256) external returns (address);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n}\n\ninterface ForgeVm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (r, v, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Performs the next smart contract call with specified `msg.sender`, (newSender)\n    function prank(address) external;\n    // Performs all the following smart contract calls with specified `msg.sender`, (newSender)\n    function startPrank(address) external;\n    // Stop smart contract calls using the specified address with prankStart()\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    // Expects the next emitted event. Params check topic 1, topic 2, topic 3 and data are the same.\n    function expectEmit(bool, bool, bool, bool) external;\n\n}\n"
    },
    "src/_test/reverts/revert__NuggftV1Swap.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../NuggftV1.test.sol';\n\ncontract revert__NuggftV1Swap is NuggftV1Test {\n    using SafeCast for uint96;\n\n    using UserTarget for address;\n\n    uint32 epoch;\n\n    uint160 tokenId;\n    uint96 floor;\n    uint16 itemId;\n\n    uint96 eth;\n\n    uint160 charliesTokenId;\n\n    uint96 MIN = 10**13 * 50;\n\n    int96 MININT = int96(int256(uint256(MIN)));\n\n    function setUp() public {\n        reset();\n        fvm.roll(57);\n\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:0] - delegate - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_0__successAsSelf() public {\n\n\n        _nuggft.shouldPass(frank, delegate(epoch), 30 * 10**16);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_0__successAsOperator() public {\n        _nuggft.shouldPass(frank, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldPass(dennis, delegate(epoch), 30 * 10**16);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    // function test__revert__NuggftV1Swap__S_0__failAsNotOperator() public {\n    //     _nuggft.shouldFail('S:0', dennis, delegate(epoch), 30 * 10**16);\n    // }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:1] - delegate - \"msg.value >= minimum offer\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_1__successWithExactMinOffer()\n        public\n        changeInUserBalance(frank, -1 * MININT)\n        changeInNuggftBalance(MININT)\n        changeInStaked(MININT, 1)\n    {\n        _nuggft.shouldPass(frank, delegate(epoch), MIN);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_1__successWithHigherMinOffer()\n        public\n        changeInUserBalance(frank, -1 * (MININT + 1))\n        changeInNuggftBalance(MININT + 1)\n        changeInStaked(MININT + 1, 1)\n    {\n        _nuggft.shouldPass(frank, delegate(epoch), MIN + 1);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_1__failWithOneWeiLessThanMin() public {\n        fvm.startPrank(address(frank));\n\n        fvm.expectRevert('S:1');\n\n        nuggft.delegate{value: MIN - 1}(epoch);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_1__failWithZero() public {\n        _nuggft.shouldFail('S:1', frank, delegate(epoch), 0);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:3a] - delegate - \"if commiting, offerer should not be owner of swap\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_R__successWithNotOwner() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        wrap__revert__NuggftV1Swap__S_R__successWithNotOwner();\n    }\n\n    function wrap__revert__NuggftV1Swap__S_R__successWithNotOwner()\n        internal\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInNuggftBalance(floor.safeInt() + 1 ether)\n        changeInStaked(1 ether, 0)\n    {\n        _nuggft.shouldPass(frank, delegate(tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_R__successWithOwnerAfterSomeoneElseDelegates() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        wrap__revert__NuggftV1Swap__S_R__successWithOwnerAfterSomeoneElseDelegates();\n    }\n\n    function wrap__revert__NuggftV1Swap__S_R__successWithOwnerAfterSomeoneElseDelegates()\n        public\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInUserBalance(dee, -1 * (floor.safeInt() + 1 ether * 2))\n        changeInNuggftBalance(3 ether + floor.safeInt() * 2)\n        changeInStaked(3 ether, 0)\n    {\n        _nuggft.shouldPass(frank, delegate(tokenId), floor + 1 ether);\n\n        _nuggft.shouldPass(dee, delegate(tokenId), floor + 2 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_R__failWithOwnerOnCommit() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        _nuggft.shouldFail('S:R', dee, delegate(tokenId), floor + 1 ether * 2);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:3b] - delegate - \"if not minting, offerer must claim previous offers for the specific token\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__NuggftV1Swap__S_R__successWithUserWithNoPrevClaim() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        wrap__revert__NuggftV1Swap__S_R__successWithUserWithNoPrevClaim();\n    }\n\n    function wrap__revert__NuggftV1Swap__S_R__successWithUserWithNoPrevClaim()\n        internal\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInNuggftBalance(floor.safeInt() + 1 ether)\n        changeInStaked(1 ether, 0)\n    {\n        _nuggft.shouldPass(frank, delegate(tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    // LOL - MASSIVE bug found with this test\n    function test__revert__NuggftV1Swap__S_R__successWithPrevClaimUserAfterClaiming() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(dee, claim(tokenId));\n\n        _nuggft.shouldPass(dee, delegate(tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_R__failWtihUserWithPrevClaim() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldFail('S:R', dee, delegate(tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:4] - delegate - \"if not minting, swap data must exist\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__NuggftV1Swap__S_4__failWithNoSwap() public {\n        tokenId = scenario_mac_has_claimed_a_token_dee_swapped();\n\n        _nuggft.shouldFail('S:4', frank, delegate(tokenId), 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_4__failWithNonexistantToken() public {\n        _nuggft.shouldFail('S:4', frank, delegate(50000), 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_4__successWithSwap() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(dee, claim(tokenId));\n\n        _nuggft.shouldPass(dee, delegate(tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:5] - delegate - \"if commiting, msg.value must be >= total eth per share\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_5__failWithVeryHighEPS() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(frank, mint(1500), 50 ether);\n\n        _nuggft.shouldFail('S:5', frank, delegate(tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_5__successWithLowEPS() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(frank, mint(1500), floor + .5 ether);\n\n        _nuggft.shouldPass(frank, delegate(tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:6] - delegateItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__NuggftV1Swap__S_6__successAsOwnerOfBuyerTokenId() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_6__successAsOperator() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldFail('S:6', mac, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_6__failAsNotOperator() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldFail('S:6', mac, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:7] - delegateItem - \"offerer should not be owner of swap\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_7__successWithNotOwner() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_7__successWithSameUserDifferentToken() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        uint160 tokenId2 = scenario_dee_has_a_token_2();\n\n        _nuggft.shouldPass(dee, delegateItem(tokenId2, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_7__failWithUserAndOwningToken() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        _nuggft.shouldFail('S:7', dee, delegateItem(tokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:8] - claim - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__NuggftV1Swap__S_8__successAsSelf() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        _nuggft.shouldPass(mac, claim(tokenId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:9] - claimItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_9__successAsOwnerOfBuyerTokenId() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        _nuggft.shouldPass(charlie, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_9__failAsOperator() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        _nuggft.shouldPass(charlie, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldFail('S:9', mac, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_9__failAsNotOperator() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        _nuggft.shouldFail('S:9', mac, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:A] - swap - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_A__successAsSelf() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        _nuggft.shouldPass(dee, swap(tokenId, 2 ether));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_A__failsAsOperator() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldFail('S:A', dennis, swap(tokenId, 2 ether));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_A__failAsNotOperator() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        _nuggft.shouldFail('S:A', dennis, swap(tokenId, 2 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:B] - swap - \"floor >= ethPerShare\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_B__successWithEqualEPS() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_B__successWithOneWeiTooHigh() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor + 1));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__NuggftV1Swap__S_B__revertWithOneWeiTooLow() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldFail('S:B', dee, swap(tokenId, floor - 1));\n    }\n\n    function test__revert__NuggftV1Swap__S_B__revertWithZero() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldFail('S:B', dee, swap(tokenId, 0));\n    }\n\n    function test__revert__NuggftV1Swap__S_B__revertWithHalfFloor() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldFail('S:B', dee, swap(tokenId, floor / 2));\n    }\n\n    function test__revert__NuggftV1Swap__S_B__successWithWayTooHigh() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor + 30 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:C] - swapItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_C__successAsOwnerOfBuyerTokenId() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        _nuggft.shouldPass(dee, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    function test__revert__NuggftV1Swap__S_C__failAsOperator() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldFail('S:C', dennis, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    function test__revert__NuggftV1Swap__S_C__failAsNotOperator() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        _nuggft.shouldFail('S:C', dennis, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:D] - swapItem - \"cannot sell two of same item at same time\" @todo\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:E] - checkClaimerIsWinnerOrLoser - \"invalid offer\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_E__successPrevSwapperCanClaimAfterNewSwapHasStarted() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        // dee got the token here\n        _nuggft.shouldPass(dee, claim(tokenId));\n    }\n\n    function test__revert__NuggftV1Swap__S_E__failNoOffer() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        _nuggft.shouldFail('S:E', charlie, claim(tokenId));\n    }\n\n    function test__revert__NuggftV1Swap__S_E__successAsLeader() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        _nuggft.shouldPass(mac, claim(tokenId));\n    }\n\n    function test__revert__NuggftV1Swap__S_E__successAsOwner() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        _nuggft.shouldPass(dee, claim(tokenId));\n    }\n\n    function test__revert__NuggftV1Swap__S_E__failAsOperator() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        _nuggft.shouldPass(mac, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldFail('S:E', dennis, claim(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:F] - offer - \"swap must be total\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Swap__S_F__successOfferInActiveSwap() public {\n        (tokenId, eth) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        // dee got the token here\n        _nuggft.shouldPass(charlie, delegate(tokenId), eth + 1 ether);\n    }\n\n    function test__revert__NuggftV1Swap__S_F__failOfferInOldSwap() public {\n        (tokenId, eth) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        fvm.roll(2000);\n\n        // dee got the token here\n        _nuggft.shouldFail('S:F', charlie, delegate(tokenId), eth + 1 ether);\n    }\n\n    function test__revert__NuggftV1Swap__S_F__failOfferInFutureSwap() public {\n        // dee got the token here\n        _nuggft.shouldFail('S:4', charlie, delegate(50000), 1 ether);\n    }\n}\n\n// @todo - make sure eth ends up where we want it\n"
    },
    "src/_test/reverts/revert__NuggftV1Stake.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../NuggftV1.test.sol';\n\ncontract revert__NuggftV1Stake is NuggftV1Test {\n    uint32 epoch;\n\n    using UserTarget for address;\n\n    function setUp() public {\n        reset();\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n            [T:1] - addStakedShareFromMsgValue - \"value of tx too low\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // mint\n    // ────\n\n    function test__revert__NuggftV1Stake__T_1__success() public {\n        _nuggft.shouldPass(frank, mint(2099), 30 ether);\n    }\n\n    function test__revert__NuggftV1Stake__T_1__failWithValue() public {\n        test__revert__NuggftV1Stake__T_1__success();\n\n        fvm.startPrank(users.dennis);\n\n        fvm.expectRevert('T:1');\n\n        nuggft.mint{value: 29 ether}(2909);\n\n        fvm.stopPrank();\n    }\n\n    function test__revert__NuggftV1Stake__T_1__failWithZero() public {\n        test__revert__NuggftV1Stake__T_1__success();\n\n        fvm.startPrank(users.dennis);\n\n        fvm.expectRevert('T:1');\n\n        nuggft.mint{value: 0}(2909);\n\n        fvm.stopPrank();\n    }\n\n    // trustedMint\n    // ────\n\n    function test__revert__NuggftV1Stake__T_1__successOnTrusted() public {\n        fvm.startPrank(users.safe);\n\n        nuggft.trustedMint{value: 30 ether}(200, users.frank);\n\n        fvm.stopPrank();\n    }\n\n    function test__revert__NuggftV1Stake__T_1__failOnTrusted() public {\n\n\n        _nuggft.shouldPass(safe, trustedMint(99, address(frank)), 15 * 10**18);\n\n\n\n        _nuggft.shouldFail('T:1', safe, trustedMint(9, address(dennis)), 14 * 10**18);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                         [T:2] - value of tx too low  @todo\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n             [T:3] - subStakedShare - \"user not granded permission\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // burn\n    // ─────────────\n\n    function test__revert__NuggftV1Stake__T_3__burn__fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldFail('T:3', mac, burn(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_3__burn__failOnNoApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldFail('T:3', dee, burn(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_3__burn__succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(dee, burn(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_3__burn__failOnIncorrectApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(mac), tokenId));\n\n        _nuggft.shouldFail('T:3', dee, burn(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_3__burn__failOnIncorrectOperatorApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldFail('T:3', dennis, burn(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_3__burn__failsOnCorrectOperatorApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldFail('T:3', mac, burn(tokenId));\n    }\n\n    // migrate\n    // ─────────────\n\n    function test__revert__NuggftV1Stake__T_3__migrate__fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        scenario_migrator_set();\n\n        _nuggft.shouldFail('T:3', dee, migrate(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_3__migrate__succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        scenario_migrator_set();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(dee, migrate(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                [T:4] - migrate - \"migrator must be set\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // migrate\n    // ────────────\n\n    function test__revert__NuggftV1Stake__T_4__fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldFail('T:4', dee, migrate(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_4__succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(safe, setMigrator(address(migrator)));\n\n        _nuggft.shouldPass(dee, migrate(tokenId));\n    }\n\n    function test__revert__NuggftV1Stake__T_4__succeedsWithApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(safe, setMigrator(address(migrator)));\n\n        _nuggft.shouldPass(dee, migrate(tokenId));\n    }\n\n    /// values add on top of each other\n}\n"
    },
    "src/_test/reverts/revert__NuggftV1Loan.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../NuggftV1.test.sol';\n\ncontract revert__NuggftV1Loan is NuggftV1Test {\n    uint32 epoch;\n\n    using UserTarget for address;\n\n    function setUp() public {\n        reset();\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:0] - loan - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Loan__L_0__successAsSelf() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldPass(frank, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(frank, loan(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_0__failAsOperator() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldPass(frank, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(frank, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldFail('L:0', dennis, loan(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_0__failAsNotOperator() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldPass(frank, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldFail('L:0', dennis, loan(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__N_1__failAsSelfHasNotApprovedContract() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldFail('N:1', frank, loan(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_0__failAsOperatorHasNotApprovedContract() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldPass(frank, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldFail('L:0', dennis, loan(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_0__failAsNotOperatorHasNotApprovedContract() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldFail('L:0', dennis, loan(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:1] - liquidate - \"msg.sender must be operator for unexpired loan\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Loan__L_1__successAsSelf() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_1__successAsSelfExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token_that_has_expired();\n\n        _nuggft.shouldPass(frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_1__successAsOperator() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(mac, liquidate(tokenId), nuggft.valueForLiquidate(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_1__successAsOperatorExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token_that_has_expired();\n\n        _nuggft.shouldPass(frank, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(mac, liquidate(tokenId), nuggft.valueForLiquidate(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_1__successNotOperatorExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token_that_has_expired();\n\n        _nuggft.shouldPass(mac, liquidate(tokenId), nuggft.valueForLiquidate(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_1__failAsNotOperatorNotExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldFail('L:1', mac, liquidate(tokenId), nuggft.valueForLiquidate(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:2] - liquidate - \"msg.value not high enough\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Loan__L_2__successLiquidateExact() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_2__successLiquidateWeiHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId) + 1);\n    }\n\n    function test__revert__NuggftV1Loan__L_2__failLiquidateWeiLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldFail('L:2', frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId) - 1);\n    }\n\n    function test__revert__NuggftV1Loan__L_2__successLiquidateWayHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId) + 50 ether);\n    }\n\n    function test__revert__NuggftV1Loan__L_2__failLiquidateWayLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldFail('L:2', frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId) / 2);\n    }\n\n    function test__revert__NuggftV1Loan__L_2__failLiquidateZero() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldFail('L:2', frank, liquidate(tokenId), 0);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:3] - rebalance - \"msg.value not high enough\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Loan__L_3__successRebalanceExact() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_3__successRebalanceWeiHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) + 1);\n    }\n\n    function test__revert__NuggftV1Loan__L_3__failRebalanceWeiLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldFail('L:3', frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) - 1);\n    }\n\n    function test__revert__NuggftV1Loan__L_3__successRebalanceWayHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) + 50 ether);\n    }\n\n    function test__revert__NuggftV1Loan__L_3__failRebalanceWayLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldFail('L:3', frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) / 2);\n    }\n\n    function test__revert__NuggftV1Loan__L_3__failRebalanceZero() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldFail('L:3', frank, rebalance(tokenId), 0);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:4] - loanInfo - \"loan exists\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Loan__L_4__failDoesNotExist() public {\n        _nuggft.shouldFail('L:4', frank, loanInfo(100));\n    }\n\n    function test__revert__NuggftV1Loan__L_4__successDoesExist() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, loanInfo(tokenId));\n    }\n\n    function test__revert__NuggftV1Loan__L_4__failDoesNotExistAfterLiquidate() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        _nuggft.shouldPass(frank, loanInfo(tokenId));\n\n        _nuggft.shouldPass(frank, liquidate(tokenId), nuggft.valueForLiquidate(tokenId) + 1);\n\n        _nuggft.shouldFail('L:4', frank, loanInfo(tokenId));\n    }\n}\n"
    },
    "src/_test/reverts/revert__NuggftV1Epoch.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../NuggftV1.test.sol';\n\nimport {NuggftV1Epoch} from '../../core/NuggftV1Epoch.sol';\n\ncontract revert__NuggftV1Epoch is NuggftV1Test, NuggftV1Epoch {\n    using UserTarget for address;\n\n    function setUp() public {\n        reset();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [E:0] - calculateSeed - \"block hash does not exist\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__NuggftV1Epoch__calculateSeed__E_0__failNextEpoch() public {\n        uint24 epoch = nuggft.epoch();\n\n        fvm.expectRevert('E:0');\n        nuggft.external__calculateSeed(epoch + 1);\n    }\n\n    function test__revert__NuggftV1Epoch__calculateSeed__E_0__succeedCurrentBlock() public view {\n        nuggft.external__calculateSeed();\n    }\n}\n"
    },
    "src/_test/general/general__NuggftV1Epoch.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../NuggftV1.test.sol';\n\nimport {NuggftV1Epoch} from '../../core/NuggftV1Epoch.sol';\n\ncontract general__NuggftV1Epoch is NuggftV1Test, NuggftV1Epoch {\n    using UserTarget for address;\n\n    function setUp() public {\n        reset();\n        // fvm.roll(13952818);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [pure] toEpoch\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function safe__toEpoch(uint32 blocknum, uint256 gen) internal pure returns (uint32 res) {\n        res = (uint32(blocknum - gen) / INTERVAL) + OFFSET;\n    }\n\n    function test__general__NuggftV1Epoch__toEpoch__symbolic(uint32 blocknum, uint256 gen) public {\n        if (blocknum < gen) return;\n\n        assertEq(\n            toEpoch(blocknum, gen), //\n            safe__toEpoch(blocknum, gen),\n            'toEpoch: real != safe'\n        );\n    }\n\n    function test__general__NuggftV1Epoch__toEpoch__gas() public view {\n        toEpoch(uint32(block.number), genesis);\n    }\n\n    function test__general__NuggftV1Epoch__toEpoch__gas__safe() public view {\n        safe__toEpoch(uint32(block.number), genesis);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [pure] toStartBlock\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function safe__toStartBlock(uint24 _epoch, uint256 gen) internal pure returns (uint256 res) {\n        res = uint256(uint256(_epoch - OFFSET) * INTERVAL) + gen;\n    }\n\n    function test__general__NuggftV1Epoch__toStartBlock__symbolic(uint32 _epoch, uint32 gen) public {\n        uint24 epoch = uint24(_epoch);\n\n        if (_epoch < OFFSET || _epoch > 5000000) return;\n        if (gen < 1000000) return;\n\n        if (gen == 0) return;\n        if (epoch == 0) return;\n\n        uint256 got = toStartBlock(epoch, gen);\n        uint256 exp = safe__toStartBlock(epoch, gen);\n\n        assertEq(got, exp, 'toStartBlock: real != safe');\n    }\n\n    function test__general__NuggftV1Epoch__toStartBlock__gas() public view {\n        toStartBlock(OFFSET + 100, genesis);\n    }\n\n    function test__general__NuggftV1Epoch__toStartBlock__gas__safe() public view {\n        safe__toStartBlock(OFFSET + 100, genesis);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [pure] toEndBlock\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function safe__toEndBlock(uint24 _epoch, uint256 gen) internal pure returns (uint256 res) {\n        res = safe__toStartBlock(_epoch + 1, gen) - 1;\n    }\n\n    function semisafe__toEndBlock(uint24 _epoch, uint256 gen) internal pure returns (uint256 res) {\n        res = toStartBlock(_epoch + 1, gen) - 1;\n    }\n\n    function test__general__NuggftV1Epoch__toEndBlock__symbolic(uint32 _epoch, uint32 gen) public {\n        uint24 epoch = uint24(_epoch);\n\n        if (_epoch < OFFSET || _epoch > 1000000) return;\n        if (gen < 1000000) return;\n\n        if (gen == 0) return;\n        if (epoch == 0) return;\n\n        uint256 got = toEndBlock(epoch, gen);\n        uint256 exp = safe__toEndBlock(epoch, gen);\n\n        assertEq(got, exp, 'toEndBlock: real != safe');\n    }\n\n    function test__general__NuggftV1Epoch__toEndBlock__gas() public view {\n        toEndBlock(OFFSET + 100, genesis);\n    }\n\n    function test__general__NuggftV1Epoch__toEndBlock__gas__safe() public view {\n        safe__toEndBlock(OFFSET + 100, genesis);\n    }\n\n    function test__general__NuggftV1Epoch__toEndBlock__gas__semisafe() public view {\n        semisafe__toEndBlock(OFFSET + 100, genesis);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [pure] toEndBlock\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}