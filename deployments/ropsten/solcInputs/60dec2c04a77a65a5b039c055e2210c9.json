{
  "language": "Solidity",
  "sources": {
    "src/_mock/libraries/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Modified from 0xSequence (https://github.com/0xsequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1;\n\n    function write(bytes memory data) internal returns (address pointer) {\n        bytes memory runtimeCode = abi.encodePacked(hex'00', data);\n\n        bytes memory creationCode = abi.encodePacked(hex'63', uint32(runtimeCode.length), hex'80_60_0E_60_00_39_60_00_F3', runtimeCode);\n\n        assembly {\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), 'DEPLOYMENT_FAILED');\n    }\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, 'OUT_OF_BOUNDS');\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(add(size, add(start, 0x20)), 0x1f), not(0x1f))))\n            mstore(data, size)\n            extcodecopy(pointer, add(data, 0x20), start, size)\n        }\n    }\n}\n"
    },
    "src/_mock/MockdotnuggV1Processer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../interfaces/dotnuggv1/IDotnuggV1Processor.sol';\nimport '../interfaces/dotnuggv1/IDotnuggV1Data.sol';\nimport '../interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\n\nimport '../_test/utils/Print.sol';\n\n\nimport {SSTORE2} from './libraries/SSTORE2.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\n\nabstract contract DotnuggV1Storage is IDotnuggV1Storage {\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    // Mapping from token ID to owner address\n    mapping(address => mapping(uint8 => uint168[])) sstore2Pointers;\n    mapping(address => mapping(uint8 => uint8)) featureLengths;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function storeFiles(uint8 feature, uint256[][] calldata data) external override returns (uint8 res) {\n        uint8 len = data.length.safe8();\n\n        require(len > 0, 'F:0');\n\n        address ptr = SSTORE2.write(abi.encode(data));\n\n        sstore2Pointers[msg.sender][feature].push(uint168(uint160(ptr)) | (uint168(len) << 160));\n\n        featureLengths[msg.sender][feature] += len;\n\n        return len;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 GET FILES\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function getBatchFiles(address implementer, uint8[] memory ids) internal view returns (uint256[][] memory data) {\n        data = new uint256[][](ids.length);\n\n        for (uint8 i = 0; i < ids.length; i++) {\n            if (ids[i] == 0) data[i] = new uint256[](0);\n            else data[i] = get(implementer, i, ids[i]);\n        }\n    }\n\n    function get(\n        address implementer,\n        uint8 feature,\n        uint8 pos\n    ) internal view returns (uint256[] memory data) {\n        require(pos != 0, 'F:1');\n\n        pos--;\n\n        uint8 totalLength = featureLengths[implementer][feature];\n\n        require(pos < totalLength, 'F:2');\n\n        uint168[] memory ptrs = sstore2Pointers[implementer][feature];\n\n        address store;\n        uint8 storePos;\n\n        uint8 workingPos;\n\n        for (uint256 i = 0; i < ptrs.length; i++) {\n            uint8 here = uint8(ptrs[i] >> 160);\n            if (workingPos + here > pos) {\n                store = address(uint160(ptrs[i]));\n                storePos = pos - workingPos;\n                break;\n            } else {\n                workingPos += here;\n            }\n        }\n\n        require(store != address(0), 'F:3');\n\n        data = abi.decode(SSTORE2.read(address(uint160(store))), (uint256[][]))[storePos];\n    }\n}\n\n\ncontract MockdotnuggV1Processor is IDotnuggV1Processor, DotnuggV1Storage {\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) public view override returns (uint256[] memory resp, IDotnuggV1Data.Data memory dat) {\n        IDotnuggV1Data.Data memory data = IDotnuggV1Implementer(implementer).dotnuggV1Callback(tokenId);\n        uint256[][] memory files = getBatchFiles(implementer, data.ids);\n        resp = processCore(files, data, width);\n        dat = data;\n    }\n\n\n    function storedAmount(        address implementer,        uint8 feature) public override view returns (uint8 res) {\n        return featureLengths[implementer][feature];\n}\n\n\n\n    function processCore(\n        uint256[][] memory files,\n        IDotnuggV1Data.Data memory,\n        uint8 width\n    ) public view returns (uint256[] memory file) {\n        Print.log(width, 'width');\n\n        for (uint256 i = 0; i < files.length; i++) {\n            Print.log(files[i], 'files[i]');\n        }\n        return files[0];\n    }\n\n    function resolveBytes(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (bytes memory res) {\n        res = abi.encode(file);\n    }\n\n    function resolveData(\n        uint256[] memory,\n        IDotnuggV1Data.Data memory data,\n        uint8\n    ) public pure override returns (IDotnuggV1Data.Data memory res) {\n        res = data;\n    }\n\n    function resolveString(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (string memory res) {\n        res = string(abi.encode(file));\n    }\n\n    function resolveRaw(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (uint256[] memory res) {\n        res = file;\n    }\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (uint256[] memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            res = IDotnuggV1Processor(resolver).resolveRaw(res, data, zoom);\n        } else {\n            res = file;\n        }\n    }\n\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (bytes memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IDotnuggV1Processor(resolver).resolveBytes(file, data, zoom);\n    }\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (string memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IDotnuggV1Processor(resolver).resolveString(file, data, zoom);\n    }\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (IDotnuggV1Data.Data memory res) {\n        (uint256[] memory file, IDotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IDotnuggV1Processor(resolver).resolveData(file, data, zoom);\n    }\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Processor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\nimport {IDotnuggV1Resolver} from './IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Storage} from './IDotnuggV1Storage.sol';\n\ninterface IDotnuggV1Processor is IDotnuggV1Resolver, IDotnuggV1Storage {\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (IDotnuggV1Data.Data memory res);\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (string memory res);\n\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) external view returns (uint256[] memory file, IDotnuggV1Data.Data memory dat);\n\n    function processCore(\n        uint256[][] memory files,\n        IDotnuggV1Data.Data memory data,\n        uint8 width\n    ) external view returns (uint256[] memory file);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Data.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1Data {\n    struct Data {\n        uint256 version;\n        uint256 renderedAt;\n        string name;\n        string desc;\n        address owner;\n        uint256 tokenId;\n        uint256 proof;\n        uint8[] ids;\n        uint8[] extras;\n        uint8[] xovers;\n        uint8[] yovers;\n    }\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Implementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\n\ninterface IDotnuggV1Implementer {\n    function dotnuggV1Callback(uint256 tokenId) external view returns (IDotnuggV1Data.Data memory data);\n\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external;\n}\n"
    },
    "src/_test/utils/Print.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n//\n\nlibrary Print {\n    function log(uint256 val, string memory name) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2\n    ) internal view {\n\n\n\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1\n    ) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3\n    ) internal view {\n\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3,\n        uint256 val4,\n        string memory name4\n    ) internal view {\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n    function log(uint256[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n\n    function log(uint8[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n}\n\nlibrary Uint256 {\n    bytes16 private constant ALPHABET = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAscii(uint256 value) internal pure returns (bytes memory buffer) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return buffer;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        return string(toAscii(value));\n    }\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// library Event {\n//     function log(uint256 val, string memory name) internal view {}\n\n//     function log(\n//         uint256 val0,\n//         string memory name0,\n//         uint256 val1,\n//         string memory name1,\n//         uint256 val2,\n//         string memory name2\n//     ) internal view {}\n\n//     function log(uint256[] memory arr, string memory name) internal view {}\n// }\n"
    },
    "src/libraries/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        require(x <= type(uint160).max);\n        y = uint160(x);\n    }\n\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        require(x <= type(uint96).max);\n        y = uint96(x);\n    }\n\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        require(x <= type(uint64).max);\n        y = uint64(x);\n    }\n\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        require(x <= type(uint32).max);\n        y = uint32(x);\n    }\n\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        require(x <= type(uint16).max);\n        y = uint16(x);\n    }\n\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        require(x <= type(uint8).max);\n        y = uint8(x);\n    }\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\n\ninterface IDotnuggV1Resolver {\n    function resolveBytes(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function resolveRaw(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function resolveData(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (IDotnuggV1Data.Data memory res);\n\n    function resolveString(\n        uint256[] memory file,\n        IDotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Data} from './IDotnuggV1Data.sol';\n\ninterface IDotnuggV1Storage {\n    function storedAmount(address implementer, uint8 feature) external returns (uint8);\n\n    function storeFiles(uint8 feature, uint256[][] calldata data) external returns (uint8 amount);\n}\n"
    },
    "src/_test/fixtures/NuggFather.fix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../utils/DSTestPlus.sol';\n\nimport {User} from '../utils/User.sol';\n\nimport {MockdotnuggV1Processor} from '../../_mock/MockdotnuggV1Processer.sol';\n\nimport {MockNuggftV1Migrator} from '../../_mock/MockNuggftV1Migrator.sol';\n\nimport {NuggftV1} from '../../NuggftV1.sol';\n\ncontract RiggedNuggft is NuggftV1 {\n    constructor(address processor) NuggftV1(processor) {\n        featureLengths = 0x0303030303030303;\n    }\n}\n\nlibrary SafeCast {\n    function safeInt(uint96 input) internal pure returns (int192) {\n        return (int192(int256(uint256(input))));\n    }\n}\n\ncontract NuggFatherFix is t {\n    using SafeCast for uint96;\n    using SafeCast for uint256;\n    using SafeCast for uint64;\n\n    MockdotnuggV1Processor public processor;\n\n    MockNuggftV1Migrator public migrator;\n\n    RiggedNuggft public nuggft;\n\n    User public safe;\n\n    User public frank;\n    User public charlie;\n    User public dennis;\n    User public mac;\n    User public dee;\n\n    User public any;\n\n    function reset() public {\n        fvm.roll(1);\n        fvm.roll(2);\n        processor = new MockdotnuggV1Processor();\n        migrator = new MockNuggftV1Migrator();\n        nuggft = new RiggedNuggft(address(processor));\n\n        safe = new User{value: 1000 ether}();\n        frank = new User{value: 1000 ether}();\n        charlie = new User{value: 1000 ether}();\n        dennis = new User{value: 1000 ether}();\n        mac = new User{value: 1000 ether}();\n        dee = new User{value: 1000 ether}();\n\n        any = new User();\n\n        nuggft.setIsTrusted(address(safe), true);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                eth modifiers\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    struct ChangeCheck {\n        int192 before_staked;\n        int192 before_protocol;\n        int192 before_shares;\n        int192 before_minSharePrice;\n        int192 before_eps;\n        //\n        int192 after_staked;\n        int192 after_protocol;\n        int192 after_shares;\n        int192 after_minSharePrice;\n        int192 after_eps;\n    }\n\n    modifier changeInStaked(int192 change, int192 shareChange) {\n        ChangeCheck memory str;\n        str.before_staked = nuggft.stakedEth().safeInt();\n        str.before_protocol = nuggft.protocolEth().safeInt();\n        str.before_shares = nuggft.stakedShares().safeInt();\n        str.before_minSharePrice = nuggft.minSharePrice().safeInt();\n\n        str.before_eps = nuggft.ethPerShare().safeInt();\n\n        assertEq(\n            str.before_eps,\n            str.before_shares > 0 ? str.before_staked / str.before_shares : int256(0),\n            'EPS is starting off with an incorrect value'\n        );\n\n        _;\n        str.after_staked = nuggft.stakedEth().safeInt();\n        str.after_protocol = nuggft.protocolEth().safeInt();\n        str.after_shares = nuggft.stakedShares().safeInt();\n        str.after_minSharePrice = nuggft.minSharePrice().safeInt();\n\n        assertTrue(str.after_minSharePrice >= str.before_minSharePrice, 'minSharePrice is did not increase as expected');\n        assertEq(str.after_protocol - str.before_protocol, take(10, change), 'totalProtocol is not what is expected');\n        assertEq(str.after_staked - str.before_staked, change - take(10, change), 'staked change is not 90 percent of expected change');\n        assertEq(str.after_shares - str.before_shares, shareChange, 'shares difference is not what is expected');\n\n        str.after_eps = nuggft.ethPerShare().safeInt();\n        assertEq(\n            str.after_eps,\n            str.after_shares > 0 ? str.after_staked / str.after_shares : int256(0),\n            'EPS is not ending with correct value'\n        );\n    }\n\n    modifier changeInUserBalance(User user, int192 change) {\n        ChangeCheck memory str;\n\n        str.before_staked = int192(int256(uint256(address(user).balance)));\n        _;\n        str.after_staked = int192(int256(uint256(address(user).balance)));\n\n        assertEq(str.after_staked - str.before_staked, change, 'user balance did not change');\n    }\n\n    modifier changeInNuggftBalance(int192 change) {\n        ChangeCheck memory str;\n\n        str.before_staked = int192(int256(uint256(address(nuggft).balance)));\n        _;\n        str.after_staked = int192(int256(uint256(address(nuggft).balance)));\n\n        assertEq(str.after_staked - str.before_staked, change, 'nuggft balance did not change');\n    }\n\n    // modifier changeInMinSharePrice(int192 change) {\n    //     int192 bef = int192(int256(uint256(nuggft.minSharePrice())));\n    //     _;\n    //     int192 aft = int192(int256(uint256(nuggft.minSharePrice())));\n\n    //     assertEq(aft - bef, change);\n    // }\n\n    // modifier changeInStakedShares(int192 change) {\n    //     int192 bef = int192(int256(uint256(nuggft.stakedShares())));\n    //     _;\n    //     int192 aft = int192(int256(uint256(nuggft.stakedShares())));\n\n    //     assertEq(aft - bef, change);\n    // }\n\n    // modifier changeInStakedEth(int192 change) {\n    //     int192 bef = int192(int256(uint256(nuggft.stakedEth())));\n    //     _;\n    //     int192 aft = int192(int256(uint256(nuggft.stakedEth())));\n\n    //     assertEq(aft - bef, change);\n    // }\n\n    function nuggft_call(User user, bytes memory args) public payable {\n        nuggft_call(user, args, 0);\n    }\n\n    function nuggft_call(\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) public payable {\n        user.call(address(nuggft), args, eth);\n    }\n\n    function nuggft_revertCall(\n        string memory message,\n        User user,\n        bytes memory args\n    ) public payable {\n        nuggft_revertCall(message, user, args, 0);\n    }\n\n    function nuggft_revertCall(\n        string memory message,\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) public payable {\n        user.revertCall{value: eth}(address(nuggft), message, args);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                encodeWithSelector\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function delegate(address sender, uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.delegate.selector, sender, tokenId);\n    }\n\n    function delegateItem(\n        uint256 buyerTokenId,\n        uint256 sellerTokenId,\n        uint256 itemId\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.delegateItem.selector, buyerTokenId, sellerTokenId, itemId);\n    }\n\n    function claim(address sender, uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.claim.selector, sender, tokenId);\n    }\n\n    function swap(uint256 tokenId, uint96 floor) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.swap.selector, tokenId, floor);\n    }\n\n    function loan(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.loan.selector, tokenId);\n    }\n\n    function payoff(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.payoff.selector, tokenId);\n    }\n\n    function rebalance(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.rebalance.selector, tokenId);\n    }\n\n    function loanInfo(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.loanInfo.selector, tokenId);\n    }\n\n    function swapItem(\n        uint256 tokenId,\n        uint256 itemId,\n        uint96 floor\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.swapItem.selector, tokenId, itemId, floor);\n    }\n\n    function claimItem(\n        uint256 buyerTokenId,\n        uint256 sellerTokenId,\n        uint256 itemId\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.claimItem.selector, buyerTokenId, sellerTokenId, itemId);\n    }\n\n    function rotateFeature(uint256 tokenId, uint256 feature) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.rotateFeature.selector, tokenId, feature);\n    }\n\n    function burn(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.burn.selector, tokenId);\n    }\n\n    function migrate(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.migrate.selector, tokenId);\n    }\n\n    function setMigrator(address _migrator) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.setMigrator.selector, _migrator);\n    }\n\n    function approve(address addr, uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.approve.selector, addr, tokenId);\n    }\n\n    function setApprovalForAll(address addr, bool appr) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.setApprovalForAll.selector, addr, appr);\n    }\n\n    function mint(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.mint.selector, tokenId);\n    }\n\n    function trustedMint(uint256 tokenId, address to) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.trustedMint.selector, tokenId, to);\n    }\n\n    function take(int256 percent, int256 value) internal pure returns (int256) {\n        return (value * percent) / 100;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                scenarios\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function scenario_dee_has_a_token() public payable returns (uint160 tokenId) {\n        tokenId = 2069;\n        nuggft_call(dee, mint(tokenId));\n    }\n\n    function scenario_frank_has_a_token_and_spent_50_eth() public payable returns (uint160 tokenId) {\n        tokenId = 2012;\n        nuggft_call(frank, mint(tokenId), 50 ether);\n    }\n\n    function scenario_frank_has_a_loaned_token() public payable returns (uint160 tokenId) {\n        scenario_charlie_has_a_token();\n\n        tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        {\n            nuggft_call(frank, approve(address(nuggft), tokenId));\n        }\n\n        nuggft_call(frank, loan(tokenId));\n    }\n\n    function scenario_frank_has_a_loaned_token_that_has_expired() public payable returns (uint160 tokenId) {\n        tokenId = scenario_frank_has_a_loaned_token();\n\n        fvm.roll(200000);\n    }\n\n    function scenario_dee_has_a_token_2() public payable returns (uint160 tokenId) {\n        tokenId = 2400;\n        nuggft_call(dee, mint(tokenId));\n    }\n\n    function scenario_charlie_has_a_token() public payable returns (uint160 tokenId) {\n        tokenId = 2070;\n        nuggft_call(charlie, mint(tokenId));\n    }\n\n    function scenario_migrator_set() public payable {\n        nuggft_call(safe, setMigrator(address(migrator)));\n    }\n\n    function scenario_dee_has_a_token_and_can_swap() public payable returns (uint160 tokenId) {\n        tokenId = scenario_dee_has_a_token();\n\n        nuggft_call(dee, approve(address(nuggft), tokenId));\n    }\n\n    function scenario_dee_has_swapped_a_token() public payable returns (uint160 tokenId, uint96 floor) {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        floor = 1 ether;\n\n        nuggft_call(dee, swap(tokenId, floor));\n    }\n\n    function scenario_dee_has_swapped_a_token_and_mac_has_delegated() public payable returns (uint160 tokenId, uint96 eth) {\n        (tokenId, ) = scenario_dee_has_swapped_a_token();\n\n        eth = 2 ether;\n\n        nuggft_call(mac, delegate(address(mac), tokenId), eth);\n    }\n\n    function scenario_dee_has_swapped_a_token_and_mac_can_claim() public payable returns (uint160 tokenId) {\n        (tokenId, ) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        fvm.roll(2000);\n    }\n\n    function scenario_mac_has_claimed_a_token_dee_swapped() public payable returns (uint160 tokenId) {\n        (tokenId) = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        nuggft_call(mac, claim(address(mac), tokenId));\n    }\n\n    function scenario_mac_has_swapped_a_token_dee_swapped() public payable returns (uint160 tokenId, uint96 floor) {\n        (tokenId) = scenario_mac_has_claimed_a_token_dee_swapped();\n        floor = 3 ether;\n\n        nuggft_call(mac, approve(address(nuggft), tokenId));\n\n        nuggft_call(mac, swap(tokenId, floor));\n    }\n\n    function scenario_dee_has_a_token_and_can_swap_an_item()\n        public\n        payable\n        returns (\n            uint160 tokenId,\n            uint16 itemId,\n            uint8 feature\n        )\n    {\n        (tokenId) = scenario_dee_has_a_token();\n\n        (, uint8[] memory items, , , ) = nuggft.parsedProofOf(tokenId);\n\n        feature = 1;\n        itemId = items[feature] | (uint16(feature) << 8);\n\n        nuggft_call(dee, rotateFeature(tokenId, feature));\n    }\n\n    function scenario_dee_has_swapped_an_item()\n        public\n        payable\n        returns (\n            uint160 tokenId,\n            uint8 feature,\n            uint16 itemId,\n            uint96 floor\n        )\n    {\n        (tokenId, itemId, feature) = scenario_dee_has_a_token_and_can_swap_an_item();\n        floor = 3 ether;\n\n        nuggft_call(dee, swapItem(tokenId, itemId, floor));\n    }\n\n    function scenario_dee_has_swapped_an_item_and_charlie_can_claim()\n        public\n        payable\n        returns (\n            uint160 charliesTokenId,\n            uint160 tokenId,\n            uint16 itemId\n        )\n    {\n        uint256 feature;\n        uint96 floor;\n        (tokenId, feature, itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        nuggft_call(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n\n        fvm.roll(2000);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                scenarios\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // function environment() public returns (address[] memory users) {\n    //     users = new address[](2000);\n\n    //     User start = new User{value: 69 ether}();\n    //     uint160 count = 501;\n\n    //                 fvm.deal(address(start), 69 ether);\n\n    //     nuggft_call(start, mint(count++), .01 ether);\n    //     nuggft_call(start, mint(count++), nuggft.minSharePrice());\n    //     nuggft_call(start, mint(count++), nuggft.minSharePrice());\n\n    //     users[0] = address(start);\n\n    //     for (uint256 i = 1; i < users.length; i++) {\n    //         User tmp = new User{value: 69 ether}();\n\n    //         fvm.deal(address(tmp), 69 ether);\n\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n\n    //         users[i] = address(tmp);\n    //     }\n\n    // }\n\n    function environmentForge() public returns (address[] memory users) {\n        users = new address[](9500);\n\n        User start = new User{value: 1000000000 ether}();\n        uint160 count = 501;\n\n        //   fvm.deal(address(start), 10000 *10**18);\n\n        nuggft_call(start, mint(count++), .08 ether);\n\n        users[0] = address(start);\n\n        int256 last = 0;\n        int256 lastDiff = 0;\n\n        for (uint256 i = 1; i < users.length; i++) {\n            // User tmp = new User{value: 100000000 ether}();\n\n            // fvm.deal(address(tmp), 10000 *10**18);\n\n            nuggft_call(start, mint(count++), nuggft.minSharePrice());\n\n            int256 curr = nuggft.minSharePrice().safeInt();\n\n            users[i] = address(start);\n\n            int256 diff = curr - last;\n            emit log_named_int('diff', curr - last);\n            emit log_named_int('ldif', diff - lastDiff);\n\n            emit log_named_uint('nuggft.ethPerShare()', nuggft.ethPerShare());\n            // emit log_named_uint('nuggft.protocolEth()', nuggft.protocolEth());\n            // emit log_named_uint('nuggft.stakedEth()', nuggft.stakedEth());\n            emit log_named_uint('nuggft.stakedShares()', nuggft.stakedShares());\n            emit log_named_uint('nuggft.minSharePrice()', nuggft.minSharePrice());\n\n            emit log_string('--------');\n\n            last = curr;\n            lastDiff = diff;\n        }\n    }\n\n    function environmentForge2() public returns (address[] memory users) {\n        users = environmentForge();\n\n        uint256 bn = 5000;\n\n        // for (uint256 i = 0; i < 10000; i++) {\n        //     uint256 epoch = nuggft.epoch();\n\n        //     uint256 funner = uint256(keccak256(abi.encodePacked(epoch))) % 100;\n\n        //     nuggft_call(User(payable(users[funner])), delegate(users[funner], epoch), nuggft.minSharePrice());\n\n        //     fvm.roll(bn);\n\n        //     bn += 70;\n\n        //     nuggft_call(User(payable(users[funner])), claim(users[funner], epoch));\n        // }\n\n        assert(false);\n    }\n}\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 36422938319266817\n//   nuggft.protocolEth(): 13721927850988207037\n//   nuggft.stakedEth(): 254960568234867720007\n//   nuggft.stakedShares(): 7000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .220269870602728762\n//   nuggft.protocolEth(): 105.652900187038601090\n//   nuggft.stakedEth(): 3524.317929643660202576\n//   nuggft.stakedShares(): 16000\n\n// Success: test__system1()\n// *10\n//   users length: 2000\n//   nuggft.ethPerShare():  .081046931383505748\n//   nuggft.protocolEth(): 36.036371675422002761\n//   nuggft.stakedEth():  891.516245218563229016\n//   nuggft.stakedShares(): 11000\n\n//   users length: 2000\n//   nuggft.ethPerShare():   .009923420616251655\n//   nuggft.protocolEth():  10.797105517187750828\n//   nuggft.stakedEth():   109.157626778768205405\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .023820112972809680\n//   nuggft.protocolEth(): 23.605706549631210195\n//   nuggft.stakedEth(): 262.021242700906482643\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 22283800801842573\n//   nuggft.protocolEth(): 12045486919914902312\n//   nuggft.stakedEth(): 133702804811055442627\n//   nuggft.stakedShares(): 6000\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 1.124042581556443270\n//   nuggft.protocolEth(): 658.232592803322633239\n//   nuggft.stakedEth(): 7306.276780116881258328\n//   nuggft.stakedShares(): 6500\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .179846813049030914\n//   nuggft.protocolEth(): 105317214848531614175\n//   nuggft.stakedEth(): 1169004284818700946598\n//   nuggft.stakedShares(): 6500\n\n// .092595956292375926\n\n// .101719406217199627\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .178270406414740660\n//   nuggft.protocolEth(): 96363895359319273644\n//   nuggft.stakedEth(): 1069622438488443964472\n//   nuggft.stakedShares(): 6000\n\n// Success: test__system1()\n\n//   users length: 1000\n//   nuggft.ethPerShare():   1.425741271002990526\n//   nuggft.protocolEth():  305.518843786355111578\n//   nuggft.stakedEth():   4277.223813008971579744\n//   nuggft.stakedShares(): 3000\n"
    },
    "src/_test/utils/DSTestPlus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTest} from '../../../lib/ds-test/src/test.sol';\n\nimport {Hevm, ForgeVm} from './Vm.sol';\n\n\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    //    Vm vm = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    bytes32 checkpointLabel;\n    uint256 private checkpointGasLeft;\n\n    function startMeasuringGas(bytes32 label) internal virtual {\n        checkpointLabel = label;\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        bytes32 label = checkpointLabel;\n\n        emit log_named_uint(string(abi.encodePacked(label, ' Gas')), checkpointGasLeft - checkpointGasLeft2 - 22134);\n    }\n\n    function fail(bytes32 err) internal virtual {\n        emit log_named_string('Error', string(abi.encodePacked(err)));\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertUint128Eq(uint128 a, uint128 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint64Eq(uint64 a, uint64 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint96Eq(uint96 a, uint96 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint32Eq(uint32 a, uint32 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log('Error: a == b not satisfied [bytes]');\n            emit log_named_bytes('  Expected', b);\n            emit log_named_bytes('    Actual', a);\n            fail();\n        }\n    }\n}\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, 'NO_TARGET_CONTRACTS');\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"
    },
    "src/_test/utils/User.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ForgeVm} from './Vm.sol';\n\ncontract User {\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    event log_named_string(string key, string val);\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor() payable {}\n\n    // function call(\n    //     address target,\n    //     bytes4 selector,\n    //     bytes memory args\n    // ) public payable virtual returns (bytes memory returnData) {\n    //     returnData = call(target, abi.encodeWithSelector(selector, args));\n    // }\n\n    function tryCall(address target, bytes memory data) public payable virtual returns (bool success, bytes memory returnData) {\n        (success, returnData) = target.call{value: msg.value}(data);\n    }\n\n    function call(\n        address target,\n        bytes memory data,\n        uint256 eth\n    ) public payable virtual returns (bytes memory returnData) {\n        bool success;\n        (success, returnData) = target.call{value: eth}(data);\n\n        if (!success) {\n            if (returnData.length > 0) {\n                assembly {\n                    let returnDataSize := mload(returnData)\n                    revert(add(32, returnData), returnDataSize)\n                }\n            } else {\n                revert('REVERTED_WITHOUT_MESSAGE');\n            }\n        }\n    }\n\n    function revertCall(\n        address target,\n        string memory message,\n        bytes memory data\n    ) public payable virtual {\n        (bool callSuccess, bytes memory returnData) = target.call{value: msg.value}(data);\n\n        require(!callSuccess, 'REVERT-CALL SUCCEEDED');\n\n        string memory revertReason = string(extractRevertReason(returnData));\n\n        if (!compareStrings(revertReason, message)) {\n            revert(string(abi.encodePacked('UNEXPECTED REVERT: ', revertReason, ' EXPECTED: ', message)));\n        }\n    }\n\n    function extractRevertReason(bytes memory revertData) internal pure returns (string memory reason) {\n        uint256 l = revertData.length;\n        if (l < 68) return '';\n        uint256 t;\n        assembly {\n            revertData := add(revertData, 4)\n            t := mload(revertData) // Save the content of the length slot\n            mstore(revertData, sub(l, 4)) // Set proper length\n        }\n        reason = abi.decode(revertData, (string));\n        assembly {\n            mstore(revertData, t) // Restore the content of the length slot\n        }\n    }\n\n    function compareStrings(string memory a, string memory b) public pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "src/_mock/MockNuggftV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Migrator} from '../interfaces/nuggftv1/INuggftV1Migrator.sol';\n\ncontract MockNuggftV1Migrator is INuggftV1Migrator {\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable override {\n        emit MigrateV1Accepted(msg.sender, tokenId, proof, owner, uint96(msg.value));\n    }\n}\n"
    },
    "src/NuggftV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721, IERC165, IERC721Metadata} from './interfaces/IERC721.sol';\n\nimport {NuggftV1Loan} from './core/NuggftV1Loan.sol';\nimport {NuggftV1Dotnugg} from './core/NuggftV1Dotnugg.sol';\nimport {Trust} from './core/Trust.sol';\n\nimport {INuggftV1Migrator} from './interfaces/nuggftv1/INuggftV1Migrator.sol';\nimport {IDotnuggV1Data} from './interfaces/dotnuggv1/IDotnuggV1Data.sol';\nimport {IDotnuggV1Implementer} from './interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1ImplementerMetadata} from './interfaces/dotnuggv1/IDotnuggV1ImplementerMetadata.sol';\nimport {IDotnuggV1Processor} from './interfaces/dotnuggv1/IDotnuggV1Processor.sol';\n\nimport {INuggftV1Token} from './interfaces/nuggftv1/INuggftV1Token.sol';\nimport {INuggftV1Stake} from './interfaces/nuggftv1/INuggftV1Stake.sol';\n\nimport {INuggftV1} from './interfaces/nuggftv1/INuggftV1.sol';\n\nimport {SafeTransferLib} from './libraries/SafeTransferLib.sol';\nimport {SafeCastLib} from './libraries/SafeCastLib.sol';\n\nimport {NuggftV1StakeType} from './types/NuggftV1StakeType.sol';\n\n/// @title NuggFT V1\n/// @author nugg.xyz - danny7even & dub6ix\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\n/// @dev the words \"share\" and \"nugg\" are used interchangably throughout\n\n/// deviations from ERC721 standard:\n/// 1. no verificaiton the receiver is a ERC721Reciever - on top of this being a gross waste of gas,\n/// the way the swapping logic works makes this only worth calling when a user places an offer - and\n/// we did not want to call \"onERC721Recieved\" when no token was being sent.\n/// 2.\ncontract NuggftV1 is IERC721Metadata, NuggftV1Loan {\n    using SafeCastLib for uint256;\n\n    using NuggftV1StakeType for uint256;\n\n    constructor(address _defaultResolver) NuggftV1Dotnugg(_defaultResolver) Trust(msg.sender) {}\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IDotnuggV1Implementer).interfaceId ||\n            interfaceId == type(IDotnuggV1ImplementerMetadata).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function name() public pure override returns (string memory) {\n        return 'Nugg Fungible Token V1';\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return 'NUGGFT';\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory res) {\n        uint160 safeTokenId = tokenId.safe160();\n\n        address resolver = hasResolver(safeTokenId) ? dotnuggV1ResolverOf(safeTokenId) : dotnuggV1Processor;\n\n        res = IDotnuggV1Processor(dotnuggV1Processor).dotnuggToString(\n            address(this),\n            tokenId,\n            resolver,\n            dotnuggV1DefaultWidth,\n            dotnuggV1DefaultZoom\n        );\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                CORE\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc IDotnuggV1Implementer\n    function dotnuggV1Callback(uint256 tokenId) public view override returns (IDotnuggV1Data.Data memory data) {\n        (uint256 proof, uint8[] memory ids, uint8[] memory extras, uint8[] memory xovers, uint8[] memory yovers) = parsedProofOf(\n            tokenId.safe160()\n        );\n\n        data = IDotnuggV1Data.Data({\n            version: 1,\n            renderedAt: block.timestamp,\n            name: 'NuggFT V1',\n            desc: 'Nugg Fungible Token V1',\n            owner: proof != 0 ? _ownerOf(tokenId.safe160()) : address(0),\n            tokenId: tokenId,\n            proof: proof,\n            ids: ids,\n            extras: extras,\n            xovers: xovers,\n            yovers: yovers\n        });\n    }\n\n    /// @inheritdoc INuggftV1Token\n    function trustedMint(uint160 tokenId, address to) external payable override requiresTrust {\n        require(tokenId < TRUSTED_MINT_TOKENS && tokenId != 0, 'G:1');\n\n        // require(!exists(tokenId), 'G:2');\n\n        addStakedShareFromMsgValue();\n\n        setProof(tokenId);\n\n        _mintTo(to, tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Token\n    function mint(uint160 tokenId) public payable override {\n        require(tokenId < UNTRUSTED_MINT_TOKENS + TRUSTED_MINT_TOKENS && tokenId > TRUSTED_MINT_TOKENS, 'G:1');\n\n        // require(!exists(tokenId), 'G:2');\n\n        addStakedShareFromMsgValue();\n\n        setProof(tokenId);\n\n        _mintTo(msg.sender, tokenId);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                BURN/MIGRATE\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Stake\n    function burn(uint160 tokenId) external {\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        SafeTransferLib.safeTransferETH(msg.sender, ethOwed);\n\n        emit Burn(tokenId, msg.sender, ethOwed);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function migrate(uint160 tokenId) external {\n        require(migrator != address(0), 'T:4');\n\n        // stores the proof before deleting the nugg\n        uint256 proof = proofOf(tokenId);\n\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        INuggftV1Migrator(migrator).nuggftMigrateFromV1{value: ethOwed}(tokenId, proof, msg.sender);\n\n        emit MigrateV1Sent(migrator, tokenId, proof, msg.sender, ethOwed);\n    }\n\n    /// @notice removes a staked share from the contract,\n    /// @dev this is the only way to remove a share\n    /// @dev caculcates but does not handle dealing the eth - which is handled by the two helpers above\n    /// @dev ensures the user is the owner of the nugg\n    /// @param tokenId the id of the nugg being unstaked\n    /// @return ethOwed -> the amount of eth owed to the unstaking user - equivilent to \"ethPerShare\"\n    function subStakedShare(uint160 tokenId) internal returns (uint96 ethOwed) {\n        // reverts if token does not exist\n        address owner = _ownerOf(tokenId);\n\n        require(_getApproved(tokenId) == address(this) && owner == msg.sender, 'T:3');\n\n        uint256 cache = stake;\n\n        // hanles all logic not related to staking the nugg\n        delete owners[tokenId];\n        delete approvals[tokenId];\n\n        delete swaps[tokenId];\n        delete loans[tokenId];\n        delete proofs[tokenId];\n        delete resolvers[tokenId];\n\n        emitTransferEvent(owner, address(0), tokenId);\n\n        ethOwed = calculateEthPerShare(cache);\n\n        /// TODO - test migration\n        assert(cache.shares() >= 1);\n        assert(cache.staked() >= ethOwed);\n\n        cache = cache.subShares(1);\n        cache = cache.subStaked(ethOwed);\n\n        stake = cache;\n\n        emit UnstakeEth(ethOwed, msg.sender);\n    }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "src/_test/utils/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface Hevm {\n    function warp(uint256) external;\n\n    function roll(uint256) external;\n\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    function load(address, bytes32) external returns (bytes32);\n\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    function addr(uint256) external returns (address);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n}\n\ninterface ForgeVm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n\n    // Loads a storage slot from an address (who, slot)\n    function load(address, bytes32) external returns (bytes32);\n\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    // Signs data, (privateKey, digest) => (r, v, s)\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    // Calls another contract with a specified `msg.sender`, (newSender, contract, input) => (success, returnData)\n    function prank(\n        address,\n        address,\n        bytes calldata\n    ) external payable returns (bool, bytes memory);\n\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Migrator {\n    event MigrateV1Accepted(address v1, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable;\n}\n"
    },
    "src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory data\n    ) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/core/NuggftV1Loan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Loan} from '../interfaces/nuggftv1/INuggftV1Loan.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1AgentType} from '../types/NuggftV1AgentType.sol';\n\nimport {NuggftV1Swap} from './NuggftV1Swap.sol';\n\nabstract contract NuggftV1Loan is INuggftV1Loan, NuggftV1Swap {\n    using SafeCastLib for uint256;\n\n    using NuggftV1AgentType for uint256;\n\n    mapping(uint160 => uint256) loans;\n\n    uint32 constant LIQUIDATION_PERIOD = 1000;\n\n    uint96 constant REBALANCE_FEE_BPS = 100;\n\n    /// @inheritdoc INuggftV1Loan\n    function loan(uint160 tokenId) external override {\n        address sender = _ownerOf(tokenId);\n\n        require(_isOperatorFor(msg.sender, sender), 'L:0');\n\n        (uint256 loanData, ) = NuggftV1AgentType.newAgentType(epoch(), sender, ethPerShare(), false);\n\n        loans[tokenId] = loanData; // starting swap data\n\n        emit TakeLoan(tokenId, loanData.eth());\n\n        approvedTransferToSelf(tokenId);\n\n        SafeTransferLib.safeTransferETH(sender, loanData.eth());\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function payoff(uint160 tokenId) external payable override {\n        (uint96 toPayoff, uint96 toRebalance, uint96 earned, uint96 epochDue, address loaner) = loanInfo(tokenId);\n\n        assert(address(this) == _ownerOf(tokenId)); // should always be true - should revert in loanInfo\n\n        delete loans[tokenId];\n\n        address benif = msg.sender;\n\n        if (epochDue >= epoch()) {\n            // if liquidaton deadline has not passed - check perrmission\n            require(_isOperatorFor(msg.sender, loaner), 'L:1');\n            benif = loaner;\n        }\n\n        uint96 value = msg.value.safe96();\n\n        require(toPayoff <= value, 'L:2');\n\n        uint96 overpayment = value - toRebalance;\n\n        uint96 owed = earned + overpayment;\n\n        emit Rebalance(tokenId, toRebalance, earned);\n\n        emit Payoff(tokenId, benif, toPayoff);\n\n        addStakedEth(toRebalance);\n\n        SafeTransferLib.safeTransferETH(benif, owed);\n\n        checkedTransferFromSelf(benif, tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function rebalance(uint160 tokenId) external payable override {\n        NuggftV1AgentType.Memory memory loanState = NuggftV1AgentType.unpack(loans[tokenId]);\n\n        (, uint96 toRebalance, uint96 earned, , address loaner) = loanInfo(loanState);\n\n        assert(address(this) == _ownerOf(tokenId)); // should always be true - should revert in loanInfo\n\n        require(toRebalance <= msg.value, 'L:3');\n\n        // must be done before new principal is calculated\n        addStakedEth(toRebalance);\n\n        // new base epoch\n        loanState.epoch = epoch();\n\n        // newPrincipal\n        loanState.eth = ethPerShare();\n\n        (uint256 res, uint96 dust) = NuggftV1AgentType.pack(loanState);\n\n        loans[tokenId] = res;\n\n        uint96 overpayment = msg.value.safe96() - toRebalance;\n\n        uint96 owed = earned + overpayment + dust;\n\n        emit Rebalance(tokenId, toRebalance, earned);\n\n        SafeTransferLib.safeTransferETH(loaner, owed);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function valueForPayoff(uint160 tokenId) external view returns (uint96 res) {\n        (res, , , , ) = loanInfo(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function valueForRebalance(uint160 tokenId) external view returns (uint96 res) {\n        (, res, , , ) = loanInfo(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function loanInfo(uint160 tokenId)\n        public\n        view\n        override\n        returns (\n            uint96 toPayoff,\n            uint96 toRebalance,\n            uint96 earned,\n            uint32 epochDue,\n            address loaner\n        )\n    {\n        return loanInfo(NuggftV1AgentType.unpack(loans[tokenId]));\n    }\n\n    function loanInfo(NuggftV1AgentType.Memory memory loanState)\n        internal\n        view\n        returns (\n            uint96 toPayoff,\n            uint96 toRebalance,\n            uint96 earned,\n            uint32 epochDue,\n            address loaner\n        )\n    {\n        // ensure loan exists\n        require(loanState.account != address(0), 'L:4');\n\n        // the amount of eth currently loanded by user\n        uint96 curr = loanState.eth;\n\n        uint96 activeEps = ethPerShare();\n\n        toRebalance = ((curr * REBALANCE_FEE_BPS) / 10000);\n\n        toPayoff = curr + toRebalance;\n\n        // value earned while lone was taken out\n        earned = toPayoff >= activeEps ? 0 : activeEps - toPayoff;\n\n        epochDue = loanState.epoch + LIQUIDATION_PERIOD;\n\n        loaner = loanState.account;\n    }\n}\n"
    },
    "src/core/NuggftV1Dotnugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Storage} from '../interfaces/dotnuggv1/IDotnuggV1Storage.sol';\n\nimport {IDotnuggV1Data} from '../interfaces/dotnuggv1/IDotnuggV1Data.sol';\nimport {IDotnuggV1Resolver} from '../interfaces/dotnuggv1/IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Processor} from '../interfaces/dotnuggv1/IDotnuggV1Processor.sol';\nimport {IDotnuggV1Implementer} from '../interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1ImplementerMetadata} from '../interfaces/dotnuggv1/IDotnuggV1ImplementerMetadata.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {INuggftV1Dotnugg} from '../interfaces/nuggftv1/INuggftV1Dotnugg.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {NuggftV1Token} from './NuggftV1Token.sol';\n\nimport {Trust} from './Trust.sol';\n\nabstract contract NuggftV1Dotnugg is INuggftV1Dotnugg, NuggftV1Token, Trust {\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    address public override dotnuggV1Processor;\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    uint8 public override dotnuggV1DefaultWidth = 45;\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    uint8 public override dotnuggV1DefaultZoom = 10;\n\n    mapping(uint8 => uint168[]) sstore2Pointers;\n    // Mapping from token ID to owner address\n\n    mapping(uint256 => address) resolvers;\n\n    uint256 internal featureLengths;\n\n    constructor(address _dotnuggV1Processor) {\n        require(_dotnuggV1Processor != address(0), 'F:4');\n        dotnuggV1Processor = _dotnuggV1Processor;\n    }\n\n    /// @inheritdoc IDotnuggV1Implementer\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external override requiresTrust {\n        uint8 len = IDotnuggV1Storage(dotnuggV1Processor).storeFiles(feature, data);\n\n        uint256 cache = featureLengths;\n\n        uint8[] memory lengths = ShiftLib.getArray(cache, 0);\n\n        lengths[feature] += len;\n\n        featureLengths = ShiftLib.setArray(cache, 0, lengths);\n    }\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    function setDotnuggV1Resolver(uint256 tokenId, address to) public virtual override {\n        require(_isOperatorForOwner(msg.sender, tokenId.safe160()), 'F:5');\n\n        resolvers[tokenId] = to;\n\n        emit DotnuggV1ResolverUpdated(tokenId, to);\n    }\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    function dotnuggV1ResolverOf(uint256 tokenId) public view virtual override returns (address) {\n        return resolvers[tokenId.safe160()];\n    }\n\n    function hasResolver(uint160 tokenId) internal view returns (bool) {\n        return resolvers[tokenId] != address(0);\n    }\n}\n"
    },
    "src/core/Trust.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ITrust} from '../interfaces/ITrust.sol';\n\n/// @notice Ultra minimal authorization logic for smart contracts.\n/// @author Inspired by Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/auth.sol)\nabstract contract Trust is ITrust {\n    event UserTrustUpdated(address indexed user, bool trusted);\n\n    mapping(address => bool) public override isTrusted;\n\n    constructor(address initialUser) {\n        isTrusted[initialUser] = true;\n\n        emit UserTrustUpdated(initialUser, true);\n    }\n\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\n        isTrusted[user] = trusted;\n\n        emit UserTrustUpdated(user, trusted);\n    }\n\n    modifier requiresTrust() {\n        require(isTrusted[msg.sender], 'UNTRUSTED');\n\n        _;\n    }\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1ImplementerMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1ImplementerMetadata {\n    event DotnuggV1ResolverUpdated(uint256 tokenId, address to);\n\n    function setDotnuggV1Resolver(uint256 tokenId, address to) external;\n\n    function dotnuggV1ResolverOf(uint256 tokenId) external view returns (address resolver);\n\n    function dotnuggV1Processor() external returns (address);\n\n    function dotnuggV1DefaultWidth() external returns (uint8);\n\n    function dotnuggV1DefaultZoom() external returns (uint8);\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721} from '../IERC721.sol';\n\ninterface INuggftV1Token is IERC721 {\n    function mint(uint160 tokenId) external payable;\n\n    function trustedMint(uint160 tokenId, address to) external payable;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Stake {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    event StakeEth(uint96 stake, uint96 protocol);\n    event UnstakeEth(uint96 stake, address to);\n    event ProtocolEthExtracted(uint96 eth);\n    event MigratorV1Updated(address migrator);\n    event MigrateV1Sent(address v2, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n    event Burn(uint160 tokenId, address owner, uint96 ethOwed);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function migrate(uint160 tokenId) external;\n\n    /// @notice burns a nugg from existance, dealing the eth worth of that share to the user\n    /// @dev should only be called directly\n    /// @param tokenId the id of the nugg being burned\n    function burn(uint160 tokenId) external;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice returns the minimum eth that must be added to create a new share\n    /// @dev premium here is used to push against dillution of supply through ensuring the price always increases\n    /// @dev used by the front end\n    /// @return res -> premium + protcolFee + ethPerShare\n    function minSharePrice() external view returns (uint96 res);\n\n    /// @notice returns the amount of eth extractable by protocol\n    /// @dev this will be\n    /// @return res -> (PROTOCOL_FEE_BPS * [all eth staked] / 10000) - [all previously extracted eth]\n    function protocolEth() external view returns (uint96);\n\n    /// @notice returns the total number of staked shares held by the contract\n    /// @dev this is equivilent to the amount of nuggs in existance\n    function stakedShares() external view returns (uint64);\n\n    function totalSupply() external view returns (uint256);\n\n    /// @notice returns the total amount of staked eth held by the contract\n    /// @dev can be used as the market-cap or tvl of all nuggft v1\n    /// @dev not equivilent to the balance of eth the contract holds, which also hs protocolEth and\n    /// unclaimed eth from unsuccessful swaps\n    function stakedEth() external view returns (uint96);\n\n    /// @notice returns the total \"ethPerShare\" held by the contract\n    /// @dev this value not always equivilent to the \"floor\" price which can consist of perceived value.\n    /// can be looked at as an \"intrinsic floor\"\n    /// @dev this is the value that users will receive when their either burn or loan out nuggs\n    /// @return res -> [current staked eth] / [current staked shares]\n    function ethPerShare() external view returns (uint96);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice sends the current protocolEth to the user and resets the value to zero\n    /// @dev caller must be a trusted user\n    function extractProtocolEth() external;\n\n    /// @notice sets the migrator contract\n    /// @dev caller must be a trusted user\n    /// @param migrator the address to set as the migrator contract\n    function setMigrator(address migrator) external;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Token} from './INuggftV1Token.sol';\nimport {INuggftV1Stake} from './INuggftV1Stake.sol';\nimport {INuggftV1Proof} from './INuggftV1Proof.sol';\nimport {INuggftV1Dotnugg} from './INuggftV1Dotnugg.sol';\nimport {INuggftV1Swap} from './INuggftV1Swap.sol';\nimport {INuggftV1Loan} from './INuggftV1Loan.sol';\nimport {INuggftV1Epoch} from './INuggftV1Epoch.sol';\n\nimport {IERC721Metadata} from '../IERC721.sol';\n\ninterface INuggftV1 is\n    IERC721Metadata,\n    INuggftV1Token,\n    INuggftV1Stake,\n    INuggftV1Proof,\n    INuggftV1Dotnugg,\n    INuggftV1Swap,\n    INuggftV1Loan,\n    INuggftV1Epoch\n{}\n"
    },
    "src/libraries/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\nlibrary SafeTransferLib {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               ETH OPERATIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, 'Z:0');\n    }\n}\n"
    },
    "src/types/NuggftV1StakeType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nlibrary NuggftV1StakeType {\n    /// 96 protocol\n    /// 96 stakedEth\n    /// 64 stakedShares\n\n    function proto(uint256 cache) internal pure returns (uint96 res) {\n        res = uint96(cache);\n    }\n\n    function proto(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        res = cache & ShiftLib.fullsubmask(96, 0);\n        res |= update;\n    }\n\n    function addProto(uint256 cache, uint96 add) internal pure returns (uint256 res) {\n        add += proto(cache);\n        res = proto(cache, add);\n    }\n\n    function subProto(uint256 cache, uint96 sub) internal pure returns (uint256 res) {\n        sub = proto(cache) - sub;\n        res = proto(cache, sub);\n    }\n\n    // @test input output unit test\n    function staked(uint256 cache) internal pure returns (uint96 res) {\n        // using casting to select only 96\n        res = uint96(cache >> 96);\n    }\n\n    function staked(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        // clear stakedEth\n        res = cache & ShiftLib.fullsubmask(96, 96);\n        res |= uint256(update) << 96;\n    }\n\n    function addStaked(uint256 cache, uint96 add) internal pure returns (uint256 res) {\n        add += staked(cache);\n        res = staked(cache, add);\n    }\n\n    function subStaked(uint256 cache, uint96 sub) internal pure returns (uint256 res) {\n        sub = staked(cache) - sub;\n        res = staked(cache, sub);\n    }\n\n    // @test input output unit test\n    function shares(uint256 cache) internal pure returns (uint64 res) {\n        res = uint64(cache >> 192);\n    }\n\n    function addShares(uint256 cache, uint64 add) internal pure returns (uint256 res) {\n        add += shares(cache);\n        res = shares(cache, add);\n    }\n\n    function subShares(uint256 cache, uint64 sub) internal pure returns (uint256 res) {\n        sub = shares(cache) - sub;\n        res = shares(cache, sub);\n    }\n\n    function shares(uint256 cache, uint64 update) internal pure returns (uint256 res) {\n        res = cache & type(uint192).max;\n        res |= (uint256(update) << 192);\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Loan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Loan {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event TakeLoan(uint160 tokenId, uint96 principal);\n    event Payoff(uint160 tokenId, address account, uint96 payoffAmount);\n    event Rebalance(uint160 tokenId, uint96 fee, uint96 earned);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function rebalance(uint160 tokenId) external payable;\n\n    function loan(uint160 tokenId) external;\n\n    function payoff(uint160 tokenId) external payable;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @notice for a nugg's active loan: calculates the current min eth a user must send to payoff or rebalance\n    /// @dev contract ->\n    /// @dev frontend -> used to set the amount of eth for user\n    /// @param tokenId the token who's current loan to check\n    /// @return toPayoff ->  the current amount loaned out, plus the final rebalance fee\n    /// @return toRebalance ->  the fee a user must pay to rebalance (and extend) the loan on their nugg\n    /// @return earned -> the amount of eth the minSharePrice has increased since loan was last rebalanced\n    /// @return epochDue -> the final epoch a user is safe from liquidation (inclusive)\n    /// @return loaner -> the user responsable for the loan\n    function loanInfo(uint160 tokenId)\n        external\n        view\n        returns (\n            uint96 toPayoff,\n            uint96 toRebalance,\n            uint96 earned,\n            uint32 epochDue,\n            address loaner\n        );\n\n    /// @notice \"toPayoff\" value from \"loanInfo\"\n    /// @dev should be used to tell user how much eth to send for payoff\n    function valueForPayoff(uint160 tokenId) external view returns (uint96 res);\n\n    /// @notice \"toRebalance\" value from \"loanInfo\"\n    /// @dev should be used to tell user how much eth to send for rebalance\n    function valueForRebalance(uint160 tokenId) external view returns (uint96 res);\n}\n"
    },
    "src/types/NuggftV1AgentType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\nlibrary NuggftV1AgentType {\n    using SafeCastLib for uint256;\n\n    // 10**13\n    uint96 constant COMPRESSION_PERCISION = 0x9184E72A000;\n\n    struct Memory {\n        uint96 eth;\n        uint32 epoch;\n        address account;\n        bool isOwner;\n        bool flag;\n    }\n\n    function unpack(uint256 packed) internal pure returns (Memory memory m) {\n        if (packed != 0) {\n            m.flag = true;\n            m.epoch = epoch(packed);\n            m.account = account(packed);\n            m.eth = eth(packed);\n            m.isOwner = isOwner(packed);\n        }\n    }\n\n    function pack(Memory memory m) internal pure returns (uint256 outuput, uint96 dust) {\n        (outuput, dust) = newAgentType(m.epoch, m.account, m.eth, m.isOwner);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               CALCULATION\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // @test  manual\n    function addIncrement(uint96 value) internal pure returns (uint96) {\n        return compressEthRoundUp(((value * 10200) / 10000));\n    }\n\n    // @test  manual\n    function compressEthRoundDown(uint96 value) internal pure returns (uint96) {\n        return (value / COMPRESSION_PERCISION) * COMPRESSION_PERCISION;\n    }\n\n    // @test  manual\n    function compressEthRoundUp(uint96 value) internal pure returns (uint96) {\n        if (value % COMPRESSION_PERCISION > 0) {\n            return ((value / COMPRESSION_PERCISION) + 1) * COMPRESSION_PERCISION;\n        } else {\n            return compressEthRoundDown(value);\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                              SHIFT HELPERS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    // @test input output unit test\n    // type(uint96).max / 10**13 = 0x01C25C268497681 =  7922816251426433\n    // type(uint56).max          = 0x100000000000000 = 72057594037927936\n    function eth(uint256 input) internal pure returns (uint96 res) {\n        return (ShiftLib.get(input, 56, 160) * COMPRESSION_PERCISION).safe96();\n    }\n\n    function eth(uint256 input, uint96 update) internal pure returns (uint256 cache, uint96 rem) {\n        rem = update % COMPRESSION_PERCISION;\n        cache = ShiftLib.set(input, 56, 160, update / COMPRESSION_PERCISION);\n    }\n\n    // @test  input output unit test\n    function epoch(uint256 input, uint32 update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 32, 216, update);\n    }\n\n    function epoch(uint256 input) internal pure returns (uint32 res) {\n        return ShiftLib.get(input, 32, 216).safe32();\n    }\n\n    // @test  input output unit test\n    function account(uint256 input) internal pure returns (address res) {\n        res = address(ShiftLib.get(input, 160, 0).safe160());\n    }\n\n    function account(uint256 input, address update) internal pure returns (uint256 output) {\n        output = ShiftLib.set(input, 160, 0, uint160(update));\n    }\n\n    // @test  input output unit test\n    function isOwner(uint256 input, bool update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 1, 255, update ? 0x1 : 0x0);\n    }\n\n    function isOwner(uint256 input) internal pure returns (bool output) {\n        output = ShiftLib.get(input, 1, 255) == 0x1;\n    }\n\n    // @test  check to see if it does this - will be easy\n    function flag(uint256 input) internal pure returns (uint256 res) {\n        res = ShiftLib.set(input, 1, 254, 0x01);\n    }\n\n    // @test  manual\n    function newAgentType(\n        uint32 _epoch,\n        address _account,\n        uint96 _eth,\n        bool _isOwner\n    ) internal pure returns (uint256 res, uint96 dust) {\n        res = epoch(res, _epoch);\n        res = account(res, _account);\n        if (_isOwner) res = isOwner(res, true);\n        (res, dust) = eth(res, _eth);\n        res = flag(res);\n    }\n}\n"
    },
    "src/core/NuggftV1Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Swap} from '../interfaces/nuggftv1/INuggftV1Swap.sol';\n\nimport {NuggftV1Stake} from './NuggftV1Stake.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1AgentType} from '../types/NuggftV1AgentType.sol';\n\n/// @notice mechanism for trading of nuggs between users (and items between nuggs)\n/// @dev Explain to a developer any extra details\nabstract contract NuggftV1Swap is INuggftV1Swap, NuggftV1Stake {\n    using SafeCastLib for uint256;\n\n    using NuggftV1AgentType for uint256;\n\n    struct Mapping {\n        Storage self;\n        mapping(uint16 => Storage) items;\n    }\n\n    struct Storage {\n        uint256 data;\n        mapping(address => uint256) offers;\n    }\n\n    struct Memory {\n        uint256 swapData;\n        uint256 offerData;\n        uint32 activeEpoch;\n        address sender;\n    }\n\n    mapping(uint16 => uint256) protocolItems;\n    mapping(uint160 => Mapping) swaps;\n\n    uint96 public constant MIN_OFFER = 10**13 * 50;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  delegate\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function delegate(address sender, uint160 tokenId) external payable override {\n        require(_isOperatorFor(msg.sender, sender), 'S:0');\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        // make sure user is not the owner of swap\n        // we do not know how much to give them when they call \"claim\" otherwise\n\n        if (m.activeEpoch == tokenId && m.swapData == 0) {\n            // to ensure we at least have enough to increment the offer amount by 2%\n            require(msg.value >= MIN_OFFER, 'S:1');\n\n            // we do not need this, could take tokenId out as an argument - but do not want to give users\n            // the ability to accidently place an offer for nugg A and end up minting nugg B.\n            assert(m.offerData == 0);\n\n            (uint256 data, ) = NuggftV1AgentType.newAgentType(m.activeEpoch, m.sender, msg.value.safe96(), false);\n\n            s.data = data;\n\n            addStakedShareFromMsgValue();\n\n            setProofFromEpoch(tokenId);\n\n            emitTransferEvent(address(0), address(this), tokenId);\n\n            emit DelegateMint(tokenId, m.sender, msg.value.safe96());\n        } else {\n            require(m.swapData != 0, 'S:4');\n\n            if (m.offerData != 0) {\n                // forces user to claim previous swap before acting on this one\n                // prevents owner from COMMITTING on their own swap - not offering\n                require(m.offerData.epoch() >= m.activeEpoch, 'S:R');\n\n                require(!m.offerData.isOwner(), 'NOPE'); // always be caught by the require above\n            }\n\n            // if the leader \"owns\" the swap, then it was initated by them - \"commit\" must be executed\n            if (m.swapData.isOwner()) {\n                require(msg.value >= ethPerShare(), 'S:5');\n\n                uint96 newAmount = commit(s, m);\n\n                emit DelegateCommit(tokenId, msg.sender, newAmount);\n            } else {\n                // default -\n                uint96 newAmount = offer(s, m);\n\n                emit DelegateOffer(tokenId, msg.sender, newAmount);\n            }\n        }\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function delegateItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external payable override {\n        require(_isOperatorForOwner(msg.sender, buyerTokenId), 'S:6');\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(buyerTokenId));\n\n        require(m.swapData != 0, 'S:S');\n\n        if (m.offerData != 0) {\n            // forces user to claim previous swap before acting on this one\n            // prevents owner from COMMITTING on their own swap - not offering\n            require(m.offerData.epoch() >= m.activeEpoch, 'S:7');\n\n            require(!m.offerData.isOwner(), 'NOPE'); // always be caught by the require above\n        }\n\n        if (m.offerData == 0 && m.swapData.isOwner()) {\n            uint96 newAmount = commit(s, m);\n\n            emit DelegateCommitItem(sellerTokenId, itemId, buyerTokenId, newAmount);\n        } else {\n            uint96 newAmount = offer(s, m);\n\n            emit DelegateOfferItem(sellerTokenId, itemId, buyerTokenId, newAmount);\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  claim\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function claim(address sender, uint160 tokenId) external override {\n        require(_isOperatorFor(msg.sender, sender), 'S:8');\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        delete s.offers[sender];\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            delete s.data;\n\n            checkedTransferFromSelf(sender, tokenId);\n        } else {\n            SafeTransferLib.safeTransferETH(sender, m.offerData.eth());\n        }\n\n        emit SwapClaim(tokenId, sender, m.offerData.epoch());\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function claimItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external override {\n        require(_isOperatorForOwner(msg.sender, buyerTokenId), 'S:9');\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(buyerTokenId));\n\n        delete s.offers[address(buyerTokenId)];\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            delete s.data;\n\n            require(protocolItems[itemId] > 0, 'P:3');\n\n            addItem(buyerTokenId, itemId);\n\n            protocolItems[itemId]--;\n        } else {\n            SafeTransferLib.safeTransferETH(_ownerOf(buyerTokenId), m.offerData.eth());\n        }\n\n        emit SwapClaimItem(sellerTokenId, itemId, buyerTokenId, m.swapData.epoch());\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  swap\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function swap(uint160 tokenId, uint96 floor) external override {\n        address sender = _ownerOf(tokenId);\n\n        require(_isOperatorFor(msg.sender, sender), 'S:A');\n\n        require(floor >= ethPerShare(), 'S:B');\n\n        approvedTransferToSelf(tokenId);\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        // make sure swap does not exist - this logically should never happen\n        require(m.swapData == 0, 'NOPE2');\n\n        // no need to check dust as no value is being transfered\n        (uint256 dat, uint96 dust) = NuggftV1AgentType.newAgentType(0, sender, floor, true);\n\n        s.data = dat;\n\n        emit SwapStart(tokenId, sender, floor - dust);\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function swapItem(\n        uint160 sellerTokenId,\n        uint16 itemId,\n        uint96 floor\n    ) external override {\n        require(_isOperatorForOwner(msg.sender, sellerTokenId), 'S:C');\n\n        // will revert if they do not have the item\n        removeItem(sellerTokenId, itemId);\n\n        protocolItems[itemId]++;\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(sellerTokenId));\n\n        // cannot sell two of the same item at same time\n        require(m.swapData == 0, 'S:D');\n\n        (uint256 dat, uint96 dust) = NuggftV1AgentType.newAgentType(0, address(sellerTokenId), floor, true);\n\n        s.data = dat;\n\n        emit SwapItemStart(sellerTokenId, itemId, floor - dust);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                    view\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // / @inheritdoc INuggftV1Swap\n    function valueForDelegate(address sender, uint160 tokenId)\n        external\n        view\n        override\n        returns (\n            bool canDelegate,\n            uint96 nextSwapAmount,\n            uint96 senderCurrentOffer\n        )\n    {\n        canDelegate = true;\n\n        (, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        if (m.swapData == 0) {\n            if (m.activeEpoch == tokenId) {\n                // swap is minting\n                nextSwapAmount = NuggftV1AgentType.compressEthRoundUp(minSharePrice());\n            } else {\n                // swap does not exist\n                return (false, 0, 0);\n            }\n        } else {\n            if (m.offerData.isOwner()) canDelegate = false;\n\n            senderCurrentOffer = m.offerData.eth();\n\n            nextSwapAmount = m.swapData.eth();\n\n            if (nextSwapAmount < ethPerShare()) {\n                nextSwapAmount = ethPerShare();\n            }\n        }\n\n        if (nextSwapAmount == 0) {\n            nextSwapAmount = MIN_OFFER;\n        } else {\n            nextSwapAmount = NuggftV1AgentType.addIncrement(nextSwapAmount);\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                internal\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function commit(Storage storage s, Memory memory m) internal returns (uint96 newAmount) {\n        require(m.offerData == 0 && m.swapData != 0, 'NOPE3');\n\n        require(m.swapData.isOwner(), 'NOPE4');\n\n        // forces a user not to commit on their own swap\n        // commented out as the logic is handled by S:R\n        // require(!m.offerData.isOwner()(), 'S:3');\n\n        (uint256 newSwapData, uint96 increment, uint96 dust) = updateSwapDataWithEpoch(m.swapData, m.activeEpoch + 1, m.sender, 0);\n\n        s.data = newSwapData;\n\n        s.offers[m.swapData.account()] = m.swapData.isOwner(false).epoch(m.activeEpoch + 1);\n\n        addStakedEth(increment + dust);\n\n        return newSwapData.eth();\n    }\n\n    function offer(Storage storage s, Memory memory m) internal returns (uint96 newAmount) {\n        // make sure swap is still active\n        require(m.activeEpoch <= m.swapData.epoch(), 'S:F');\n\n        if (m.swapData.account() != m.sender) s.offers[m.swapData.account()] = m.swapData;\n\n        (uint256 newSwapData, uint96 increment, uint96 dust) = updateSwapDataWithEpoch(\n            m.swapData,\n            m.swapData.epoch(),\n            m.sender,\n            m.offerData.eth()\n        );\n\n        s.data = newSwapData;\n\n        addStakedEth(increment + dust);\n\n        return newSwapData.eth();\n    }\n\n    function checkClaimerIsWinnerOrLoser(Memory memory m) internal pure returns (bool winner) {\n        require(m.offerData != 0, 'S:E');\n\n        bool isOver = m.activeEpoch > m.swapData.epoch();\n        bool isLeader = m.offerData.account() == m.swapData.account();\n        bool isOwner = m.swapData.isOwner() && m.offerData.isOwner();\n\n        return isLeader && (isOwner || isOver);\n    }\n\n    // @test  unit\n    function updateSwapDataWithEpoch(\n        uint256 prevSwapData,\n        uint32 _epoch,\n        address account,\n        uint96 currUserOffer\n    )\n        internal\n        view\n        returns (\n            uint256 res,\n            uint96 increment,\n            uint96 dust\n        )\n    {\n        uint96 baseEth = prevSwapData.eth();\n\n        currUserOffer += msg.value.safe96();\n\n        require(NuggftV1AgentType.addIncrement(baseEth) <= currUserOffer, 'S:G');\n\n        (res, dust) = NuggftV1AgentType.newAgentType(_epoch, account, currUserOffer, false);\n\n        increment = currUserOffer - baseEth;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TOKEN SWAP\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function loadTokenSwap(uint160 tokenId, address account) internal view returns (Storage storage s, Memory memory m) {\n        s = swaps[tokenId].self;\n        m = _load(s, account);\n    }\n\n    function loadItemSwap(\n        uint160 tokenId,\n        uint16 itemId,\n        address account\n    ) internal view returns (Storage storage s, Memory memory m) {\n        s = swaps[tokenId].items[itemId];\n        m = _load(s, account);\n    }\n\n    function _load(Storage storage ptr, address account) private view returns (Memory memory m) {\n        uint256 cache = ptr.data;\n        m.swapData = cache;\n        m.activeEpoch = epoch();\n        m.sender = account;\n\n        if (account == cache.account()) {\n            m.offerData = cache;\n        } else {\n            m.offerData = ptr.offers[account];\n        }\n    }\n}\n"
    },
    "src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from './SafeCastLib.sol';\n\nlibrary ShiftLib {\n    using SafeCastLib for uint256;\n\n    /// @notice creates a bit mask\n    /// @dev res = (2 ^ bits) - 1\n    /// @param bits bit size of mask\n    /// @return res the mask\n    function mask(uint8 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(shl(bits, 1), 1)\n        }\n    }\n\n    function fullsubmask(uint8 bits, uint8 pos) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << pos);\n    }\n\n    function set(\n        uint256 preStore,\n        uint8 bits,\n        uint8 pos,\n        uint256 value\n    ) internal pure returns (uint256 postStore) {\n        postStore = preStore & fullsubmask(bits, pos);\n\n        assembly {\n            value := shl(pos, value)\n        }\n\n        postStore |= value;\n    }\n\n    function get(\n        uint256 store,\n        uint8 bits,\n        uint8 pos\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := shr(pos, store)\n        }\n        value &= mask(bits);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                ARRAYS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function getArray(uint256 store, uint8 pos) internal pure returns (uint8[] memory arr) {\n        store = get(store, 64, pos);\n\n        arr = new uint8[](8);\n        for (uint256 i = 0; i < 8; i++) {\n            arr[i] = uint8(store & 0xff);\n            store >>= 8;\n        }\n    }\n\n    function setArray(\n        uint256 store,\n        uint8 pos,\n        uint8[] memory arr\n    ) internal pure returns (uint256 res) {\n        for (uint256 i = 8; i > 0; i--) {\n            res |= uint256(arr[i - 1]) << ((8 * (i - 1)));\n        }\n\n        res = set(store, 64, pos, res);\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Swap {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event DelegateMint(uint256 epoch, address account, uint96 eth);\n    event DelegateCommit(uint160 tokenId, address account, uint96 eth);\n    event DelegateOffer(uint160 tokenId, address account, uint96 eth);\n    event SwapClaim(uint160 tokenId, address account, uint32 epoch);\n    event SwapStart(uint160 tokenId, address account, uint96 eth);\n\n    event DelegateCommitItem(uint160 sellerTokenId, uint16 itemId, uint160 buyerTokenId, uint96 eth);\n    event DelegateOfferItem(uint160 sellerTokenId, uint16 itemId, uint160 buyerTokenId, uint96 eth);\n    event SwapClaimItem(uint160 sellerTokenId, uint16 itemId, uint160 buyerTokenId, uint32 epoch);\n    event SwapItemStart(uint160 sellerTokenId, uint16 itemId, uint96 eth);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function delegate(address sender, uint160 tokenId) external payable;\n\n    function delegateItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external payable;\n\n    function claim(address sender, uint160 tokenId) external;\n\n    function claimItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemid\n    ) external;\n\n    function swap(uint160 tokenId, uint96 floor) external;\n\n    function swapItem(\n        uint160 sellerTokenId,\n        uint16 itemid,\n        uint96 floor\n    ) external;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @notice calculates the minimum eth that must be sent with a delegate call\n    /// @dev returns 0 if no delegate can be made for this oken\n    /// @param tokenId -> the token to be delegated to\n    /// @param sender -> the address of the user who will be delegating\n    /// @return canDelegate -> instead of reverting this function will return false\n    /// @return nextSwapAmount -> the minimum value that must be sent with a delegate call\n    /// @return senderCurrentOffer ->\n    function valueForDelegate(address sender, uint160 tokenId)\n        external\n        view\n        returns (\n            bool canDelegate,\n            uint96 nextSwapAmount,\n            uint96 senderCurrentOffer\n        );\n}\n"
    },
    "src/core/NuggftV1Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggftV1Proof} from './NuggftV1Proof.sol';\n\nimport {INuggftV1Migrator} from '../interfaces/nuggftv1/INuggftV1Migrator.sol';\nimport {INuggftV1Stake} from '../interfaces/nuggftv1/INuggftV1Stake.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1StakeType} from '../types/NuggftV1StakeType.sol';\n\nabstract contract NuggftV1Stake is INuggftV1Stake, NuggftV1Proof {\n    using SafeCastLib for uint256;\n    using NuggftV1StakeType for uint256;\n\n    address public migrator;\n\n    uint256 internal stake;\n\n    uint96 constant PROTOCOL_FEE_BPS = 1000;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc INuggftV1Stake\n    function extractProtocolEth() external requiresTrust {\n        uint256 cache = stake;\n\n        emit ProtocolEthExtracted(cache.proto());\n\n        SafeTransferLib.safeTransferETH(msg.sender, cache.proto());\n\n        stake = cache.proto(0);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function setMigrator(address _migrator) external requiresTrust {\n        migrator = _migrator;\n\n        emit MigratorV1Updated(_migrator);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                VIEW\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc INuggftV1Stake\n    function ethPerShare() public view override returns (uint96 res) {\n        res = calculateEthPerShare(stake);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function minSharePrice() public view override returns (uint96 res) {\n        (res, , , ) = minSharePriceBreakdown(stake);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function stakedShares() public view override returns (uint64 res) {\n        res = stake.shares();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function stakedEth() public view override returns (uint96 res) {\n        res = stake.staked();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function protocolEth() public view override returns (uint96 res) {\n        res = stake.proto();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function totalSupply() public view override returns (uint256 res) {\n        res = stakedShares();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            ADD STAKE & SHARES\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice handles the adding of shares - ensures enough eth is being added\n    /// @dev this is the only way to add shares - the logic here ensures that \"ethPerShare\" can never decrease\n    function addStakedShareFromMsgValue() internal {\n        uint96 value = msg.value.safe96();\n\n        uint256 cache = stake;\n\n        (uint96 totalPrice, , uint96 protocolFee, ) = minSharePriceBreakdown(cache);\n\n        // logically unnessesary - to help front end\n        require(value >= totalPrice, 'T:1'); // \"not enough eth to create share\"\n\n        uint96 overpay = value - totalPrice;\n\n        // the rest of the value gets added to stakedEth\n        protocolFee += calculateProtocolFeeOf(overpay);\n\n        cache = cache.addShares(1);\n        cache = cache.addStaked(value - protocolFee);\n        cache = cache.addProto(protocolFee);\n\n        stake = cache;\n\n        emit StakeEth(value - protocolFee, protocolFee);\n    }\n\n    /// @notice handles isolated staking of eth\n    /// @dev supply of eth goes up while supply of shares stays constant - increasing \"minSharePrice\"\n    /// @param eth the amount of eth being staked - must be some portion of msg.value\n    function addStakedEth(uint96 eth) internal {\n        require(msg.value >= eth, 'T:2'); // \"value of tx too low\"\n\n        uint256 cache = stake;\n\n        uint96 protocolFee = calculateProtocolFeeOf(eth);\n\n        stake = cache.staked(cache.staked() + eth - protocolFee).proto(cache.proto() + protocolFee);\n\n        emit StakeEth(eth - protocolFee, protocolFee);\n    }\n\n    function calculateProtocolFeeOf(uint96 any) internal pure returns (uint96 res) {\n        res = (any * PROTOCOL_FEE_BPS) / 10000;\n    }\n\n    // @test manual\n    function minSharePriceBreakdown(uint256 cache)\n        internal\n        pure\n        returns (\n            uint96 total,\n            uint96 eps,\n            uint96 protocolFee,\n            uint96 premium\n        )\n    {\n        eps = calculateEthPerShare(cache);\n\n        protocolFee = calculateProtocolFeeOf(eps);\n\n        premium = ((eps * cache.shares()) / 10000);\n\n        total = eps + protocolFee + premium;\n    }\n\n    // @test manual\n    function calculateEthPerShare(uint256 cache) internal pure returns (uint96 res) {\n        res = cache.shares() == 0 ? 0 : cache.staked() / cache.shares();\n    }\n}\n"
    },
    "src/core/NuggftV1Proof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Proof} from '../interfaces/nuggftv1/INuggftV1Proof.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {NuggftV1Dotnugg} from './NuggftV1Dotnugg.sol';\n\nimport {NuggftV1ProofType} from '../types/NuggftV1ProofType.sol';\n\n// import {Print} from '../_test/utils/Print.sol';\n\nabstract contract NuggftV1Proof is INuggftV1Proof, NuggftV1Dotnugg {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                state\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    mapping(uint160 => uint256) proofs;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                           external functions\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Proof\n    function rotateFeature(uint160 tokenId, uint8 feature) external override {\n        require(_isOperatorForOwner(msg.sender, tokenId), 'P:A');\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.rotateDefaultandExtra(working, feature);\n\n        working = NuggftV1ProofType.clearAnchorOverridesForFeature(working, feature);\n\n        proofs[tokenId] = working;\n\n        emit RotateItem(tokenId, working, feature);\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function setOverrides(\n        uint160 tokenId,\n        uint8[] memory xs,\n        uint8[] memory ys\n    ) external override {\n        require(_isOperatorForOwner(msg.sender, tokenId), 'P:B');\n\n        require(xs.length == 8 && ys.length == 8, 'P:C');\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.setNewAnchorOverrides(working, xs, ys);\n\n        proofs[tokenId] = working;\n\n        emit SetAnchorOverrides(tokenId, working, xs, ys);\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function proofOf(uint160 tokenId) public view virtual override returns (uint256) {\n        if (proofs[tokenId] != 0) return proofs[tokenId];\n\n        (uint256 seed, uint256 epoch, uint256 proof, ) = pendingProof();\n\n        if (epoch == tokenId && seed != 0) return proof;\n        else return 0;\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function parsedProofOf(uint160 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory extraIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        )\n    {\n        proof = proofOf(tokenId);\n\n        return NuggftV1ProofType.fullProof(proof);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                             internal functions\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function exists(uint160 tokenId) internal view override returns (bool) {\n        return proofOf(tokenId) != 0;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            SWAP MANAGEMENT\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function addItem(uint160 tokenId, uint16 itemId) internal {\n        require(_isOperatorForOwner(msg.sender, tokenId), 'P:2');\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.pushToExtra(working, itemId);\n\n        proofs[tokenId] = working;\n\n        emit PushItem(tokenId, working, itemId);\n    }\n\n    function removeItem(uint160 tokenId, uint16 itemId) internal {\n        require(_isOperatorForOwner(msg.sender, tokenId), 'P:4');\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.pullFromExtra(working, itemId);\n\n        proofs[tokenId] = working;\n\n        emit PopItem(tokenId, working, itemId);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            INITIALIZATION\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function setProof(uint160 tokenId) internal {\n        require(proofs[tokenId] == 0, 'P:5');\n\n        uint256 randomEnoughSeed = uint256(keccak256(abi.encodePacked(hex'420690', tokenId, blockhash(block.number - 1))));\n\n        (uint256 res, uint8[] memory picks) = initFromSeed(randomEnoughSeed);\n\n        proofs[tokenId] = res;\n\n        emit SetProof(tokenId, res, picks);\n    }\n\n    function setProofFromEpoch(uint160 tokenId) internal {\n        require(proofs[tokenId] == 0, 'P:6');\n\n        (, uint256 epoch, uint256 res, uint8[] memory picks) = pendingProof();\n\n        require(epoch == tokenId, 'P:7');\n\n        proofs[tokenId] = res;\n\n        emit SetProof(tokenId, res, picks);\n    }\n\n    // TODO TO BE TESTED\n    function initFromSeed(uint256 seed) internal view returns (uint256 res, uint8[] memory upd) {\n        require(seed != 0, 'P:8');\n\n        uint8[] memory lengths = ShiftLib.getArray(featureLengths, 0);\n\n        upd = new uint8[](8);\n\n        uint8[] memory picks = ShiftLib.getArray(seed, 0);\n\n        upd[0] = (safeMod(picks[0], lengths[0])) + 1;\n        upd[1] = (safeMod(picks[1], lengths[1])) + 1;\n        upd[2] = (safeMod(picks[2], lengths[2])) + 1;\n\n        // Print.log(picks[3], 'picks[3]');\n\n        if (picks[3] < 60) upd[3] = (safeMod(picks[4], lengths[3])) + 1;\n        else if (picks[3] < 120) upd[4] = (safeMod(picks[4], lengths[4])) + 1;\n        else if (picks[3] < 180) upd[5] = (safeMod(picks[4], lengths[5])) + 1;\n        else if (picks[3] < 240)\n            upd[6] = (safeMod(picks[4], lengths[6])) + 1;\n            // FIXME\n        else upd[6] = (safeMod(picks[4], lengths[6])) + 1;\n\n        // Print.log(lengths, 'lengths');\n\n        res = ShiftLib.setArray(res, 0, upd);\n    }\n\n    function safeMod(uint8 value, uint8 modder) internal pure returns (uint8) {\n        require(modder != 0, 'P:9');\n        return value % modder;\n    }\n\n    function pendingProof()\n        internal\n        view\n        returns (\n            uint256 seed,\n            uint256 epoch,\n            uint256 proof,\n            uint8[] memory defaultIds\n        )\n    {\n        (seed, epoch) = calculateSeed();\n\n        (proof, defaultIds) = initFromSeed(seed);\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Proof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Proof {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  EVENTS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    event SetProof(uint160 tokenId, uint256 proof, uint8[] items);\n    event PopItem(uint160 tokenId, uint256 proof, uint16 itemId);\n    event PushItem(uint160 tokenId, uint256 proof, uint16 itemId);\n    event RotateItem(uint160 tokenId, uint256 proof, uint8 feature);\n    event SetAnchorOverrides(uint160 tokenId, uint256 proof, uint8[] xs, uint8[] ys);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                             STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function rotateFeature(uint160 tokenId, uint8 feature) external;\n\n    function setOverrides(\n        uint160 tokenId,\n        uint8[] memory xs,\n        uint8[] memory ys\n    ) external;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               VIEW FUNCTIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function proofOf(uint160 tokenId) external view returns (uint256);\n\n    function parsedProofOf(uint160 tokenId)\n        external\n        view\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory extraIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        );\n}\n"
    },
    "src/types/NuggftV1ProofType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\n/// @notice abstracts all the logic for converting the proof between a the uint256 which is stored in\n/// in state and the the 4 uint8 arrays that it consists off.\n/// @dev Explain to a developer any extra details\n/// @dev itemIds are externally 16 bits, but here there are referenced as 8 bit ids in one of 8 indexs\n/// where the id is the position the item exists in the file storage, and the index is the feature id\n/// @dev there is not check - but dotnugg v1 only allows for max 63 for size, so anchor overrides should\n/// reflect this.\n/// @dev pushing and pulling is only set up for the extra array, so the user must manage their default array\n/// by passing through the extra array - this is to reduce complexity\n/// @dev see the dotnugg specification for more clarificaiton on the values used here\n///\n///  uint256 bit allocation of proof \"state\" variable:\n/// ┌───────────┬─────────┬────────────────────────────────────┐\n/// │  0 - 63   │ 64 bits │  default item ids - 8 x 8 bits     │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 64 - 127  │ 64 bits │  extra item ids - 8 x 8 bits       │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 128 - 191 │ 64 bits │  x anchor overrides - 8 x 8 bits   │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 192 - 255 │ 64 bits │  y anchor overrides - 8 x 8 bits   │\n/// └───────────┴─────────┴────────────────────────────────────┘\n///\nlibrary NuggftV1ProofType {\n    /// @notice converts the proof state into a human readable form\n    /// @dev fully parses the proof from a uint256 to 4 uint8 arrays\n    /// @param state -> the uint256 proof state\n    /// @return proof -> the uint256 proof state\n    /// @return defaultIds -> the modifed uint256 proof state\n    /// @return extraIds -> the modifed uint256 proof state\n    /// @return xOverrides -> the modifed uint256 proof state\n    /// @return yOverrides -> the modifed uint256 proof state\n    function fullProof(uint256 state)\n        internal\n        pure\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory extraIds,\n            uint8[] memory xOverrides,\n            uint8[] memory yOverrides\n        )\n    {\n        proof = state;\n        defaultIds = ShiftLib.getArray(state, 0);\n        extraIds = ShiftLib.getArray(state, 64);\n        xOverrides = ShiftLib.getArray(state, 128);\n        yOverrides = ShiftLib.getArray(state, 192);\n    }\n\n    /// @notice sets an item to the extra array\n    /// @dev extra array must be empty at the feature positon being added to\n    /// @param state -> the uint256 proof state\n    /// @param itemId -> the itemId being added\n    /// @return res -> the modifed uint256 proof state\n    function pushToExtra(uint256 state, uint16 itemId) internal pure returns (uint256 res) {\n        uint8[] memory arr = ShiftLib.getArray(state, 64);\n\n        (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n        require(arr[feat] == 0, 'P:D');\n\n        arr[feat] = pos;\n\n        res = ShiftLib.setArray(state, 64, arr);\n    }\n\n    /// @notice removes an item from the extra array\n    /// @dev extra array must NOT be empty at the feature positon being removed\n    /// @dev the extra array must have that specific feature in that postion\n    /// @param state -> the uint256 proof state\n    /// @param itemId -> the itemId being removed\n    /// @return res -> the modifed uint256 proof state\n    function pullFromExtra(uint256 state, uint16 itemId) internal pure returns (uint256 res) {\n        uint8[] memory arr = ShiftLib.getArray(state, 64);\n\n        (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n        require(feat != 0, 'P:F');\n\n        require(arr[feat] == pos, 'P:E');\n\n        arr[feat] = 0;\n\n        res = ShiftLib.setArray(state, 64, arr);\n    }\n\n    /// @notice swaps the default feauture x with the extra feature x\n    /// @dev either default or extra feature value can be empty (0)\n    /// @param state -> the uint256 proof state\n    /// @param feature -> the feature to switch items for\n    /// @return res -> the modifed uint256 proof state\n    function rotateDefaultandExtra(uint256 state, uint8 feature) internal pure returns (uint256 res) {\n        require(feature != 0, 'P:F');\n\n        uint8[] memory def = ShiftLib.getArray(state, 0);\n        uint8[] memory ext = ShiftLib.getArray(state, 64);\n\n        uint8 tmp = ext[feature];\n        ext[feature] = def[feature];\n        def[feature] = tmp;\n\n        res = ShiftLib.setArray(state, 0, def);\n        res = ShiftLib.setArray(res, 64, ext);\n    }\n\n    /// @notice updates the x and y override arrays\n    /// @dev all must be set at once\n    /// @param state -> the uint256 proof state\n    /// @param xOverrides -> uint8 array of new x overrides\n    /// @param yOverrides -> uint8 array of new x overrides\n    /// @return res -> the modifed uint256 proof state\n    function setNewAnchorOverrides(\n        uint256 state,\n        uint8[] memory xOverrides,\n        uint8[] memory yOverrides\n    ) internal pure returns (uint256 res) {\n        res = ShiftLib.setArray(state, 128, xOverrides);\n        res = ShiftLib.setArray(res, 192, yOverrides);\n    }\n\n    /// @notice clears the anchor overrides for a specific feature\n    /// @dev this should be called each time an item is added or removed from a feature\n    /// @param state -> the uint256 proof state\n    /// @param feature -> the feature to switch items for\n    /// @return res -> the modifed uint256 proof state\n    function clearAnchorOverridesForFeature(uint256 state, uint8 feature) internal pure returns (uint256 res) {\n        uint8[] memory x = ShiftLib.getArray(state, 128);\n        uint8[] memory y = ShiftLib.getArray(state, 192);\n\n        y[feature] = 0;\n        x[feature] = 0;\n\n        res = ShiftLib.setArray(state, 128, x);\n        res = ShiftLib.setArray(res, 192, y);\n    }\n\n    /// @notice parses the external itemId into a feautre and position\n    /// @dev this follows dotnugg v1 specification\n    /// @param itemId -> the external itemId\n    /// @return feat -> the feautre of the item\n    /// @return pos -> the file storage position of the item\n    function parseItemId(uint16 itemId) internal pure returns (uint8 feat, uint8 pos) {\n        feat = uint8(itemId >> 8);\n        pos = uint8(itemId & 0xff);\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Dotnugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Implementer} from '../dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1ImplementerMetadata} from '../dotnuggv1/IDotnuggV1ImplementerMetadata.sol';\n\ninterface INuggftV1Dotnugg is IDotnuggV1Implementer, IDotnuggV1ImplementerMetadata {}\n"
    },
    "src/core/NuggftV1Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721} from '../interfaces/IERC721.sol';\n\nimport {INuggftV1Token} from '../interfaces/nuggftv1/INuggftV1Token.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {NuggftV1Epoch} from './NuggftV1Epoch.sol';\n\n///\n/// @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard\n///\nabstract contract NuggftV1Token is INuggftV1Token, NuggftV1Epoch {\n    using SafeCastLib for uint256;\n\n    uint32 constant TRUSTED_MINT_TOKENS = 500;\n    uint32 constant UNTRUSTED_MINT_TOKENS = 10000;\n\n    mapping(uint256 => address) owners;\n    // mapping(address => uint256) balances;\n    mapping(uint256 => address) approvals;\n    mapping(address => mapping(address => bool)) operatorApprovals;\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) public payable override {\n        address owner = _ownerOf(tokenId.safe160());\n\n        require(_isOperatorFor(msg.sender, owner), 'G:1');\n\n        approvals[tokenId] = to;\n\n        emit Approval(owner, to, tokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) public override {\n        // require(msg.sender != operator && operator == address(this), 'G:0');\n\n        operatorApprovals[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        return _ownerOf(tokenId.safe160());\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) external view override returns (address) {\n        return _getApproved(tokenId.safe160());\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view override returns (bool) {\n        return _isOperatorFor(operator, owner);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                DISABLED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function balanceOf(address) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public payable override {\n        revert();\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256\n    ) public payable override {\n        revert();\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public payable override {\n        revert();\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                internal\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function _mintTo(address to, uint160 tokenId) internal {\n        owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                view\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function exists(uint160 tokenId) internal view virtual returns (bool);\n\n    function _isOperatorFor(address operator, address owner) internal view returns (bool) {\n        return owner == operator || operatorApprovals[owner][operator];\n    }\n\n    function _isOperatorForOwner(address operator, uint160 tokenId) internal view returns (bool) {\n        return _isOperatorFor(operator, _ownerOf(tokenId));\n    }\n\n    function _getApproved(uint160 tokenId) internal view returns (address) {\n        require(exists(tokenId), 'T:9:1');\n        return approvals[tokenId];\n    }\n\n    function _ownerOf(uint160 tokenId) internal view returns (address owner) {\n        require(exists(tokenId), 'T:9:2');\n        owner = owners[tokenId];\n        if (owner == address(0)) return address(this);\n    }\n\n    function _isApprovedOrOwner(address spender, uint160 tokenId) internal view returns (bool) {\n        address owner = _ownerOf(tokenId);\n        return (spender == owner || _getApproved(tokenId) == spender || _isOperatorFor(owner, spender));\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRANSFER\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function checkedTransferFromSelf(address to, uint160 tokenId) internal {\n        require(_ownerOf(tokenId) == address(this), 'N:0');\n\n        owners[tokenId] = to;\n\n        emitTransferEvent(address(this), to, tokenId);\n    }\n\n    function approvedTransferToSelf(uint160 tokenId) internal {\n        require(_isOperatorForOwner(msg.sender, tokenId) && _getApproved(tokenId) == address(this), 'N:1');\n\n        delete owners[tokenId];\n\n        // Clear approvals from the previous owner\n        delete approvals[tokenId];\n\n        emitTransferEvent(msg.sender, address(this), tokenId);\n    }\n\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint160 tokenId\n    ) internal {\n        emit Transfer(from, to, tokenId);\n    }\n}\n"
    },
    "src/core/NuggftV1Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Epoch} from '../interfaces/nuggftv1/INuggftV1Epoch.sol';\n\nabstract contract NuggftV1Epoch is INuggftV1Epoch {\n    uint256 public immutable genesis;\n\n    uint32 constant INTERVAL = 69;\n    uint32 constant OFFSET = 3000;\n\n    constructor() {\n        genesis = block.number;\n        emit Genesis(block.number, INTERVAL, OFFSET);\n    }\n\n    /// @inheritdoc INuggftV1Epoch\n    function epoch() public view override returns (uint32 res) {\n        res = toEpoch(block.number);\n    }\n\n    function toStartBlock(uint32 _epoch) internal view returns (uint256 res) {\n        res = ((_epoch - OFFSET) * INTERVAL) + genesis;\n    }\n\n    function toEpoch(uint256 blocknum) internal view returns (uint32 res) {\n        res = (uint32(blocknum - genesis) / INTERVAL) + OFFSET;\n    }\n\n    function toEndBlock(uint32 _epoch) internal view returns (uint256 res) {\n        res = toStartBlock(_epoch + 1) - 1;\n    }\n\n    function activeEpoch() internal view returns (uint32 res) {\n        res = toEpoch(block.number);\n    }\n\n    /// @notice gets unique base based on given epoch and converts encoded bytes to object that can be merged\n    /// Note: by using the block hash no one knows what a nugg will look like before it's epoch.\n    /// We considered making this harder to manipulate, but we decided that if someone were able to\n    /// pull it off and make their own custom nugg, that would be really fucking cool.\n    function calculateSeed() internal view returns (uint256 res, uint32 _epoch) {\n        _epoch = epoch();\n        uint256 startblock = toStartBlock(_epoch);\n        bytes32 bhash = blockhash(startblock - 1);\n        require(bhash != 0, 'E:0');\n        res = uint256(keccak256(abi.encodePacked(bhash, _epoch, address(this))));\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Epoch {\n    /// @notice Explain to an end user what this does\n    /// @dev Explain to a developer any extra details\n    event Genesis(uint256 blocknum, uint32 interval, uint32 offset);\n\n    function epoch() external view returns (uint32 res);\n}\n"
    },
    "src/interfaces/ITrust.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITrust {\n    event TrustUpdated(address indexed user, bool trust);\n\n    function setIsTrusted(address user, bool trust) external;\n\n    function isTrusted(address user) external view returns (bool);\n}\n"
    },
    "src/_test/system/system1.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\nimport {SafeCast} from '../fixtures/NuggFather.fix.sol';\n\ncontract systemTest__one is NuggFatherFix {\n    using SafeCast for uint96;\n\n    // function setUp() public {\n    //     reset();\n    // }\n\n    // function test__system1() public {\n    //     address[] memory users = environmentForge2();\n    //     emit log_named_uint('users length', users.length);\n\n    //     emit log_named_uint('nuggft.totalEthPerShare()', nuggft.totalEthPerShare());\n    //     emit log_named_uint('nuggft.totalProtocolEth()', nuggft.totalProtocolEth());\n    //     emit log_named_uint('nuggft.totalStakedEth()', nuggft.totalStakedEth());\n    //     emit log_named_uint('nuggft.totalStakedShares()', nuggft.totalStakedShares());\n    //     emit log_named_uint('nuggft.minSharePrice()', nuggft.minSharePrice());\n\n    //     // assert(false);\n    // }\n}\n// 918280174020444\n/// simulated epoch\n\n/// full migration\n\n/// everyone loans\n\n/// everyone burns\n\n/// everyone liquidates\n\n///\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.totalEthPerShare(): 0.016383373055966815\n//   nuggft.totalProtocolEth():  7.392450086659235424\n//   nuggft.totalStakedEth():   98.300238335800890640\n//   nuggft.totalStakedShares(): 6000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.totalEthPerShare():  .029822095207758643\n//   nuggft.totalProtocolEth(): 10.420998798111959771\n//   nuggft.totalStakedEth(): 178.932571246551862590\n//   nuggft.totalStakedShares(): 6000\n"
    },
    "src/_test/reverts/swap.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\nimport {SafeCast} from '../fixtures/NuggFather.fix.sol';\n\ncontract revertTest__swap is NuggFatherFix {\n    using SafeCast for uint96;\n\n    uint32 epoch;\n\n    uint160 tokenId;\n    uint96 floor;\n    uint16 itemId;\n\n    uint96 eth;\n\n    uint160 charliesTokenId;\n\n    uint96 MIN = 10**13 * 50;\n\n    int96 MININT = int96(int256(uint256(MIN)));\n\n    function setUp() public {\n        reset();\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:0] - delegate - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_0__successAsSelf() public {\n        nuggft_call(frank, delegate(address(frank), epoch), 30 * 10**16);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_0__successAsOperator() public {\n        nuggft_call(frank, setApprovalForAll(address(dennis), true));\n\n        nuggft_call(dennis, delegate(address(frank), epoch), 30 * 10**16);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_0__failAsNotOperator() public {\n        nuggft_revertCall('S:0', dennis, delegate(address(frank), epoch), 30 * 10**16);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:1] - delegate - \"msg.value >= minimum offer\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_1__successWithExactMinOffer()\n        public\n        changeInUserBalance(frank, -1 * MININT)\n        changeInNuggftBalance(MININT)\n        changeInStaked(MININT, 1)\n    {\n        nuggft_call(frank, delegate(address(frank), epoch), MIN);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_1__successWithHigherMinOffer()\n        public\n        changeInUserBalance(frank, -1 * (MININT + 1))\n        changeInNuggftBalance(MININT + 1)\n        changeInStaked(MININT + 1, 1)\n    {\n        nuggft_call(frank, delegate(address(frank), epoch), MIN + 1);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_1__failWithOneWeiLessThanMin() public {\n        nuggft_revertCall('S:1', frank, delegate(address(frank), epoch), MIN - 1);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_1__failWithZero() public {\n        nuggft_revertCall('S:1', frank, delegate(address(frank), epoch), 0);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:3a] - delegate - \"if commiting, offerer should not be owner of swap\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_R__successWithNotOwner() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        wrap__revert__swap__S_R__successWithNotOwner();\n    }\n\n    function wrap__revert__swap__S_R__successWithNotOwner()\n        internal\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInNuggftBalance(floor.safeInt() + 1 ether)\n        changeInStaked(1 ether, 0)\n    {\n        nuggft_call(frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_R__successWithOwnerAfterSomeoneElseDelegates() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        wrap__revert__swap__S_R__successWithOwnerAfterSomeoneElseDelegates();\n    }\n\n    function wrap__revert__swap__S_R__successWithOwnerAfterSomeoneElseDelegates()\n        public\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInUserBalance(dee, -1 * (floor.safeInt() + 1 ether * 2))\n        changeInNuggftBalance(3 ether + floor.safeInt() * 2)\n        changeInStaked(3 ether, 0)\n    {\n        nuggft_call(frank, delegate(address(frank), tokenId), floor + 1 ether);\n\n        nuggft_call(dee, delegate(address(dee), tokenId), floor + 2 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_R__failWithOwnerOnCommit() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        nuggft_revertCall('S:R', dee, delegate(address(dee), tokenId), floor + 1 ether * 2);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:3b] - delegate - \"if not minting, offerer must claim previous offers for the specific token\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_R__successWithUserWithNoPrevClaim() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        wrap__revert__swap__S_R__successWithUserWithNoPrevClaim();\n    }\n\n    function wrap__revert__swap__S_R__successWithUserWithNoPrevClaim()\n        internal\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInNuggftBalance(floor.safeInt() + 1 ether)\n        changeInStaked(1 ether, 0)\n    {\n        nuggft_call(frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    // LOL - MASSIVE bug found with this test\n    function test__revert__swap__S_R__successWithPrevClaimUserAfterClaiming() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        nuggft_call(dee, claim(address(dee), tokenId));\n\n        nuggft_call(dee, delegate(address(dee), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_R__failWtihUserWithPrevClaim() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        nuggft_revertCall('S:R', dee, delegate(address(dee), tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:4] - delegate - \"if not minting, swap data must exist\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_4__failWithNoSwap() public {\n        tokenId = scenario_mac_has_claimed_a_token_dee_swapped();\n\n        nuggft_revertCall('S:4', frank, delegate(address(frank), tokenId), 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_4__failWithNonexistantToken() public {\n        nuggft_revertCall('S:4', frank, delegate(address(frank), 50000), 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_4__successWithSwap() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        nuggft_call(dee, claim(address(dee), tokenId));\n\n        nuggft_call(dee, delegate(address(dee), tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:5] - delegate - \"if commiting, msg.value must be >= total eth per share\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_5__failWithVeryHighEPS() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        nuggft_call(frank, mint(1500), 50 ether);\n\n        nuggft_revertCall('S:5', frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_5__successWithLowEPS() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        nuggft_call(frank, mint(1500), floor + .5 ether);\n\n        nuggft_call(frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:6] - delegateItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_6__successAsOwnerOfBuyerTokenId() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        nuggft_call(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_6__successAsOperator() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        nuggft_call(charlie, setApprovalForAll(address(mac), true));\n\n        nuggft_call(mac, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_6__failAsNotOperator() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        nuggft_revertCall('S:6', mac, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:7] - delegateItem - \"offerer should not be owner of swap\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_7__successWithNotOwner() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        nuggft_call(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_7__successWithSameUserDifferentToken() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        uint160 tokenId2 = scenario_dee_has_a_token_2();\n\n        nuggft_call(dee, delegateItem(tokenId2, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_7__failWithUserAndOwningToken() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        nuggft_revertCall('S:7', dee, delegateItem(tokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:8] - claim - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_8__successAsSelf() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        nuggft_call(mac, claim(address(mac), tokenId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_8__successAsOperator() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        nuggft_call(mac, setApprovalForAll(address(dennis), true));\n\n        nuggft_call(dennis, claim(address(mac), tokenId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_8__failAsNotOperator() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        nuggft_revertCall('S:8', dennis, claim(address(frank), tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:9] - claimItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_9__successAsOwnerOfBuyerTokenId() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        nuggft_call(charlie, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_9__successAsOperator() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        nuggft_call(charlie, setApprovalForAll(address(mac), true));\n\n        nuggft_call(mac, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_9__failAsNotOperator() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        nuggft_revertCall('S:9', mac, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:A] - swap - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_A__successAsSelf() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        nuggft_call(dee, swap(tokenId, 2 ether));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_A__successAsOperator() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        nuggft_call(dee, setApprovalForAll(address(dennis), true));\n\n        nuggft_call(dennis, swap(tokenId, 2 ether));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_A__failAsNotOperator() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        nuggft_revertCall('S:A', dennis, swap(tokenId, 2 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:B] - swap - \"floor >= ethPerShare\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_B__successWithEqualEPS() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        nuggft_call(dee, swap(tokenId, floor));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_B__successWithOneWeiTooHigh() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        nuggft_call(dee, swap(tokenId, floor + 1));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_B__revertWithOneWeiTooLow() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        nuggft_revertCall('S:B', dee, swap(tokenId, floor - 1));\n    }\n\n    function test__revert__swap__S_B__revertWithZero() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        nuggft_revertCall('S:B', dee, swap(tokenId, 0));\n    }\n\n    function test__revert__swap__S_B__revertWithHalfFloor() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        nuggft_revertCall('S:B', dee, swap(tokenId, floor / 2));\n    }\n\n    function test__revert__swap__S_B__successWithWayTooHigh() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        nuggft_call(dee, swap(tokenId, floor + 30 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:C] - swapItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_C__successAsOwnerOfBuyerTokenId() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        nuggft_call(dee, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    function test__revert__swap__S_C__successAsOperator() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        nuggft_call(dee, setApprovalForAll(address(dennis), true));\n\n        nuggft_call(dennis, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    function test__revert__swap__S_C__failAsNotOperator() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        nuggft_revertCall('S:C', dennis, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:D] - swapItem - \"cannot sell two of same item at same time\" @todo\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:E] - checkClaimerIsWinnerOrLoser - \"invalid offer\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_E__successPrevSwapperCanClaimAfterNewSwapHasStarted() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        // dee got the token here\n        nuggft_call(dee, claim(address(dee), tokenId));\n    }\n\n    function test__revert__swap__S_E__failNoOffer() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        nuggft_revertCall('S:E', charlie, claim(address(charlie), tokenId));\n    }\n\n    function test__revert__swap__S_E__successAsLeader() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        nuggft_call(mac, claim(address(mac), tokenId));\n    }\n\n    function test__revert__swap__S_E__successAsOwner() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        nuggft_call(dee, claim(address(dee), tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:F] - offer - \"swap must be total\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_F__successOfferInActiveSwap() public {\n        (tokenId, eth) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        // dee got the token here\n        nuggft_call(charlie, delegate(address(charlie), tokenId), eth + 1 ether);\n    }\n\n    function test__revert__swap__S_F__failOfferInOldSwap() public {\n        (tokenId, eth) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        fvm.roll(2000);\n\n        // dee got the token here\n        nuggft_revertCall('S:F', charlie, delegate(address(charlie), tokenId), eth + 1 ether);\n    }\n\n    function test__revert__swap__S_F__failOfferInFutureSwap() public {\n        // dee got the token here\n        nuggft_revertCall('S:4', charlie, delegate(address(charlie), 50000), 1 ether);\n    }\n}\n\n// @todo - make sure eth ends up where we want it\n"
    },
    "src/_test/reverts/stake.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../utils/DSTestPlus.sol';\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\n\ncontract revertTest__stake is t, NuggFatherFix {\n    uint32 epoch;\n\n    function setUp() public {\n        reset();\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n            [T:1] - addStakedShareFromMsgValue - \"value of tx too low\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // mint\n    // ────\n\n    function test__revert__stake__T_1__success() public {\n        nuggft_call(frank, mint(2099), 30 * 10**16);\n    }\n\n    function test__revert__stake__T_1__fail() public {\n        nuggft_call(frank, mint((2099)), 30 * 10**18);\n\n        nuggft_revertCall('T:1', dennis, mint(2909), 29 * 10**18);\n    }\n\n    function test__revert__stake__T_1__fail_fromZero() public {\n        nuggft_call(frank, mint((2099)), 30 * 10**18);\n\n        nuggft_revertCall('T:1', dennis, mint(2909));\n    }\n\n    // trustedMint\n    // ────\n\n    function test__revert__stake__T_1__successOnTrusted() public {\n        nuggft_call(safe, trustedMint(99, address(frank)), 30 * 10**16);\n    }\n\n    function test__revert__stake__T_1__failOnTrusted() public {\n        nuggft_call(safe, trustedMint(99, address(frank)), 30 * 10**18);\n\n        nuggft_revertCall('T:1', safe, trustedMint(9, address(dennis)), 29 * 10**18);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                         [T:2] - value of tx too low  @todo\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n             [T:3] - subStakedShare - \"user not granded permission\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // burn\n    // ─────────────\n\n    function test__revert__stake__T_3__burn__fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_revertCall('T:3', mac, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failOnNoApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_revertCall('T:3', dee, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_call(dee, approve(address(nuggft), tokenId));\n\n        nuggft_call(dee, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failOnIncorrectApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_call(dee, approve(address(mac), tokenId));\n\n        nuggft_revertCall('T:3', dee, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failOnIncorrectOperatorApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_call(dee, setApprovalForAll(address(mac), true));\n\n        nuggft_call(dee, approve(address(nuggft), tokenId));\n\n        nuggft_revertCall('T:3', dennis, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failsOnCorrectOperatorApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_call(dee, setApprovalForAll(address(mac), true));\n\n        nuggft_call(dee, approve(address(nuggft), tokenId));\n\n        nuggft_revertCall('T:3', mac, burn(tokenId));\n    }\n\n    // migrate\n    // ─────────────\n\n    function test__revert__stake__T_3__migrate__fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        scenario_migrator_set();\n\n        nuggft_revertCall('T:3', dee, migrate(tokenId));\n    }\n\n    function test__revert__stake__T_3__migrate__succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        scenario_migrator_set();\n\n        nuggft_call(dee, approve(address(nuggft), tokenId));\n\n        nuggft_call(dee, migrate(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                [T:4] - migrate - \"migrator must be set\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // migrate\n    // ────────────\n\n    function test__revert__stake__T_4_fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_revertCall('T:4', dee, migrate(tokenId));\n    }\n\n    function test__revert__stake__T_4_succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_call(dee, approve(address(nuggft), tokenId));\n\n        nuggft_call(safe, setMigrator(address(migrator)));\n\n        nuggft_call(dee, migrate(tokenId));\n    }\n\n    function test__revert__stake__T_4_succeedsWithApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        nuggft_call(dee, approve(address(nuggft), tokenId));\n\n        nuggft_call(safe, setMigrator(address(migrator)));\n\n        nuggft_call(dee, migrate(tokenId));\n    }\n\n    /// values add on top of each other\n}\n"
    },
    "src/_test/fixtures/NuggFather.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../utils/DSTestPlus.sol';\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\n\ncontract fixtureTest__NuggFatherFix is t, NuggFatherFix {\n    uint32 epoch;\n\n    function setUp() public {\n        reset();\n        epoch = nuggft.epoch();\n    }\n\n    function test_scenario_frank_has_a_token_and_spent_50_eth()\n        public\n        payable\n        changeInUserBalance(frank, -1 * 50 ether)\n        changeInNuggftBalance(50 ether)\n        changeInStaked(50 ether, 1)\n    {\n        scenario_frank_has_a_token_and_spent_50_eth();\n    }\n\n    function test_scenario_frank_has_a_loaned_token()\n        public\n        payable\n        changeInUserBalance(frank, -1 * 27.5 ether)\n        changeInNuggftBalance(27.5 ether)\n        changeInStaked(50 ether, 2)\n    {\n        scenario_frank_has_a_loaned_token();\n    }\n}\n"
    },
    "src/_test/reverts/loan.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggFatherFix} from '../fixtures/NuggFather.fix.sol';\n\ncontract revertTest__loan is NuggFatherFix {\n    uint32 epoch;\n\n    function setUp() public {\n        reset();\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:0] - loan - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__loan__L_0__successAsSelf() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        nuggft_call(frank, approve(address(nuggft), tokenId));\n\n        nuggft_call(frank, loan(tokenId));\n    }\n\n    function test__revert__loan__L_0__successAsOperator() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        nuggft_call(frank, approve(address(nuggft), tokenId));\n\n        nuggft_call(frank, setApprovalForAll(address(dennis), true));\n\n        nuggft_call(dennis, loan(tokenId));\n    }\n\n    function test__revert__loan__L_0__failAsNotOperator() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        nuggft_call(frank, approve(address(nuggft), tokenId));\n\n        nuggft_revertCall('L:0', dennis, loan(tokenId));\n    }\n\n    function test__revert__loan__N_1__failAsSelfHasNotApprovedContract() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        nuggft_revertCall('N:1', frank, loan(tokenId));\n    }\n\n    function test__revert__loan__N_1__failAsOperatorHasNotApprovedContract() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        nuggft_call(frank, setApprovalForAll(address(dennis), true));\n\n        nuggft_revertCall('N:1', dennis, loan(tokenId));\n    }\n\n    function test__revert__loan__L_0__failAsNotOperatorHasNotApprovedContract() public {\n        uint160 tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        nuggft_revertCall('L:0', dennis, loan(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:1] - payoff - \"msg.sender must be operator for unexpired loan\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__loan__L_1__successAsSelf() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, payoff(tokenId), nuggft.valueForPayoff(tokenId));\n    }\n\n    function test__revert__loan__L_1__successAsSelfExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token_that_has_expired();\n\n        nuggft_call(frank, payoff(tokenId), nuggft.valueForPayoff(tokenId));\n    }\n\n    function test__revert__loan__L_1__successAsOperator() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, setApprovalForAll(address(mac), true));\n\n        nuggft_call(mac, payoff(tokenId), nuggft.valueForPayoff(tokenId));\n    }\n\n    function test__revert__loan__L_1__successAsOperatorExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token_that_has_expired();\n\n        nuggft_call(frank, setApprovalForAll(address(mac), true));\n\n        nuggft_call(mac, payoff(tokenId), nuggft.valueForPayoff(tokenId));\n    }\n\n    function test__revert__loan__L_1__successNotOperatorExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token_that_has_expired();\n\n        nuggft_call(mac, payoff(tokenId), nuggft.valueForPayoff(tokenId));\n    }\n\n    function test__revert__loan__L_1__failAsNotOperatorNotExpired() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_revertCall('L:1', mac, payoff(tokenId), nuggft.valueForPayoff(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:2] - payoff - \"msg.value not high enough\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__loan__L_2__successPayoffExact() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, payoff(tokenId), nuggft.valueForPayoff(tokenId));\n    }\n\n    function test__revert__loan__L_2__successPayoffWeiHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, payoff(tokenId), nuggft.valueForPayoff(tokenId) + 1);\n    }\n\n    function test__revert__loan__L_2__failPayoffWeiLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_revertCall('L:2', frank, payoff(tokenId), nuggft.valueForPayoff(tokenId) - 1);\n    }\n\n    function test__revert__loan__L_2__successPayoffWayHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, payoff(tokenId), nuggft.valueForPayoff(tokenId) + 50 ether);\n    }\n\n    function test__revert__loan__L_2__failPayoffWayLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_revertCall('L:2', frank, payoff(tokenId), nuggft.valueForPayoff(tokenId) / 2);\n    }\n\n    function test__revert__loan__L_2__failPayoffZero() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_revertCall('L:2', frank, payoff(tokenId), 0);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:3] - rebalance - \"msg.value not high enough\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__loan__L_3__successRebalanceExact() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId));\n    }\n\n    function test__revert__loan__L_3__successRebalanceWeiHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) + 1);\n    }\n\n    function test__revert__loan__L_3__failRebalanceWeiLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_revertCall('L:3', frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) - 1);\n    }\n\n    function test__revert__loan__L_3__successRebalanceWayHigher() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) + 50 ether);\n    }\n\n    function test__revert__loan__L_3__failRebalanceWayLower() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_revertCall('L:3', frank, rebalance(tokenId), nuggft.valueForRebalance(tokenId) / 2);\n    }\n\n    function test__revert__loan__L_3__failRebalanceZero() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_revertCall('L:3', frank, rebalance(tokenId), 0);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [L:4] - loanInfo - \"loan exists\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__loan__L_4__failDoesNotExist() public {\n        nuggft_revertCall('L:4', frank, loanInfo(100));\n    }\n\n    function test__revert__loan__L_4__successDoesExist() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, loanInfo(tokenId));\n    }\n\n    function test__revert__loan__L_4__failDoesNotExistAfterPayoff() public {\n        uint160 tokenId = scenario_frank_has_a_loaned_token();\n\n        nuggft_call(frank, loanInfo(tokenId));\n\n        nuggft_call(frank, payoff(tokenId), nuggft.valueForPayoff(tokenId) + 1);\n\n        nuggft_revertCall('L:4', frank, loanInfo(tokenId));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}