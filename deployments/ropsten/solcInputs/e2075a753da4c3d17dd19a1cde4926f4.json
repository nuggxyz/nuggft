{
  "language": "Solidity",
  "sources": {
    "contracts/mock/MockProcessResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../src/interfaces/IResolver.sol';\nimport '../tests/Event.sol';\n\n/**\n * @title DotNugg V1 - onchain encoder/decoder for dotnugg files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract MockProcessResolver is INuggFtProcessor {\n    IPostProcessResolver public immutable override postProcessor;\n\n    IProcessResolver public immutable override processor;\n\n    IPreProcessResolver public immutable override preProcessor;\n\n    constructor() {\n        postProcessor = IPostProcessResolver(address(this));\n        preProcessor = IPreProcessResolver(address(this));\n        processor = IProcessResolver(address(this));\n    }\n\n    function preProcess(bytes memory data) public view override returns (bytes memory _res) {\n        return preProcessor.preProcess(data);\n    }\n\n    function process(\n        uint256[][] memory files,\n        bytes memory data,\n        bytes memory preProcessorData\n    ) public view override returns (uint256[] memory resp) {\n        for (uint256 i = 0; i < files.length; i++) {\n            Event.log(files[i], 'files[i]');\n        }\n        return files[0];\n    }\n\n    function postProcess(\n        uint256[] memory file,\n        bytes memory,\n        bytes memory\n    ) public pure override returns (bytes memory res) {\n        res = abi.encode(file);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override(INuggFtProcessor) returns (bool) {\n        return\n            interfaceId == type(IPostProcessResolver).interfaceId ||\n            interfaceId == type(INuggFtProcessor).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/src/interfaces/IResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\ninterface IProcessResolver is IERC165 {\n    function process(\n        uint256[][] memory files,\n        bytes memory data,\n        bytes memory preProcessData\n    ) external view returns (uint256[] memory file);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n\ninterface IPreProcessResolver is IERC165 {\n    function preProcess(bytes memory data) external view returns (bytes memory preProcessData);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n\ninterface IPostProcessResolver is IERC165 {\n    function postProcess(\n        uint256[] memory file,\n        bytes memory data,\n        bytes memory preProcessData\n    ) external view returns (bytes memory res);\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n\ninterface INuggFtProcessor is IERC165, IPostProcessResolver, IProcessResolver, IPreProcessResolver {\n    function postProcessor() external view returns (IPostProcessResolver);\n\n    function preProcessor() external view returns (IPreProcessResolver);\n\n    function processor() external view returns (IProcessResolver);\n\n    function supportsInterface(bytes4 interfaceId) external view override(IERC165, IPostProcessResolver, IProcessResolver, IPreProcessResolver) returns (bool);\n}\n"
    },
    "contracts/tests/Event.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n\n\nlibrary Event {\n    function log(uint256 val, string memory name) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2\n    ) internal view {\n\n\n\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1\n    ) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3\n    ) internal view {\n\n\n\n\n\n    }\n\n    function log(uint256[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n}\n\nlibrary Uint256 {\n    bytes16 private constant ALPHABET = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAscii(uint256 value) internal pure returns (bytes memory buffer) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return buffer;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        return string(toAscii(value));\n    }\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// library Event {\n//     function log(uint256 val, string memory name) internal view {}\n\n//     function log(\n//         uint256 val0,\n//         string memory name0,\n//         uint256 val1,\n//         string memory name1,\n//         uint256 val2,\n//         string memory name2\n//     ) internal view {}\n\n//     function log(uint256[] memory arr, string memory name) internal view {}\n// }\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/src/swap/SwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '../token/TokenLib.sol';\nimport '../proof/ProofLib.sol';\n\nimport './Swap.sol';\n\nimport './SwapLib.sol';\nimport './SwapType.sol';\n\nimport '../libraries/EpochLib.sol';\nimport '../stake/StakeLib.sol';\n\nimport '../../tests/Event.sol';\n\nlibrary SwapLib {\n    using EpochLib for uint256;\n    using ShiftLib for uint256;\n    using Address for address payable;\n    using QuadMath for uint256;\n    using SwapType for uint256;\n    using ProofLib for uint256;\n\n    using Swap for Swap.Storage;\n    using StakeLib for Token.Storage;\n    using ProofLib for Token.Storage;\n    using TokenLib for Token.Storage;\n\n    event Mint(uint256 epoch, address account, uint256 eth);\n    event Commit(uint256 tokenid, address account, uint256 eth);\n    event Offer(uint256 tokenid, address account, uint256 eth);\n    event Claim(uint256 tokenid, uint256 endingEpoch, address account);\n    event StartSwap(uint256 tokenid, address account, uint256 eth);\n\n    function delegate(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 tokenid\n    ) internal {\n        uint256 activeEpoch = genesis.activeEpoch();\n\n        (uint256 swapData, uint256 offerData) = nuggft._swaps[tokenid].self.loadStorage(msg.sender);\n\n        if (activeEpoch == tokenid && swapData == 0) {\n            mint(nuggft, genesis, tokenid);\n        } else if (offerData == 0 && swapData.isOwner()) {\n            commit(nuggft, genesis, tokenid);\n        } else {\n            offer(nuggft, genesis, tokenid);\n        }\n    }\n\n    function mint(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 tokenid\n    ) internal returns (uint256 newSwapData) {\n        Swap.Storage storage _swap = nuggft._swaps[tokenid].self;\n\n        uint256 activeEpoch = genesis.activeEpoch();\n\n        (uint256 swapData, uint256 offerData) = _swap.loadStorage(msg.sender);\n\n        // we do not need this, could take tokenid out as an argument - but do not want to give users\n        // the ability to accidently place an offer for nugg A and end up minting nugg B.\n        require(activeEpoch == tokenid, 'NS:M:0');\n\n        require(swapData == 0, 'NS:M:D');\n\n        (newSwapData, ) = uint256(0).epoch(activeEpoch).account(uint160(msg.sender)).eth(msg.value);\n\n        _swap.data = newSwapData;\n\n        nuggft.setProof(tokenid, genesis);\n\n        nuggft.addStakedSharesAndEth(1, msg.value);\n\n        emit Mint(activeEpoch, msg.sender, newSwapData.eth());\n    }\n\n    function commit(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 tokenId\n    ) internal {\n        Swap.Storage storage _swap = nuggft._swaps[tokenId].self;\n\n        // Event.log(tokenId, 'tokenId');\n\n        _commitCore(nuggft, _swap, genesis, uint160(msg.sender));\n\n        emit Commit(tokenId, msg.sender, msg.value);\n    }\n\n    function _commitCore(\n        Token.Storage storage nuggft,\n        Swap.Storage storage _swap,\n        uint256 genesis,\n        uint160 sender\n    ) internal {\n        uint256 activeEpoch = genesis.activeEpoch();\n\n        (uint256 swapData, uint256 offerData) = _swap.loadStorage(sender);\n\n        require(msg.value > 0, 'SL:COM:2');\n\n        require(offerData == 0 && swapData != 0, 'SL:HSO:0');\n\n        // Event.log(swapData, 'swapData');\n\n        require(swapData.isOwner(), 'SL:HSO:1');\n\n        uint256 _epoch = activeEpoch + 1;\n\n        // copy relevent items from swapData to newSwapData\n        (uint256 newSwapData, uint256 dust) = uint256(0).epoch(_epoch).account(sender).eth(msg.value);\n\n        require(swapData.eth().mulDiv(100, 10000) < newSwapData.eth(), 'SL:OBP:4');\n\n        _swap.offers[_epoch][swapData.account()] = swapData;\n\n        _swap.data = newSwapData;\n\n        nuggft.addStakedEth(newSwapData.eth() - swapData.eth() + dust);\n    }\n\n    function offer(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 tokenid\n    ) internal {\n        Swap.Storage storage _swap = nuggft._swaps[tokenid].self;\n\n        _offerCore(nuggft, _swap, genesis, uint160(msg.sender));\n\n        emit Offer(tokenid, msg.sender, msg.value);\n    }\n\n    function _offerCore(\n        Token.Storage storage nuggft,\n        Swap.Storage storage _swap,\n        uint256 genesis,\n        uint160 sender\n    ) internal {\n        uint256 activeEpoch = genesis.activeEpoch();\n\n        (uint256 swapData, uint256 offerData) = _swap.loadStorage(sender);\n\n        require(msg.value > 0, 'SL:OBP:2');\n\n        require(swapData != 0, 'NS:0:0');\n\n        // make sure user is not the owner of swap\n        // we do not know how much to give them when they call \"claim\" otherwise\n        require(!offerData.isOwner(), 'SL:HSO:0');\n\n        // if (swapData.epoch() == 0 && swapData.isOwner()) swapData = swapData.epoch(activeEpoch + 1);\n\n        // make sure swap is still active\n        require(activeEpoch <= swapData.epoch(), 'SL:OBP:3');\n\n        // save prev offers data\n        if (swapData.account() != sender) _swap.offers[swapData.epoch()][swapData.account()] = swapData;\n\n        // copy relevent items from swapData to newSwapData\n        (uint256 newSwapData, uint256 dust) = uint256(0).epoch(swapData.epoch()).account(sender).eth(offerData.eth() + msg.value);\n\n        require(swapData.eth().mulDiv(100, 10000) < newSwapData.eth(), 'SL:OBP:4');\n\n        _swap.data = newSwapData;\n\n        nuggft.addStakedEth(newSwapData.eth() - swapData.eth() + dust);\n    }\n\n    function claim(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 tokenid,\n        uint256 endingEpoch\n    ) internal {\n        Swap.Storage storage _swap = nuggft._swaps[tokenid].self;\n\n        uint256 activeEpoch = genesis.activeEpoch();\n\n        (uint256 swapData, uint256 offerData) = _swap.loadStorage(msg.sender, endingEpoch);\n\n        delete _swap.offers[endingEpoch][uint160(msg.sender)];\n\n        if (Swap.checkClaimer(uint160(msg.sender), swapData, offerData, activeEpoch)) {\n            delete _swap.data;\n            if (endingEpoch == swapData.epoch()) {\n                nuggft.checkedMintTo(msg.sender, tokenid);\n            } else {\n                nuggft.checkedTransferFromSelf(msg.sender, tokenid);\n            }\n        } else {\n            payable(msg.sender).sendValue(offerData.eth());\n        }\n\n        emit Claim(tokenid, endingEpoch, msg.sender);\n    }\n\n    function swap(\n        Token.Storage storage nuggft,\n        uint256 tokenid,\n        uint256 floor\n    ) internal {\n        Swap.Storage storage _swap = nuggft._swaps[tokenid].self;\n\n        (uint256 swapData, ) = _swap.loadStorage(msg.sender);\n\n        // make sure swap does not exist\n        require(swapData == 0, 'NS:SS:0');\n\n        // build starting swap data\n        (swapData, ) = swapData.account(uint160(msg.sender)).isOwner(true).eth(floor);\n\n        _swap.data = swapData;\n\n        nuggft.approvedTransferToSelf(msg.sender, tokenid);\n\n        emit StartSwap(tokenid, msg.sender, floor);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/src/token/TokenLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport './Token.sol';\n\nimport '../stake/StakeLib.sol';\n\nlibrary TokenLib {\n    using Address for address payable;\n    using Token for Token.Storage;\n    using StakeLib for Token.Storage;\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        Token.Storage storage nuggft,\n        address to,\n        uint256 tokenId\n    ) internal {\n        nuggft._tokenApprovals[tokenId] = to;\n        emit Approval(nuggft._ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function checkedTransferFromSelf(\n        Token.Storage storage nuggft,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(Token._checkOnERC721Received(address(this), to, tokenId, ''), 'ERC721: transfer caller is not owner nor approved');\n\n        nuggft._balances[address(this)] -= 1;\n        nuggft._balances[to] += 1;\n        nuggft._owners[tokenId] = to;\n\n        emit Transfer(address(this), to, tokenId);\n    }\n\n    function approvedTransferToSelf(\n        Token.Storage storage nuggft,\n        address from,\n        uint256 tokenId\n    ) internal {\n        require(\n            msg.sender == nuggft._ownerOf(tokenId) && from == msg.sender && nuggft._getApproved(tokenId) == address(this),\n            'ERC721: transfer caller is not owner nor approved'\n        );\n\n        nuggft._balances[from] -= 1;\n        nuggft._balances[address(this)] += 1;\n        nuggft._owners[tokenId] = address(this);\n\n        // Clear approvals from the previous owner\n        nuggft._tokenApprovals[tokenId] = address(0);\n        emit Approval(address(this), address(0), tokenId);\n\n        emit Transfer(from, address(this), tokenId);\n    }\n\n    function checkedMintTo(\n        Token.Storage storage nuggft,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(Token._checkOnERC721Received(address(this), to, tokenId, ''), 'ERC721: transfer caller is not owner nor approved');\n\n        nuggft._balances[to] += 1;\n        nuggft._owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function burnForStake(Token.Storage storage nuggft, uint256 tokenId) internal {\n        require(nuggft._getApproved(tokenId) == address(this), 'TL:BFS:0');\n\n        address owner = nuggft._ownerOf(tokenId);\n\n        require(owner == msg.sender, 'TL:BFS:1');\n\n        delete nuggft._tokenApprovals[tokenId];\n        emit Approval(owner, address(0), tokenId);\n\n        nuggft._balances[owner] -= 1;\n        delete nuggft._owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        uint256 amount = nuggft.getActiveEthPerShare();\n\n        nuggft.subStakedEth(amount);\n        nuggft.subStakedShares(1);\n\n        payable(owner).sendValue(nuggft.getActiveEthPerShare());\n    }\n}\n"
    },
    "contracts/src/proof/ProofLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport '../token/Token.sol';\n\nimport '../libraries/EpochLib.sol';\n\nimport './ProofType.sol';\n\nlibrary ProofLib {\n    event SetProof(uint256 tokenId, uint256[] items); // CANGE\n    event PopItem(uint256 tokenId, uint256 itemId);\n    event PushItem(uint256 tokenId, uint256 itemId);\n    event OpenSlot(uint256 tokenId);\n\n    uint256 constant ITEMID_SIZE = 12;\n\n    using ProofType for uint256;\n    using Token for Token.Storage;\n\n    function proofOf(Token.Storage storage nuggft, uint256 tokenId) internal view returns (uint256 res) {\n        res = nuggft._proofs[tokenId];\n        require(res != 0, 'PROOF:PO:0');\n    }\n\n    function hasProof(Token.Storage storage nuggft, uint256 tokenId) internal view returns (bool res) {\n        res = nuggft._proofs[tokenId] != 0;\n    }\n\n    function parseProof(Token.Storage storage nuggft, uint256 tokenId)\n        internal\n        view\n        returns (\n            uint256 proof,\n            uint256[] memory defaultIds,\n            uint256[] memory extraIds,\n            uint256[] memory overrides\n        )\n    {\n        proof = nuggft._proofOf(tokenId);\n\n        return parseProofLogic(proof);\n\n        // TODO HAVE TO IMPLEMENT OVERRIDES AND EXTRA IDS\n        // defaultIds = new uint256[](8);\n\n        // for (uint256 i = 1; i < 6; i++) {\n        //     defaultIds[i] = (proof >> (4 + (ITEMID_SIZE * 6) + ITEMID_SIZE * (i - 1)));\n        // }\n    }\n\n    function parseProofLogic(uint256 _proof)\n        internal\n        pure\n        returns (\n            uint256 proof,\n            uint256[] memory defaultIds,\n            uint256[] memory extraIds,\n            uint256[] memory overrides\n        )\n    {\n        proof = _proof;\n        defaultIds = new uint256[](_proof & ShiftLib.mask(4));\n\n        for (uint256 i = 0; i < defaultIds.length; i++) {\n            defaultIds[i] = (_proof >> (4 + i * 16)) & ShiftLib.mask(16);\n        }\n        extraIds = new uint256[](8);\n        overrides = new uint256[](8);\n    }\n\n    function pendingProof(Token.Storage storage nuggft, uint256 genesis)\n        internal\n        view\n        returns (\n            uint256 proof,\n            uint256[] memory defaultIds,\n            uint256[] memory extraIds,\n            uint256[] memory overrides\n        )\n    {\n        (uint256 seed, ) = EpochLib.calculateSeed(genesis);\n\n        uint256 lendata = nuggft._vault.lengthData;\n\n        seed = ProofType.initFromSeed(lendata, seed);\n\n        return parseProofLogic(seed);\n    }\n\n    function setProof(\n        Token.Storage storage nuggft,\n        uint256 tokenId,\n        uint256 genesis\n    ) internal {\n        require(!hasProof(nuggft, tokenId), 'IL:M:0');\n\n        (uint256 seed, uint256 epoch) = EpochLib.calculateSeed(genesis);\n\n        require(seed != 0, '721:MINT:0');\n        require(epoch == tokenId, '721:MINT:1');\n\n        uint256 lendata = nuggft._vault.lengthData;\n\n        seed = ProofType.initFromSeed(lendata, seed);\n\n        nuggft._proofs[tokenId] = seed;\n\n        (, uint256[] memory items, , ) = parseProofLogic(seed);\n\n        emit SetProof(tokenId, items);\n    }\n\n    function push(\n        Token.Storage storage nuggft,\n        uint256 tokenId,\n        uint256 itemId\n    ) internal {\n        uint256 working = proofOf(nuggft, tokenId);\n\n        require(nuggft._ownedItems[itemId] > 0, '1155:SBTF:1');\n\n        nuggft._ownedItems[itemId]--;\n\n        (working, ) = working.pushFirstEmpty(uint16(itemId));\n\n        nuggft._proofs[tokenId] = working;\n\n        emit PushItem(tokenId, itemId);\n    }\n\n    function pop(\n        Token.Storage storage nuggft,\n        uint256 tokenId,\n        uint256 itemId\n    ) internal {\n        uint256 working = proofOf(nuggft, tokenId);\n\n        require(working != 0, '1155:STF:0');\n\n        (working, , ) = working.popFirstMatch(uint16(itemId));\n\n        nuggft._proofs[tokenId] = working;\n\n        nuggft._ownedItems[itemId]++;\n\n        emit PopItem(tokenId, itemId);\n    }\n\n    function open(Token.Storage storage nuggft, uint256 tokenId) internal {\n        uint256 working = proofOf(nuggft, tokenId);\n\n        working = working.size(working.size() + 1);\n\n        nuggft._proofs[tokenId] = working;\n\n        emit OpenSlot(tokenId);\n    }\n}\n"
    },
    "contracts/src/swap/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport '../libraries/ShiftLib.sol';\nimport '../libraries/QuadMath.sol';\n\nimport './SwapType.sol';\n\nlibrary Swap {\n    using SwapType for uint256;\n\n    struct History {\n        Storage self;\n        mapping(uint256 => Storage) items;\n    }\n\n    struct Storage {\n        uint256 data;\n        mapping(uint256 => mapping(uint160 => uint256)) offers;\n    }\n\n    function loadStorage(Storage storage s, address account) internal view returns (uint256 swapData, uint256 offerData) {\n        return loadStorage(s, uint160(account));\n    }\n\n    function loadStorage(\n        Storage storage s,\n        address account,\n        uint256 epoch\n    ) internal view returns (uint256 swapData, uint256 offerData) {\n        return loadStorage(s, uint160(account), epoch);\n    }\n\n    function loadStorage(Storage storage s, uint160 account) internal view returns (uint256 swapData, uint256 offerData) {\n        swapData = s.data;\n\n        offerData = swapData == 0 || account == swapData.account() ? swapData : s.offers[swapData.epoch()][account];\n    }\n\n    function loadStorage(\n        Storage storage s,\n        uint160 account,\n        uint256 epoch\n    ) internal view returns (uint256 swapData, uint256 offerData) {\n        swapData = s.data;\n\n        swapData = swapData.epoch() == epoch ? swapData : 0;\n\n        offerData = swapData != 0 && account == swapData.account() ? swapData : s.offers[epoch][account];\n    }\n\n    function checkClaimer(\n        uint160 account,\n        uint256 swapData,\n        uint256 offerData,\n        uint256 activeEpoch\n    ) internal pure returns (bool winner) {\n        require(offerData != 0, 'SL:CC:1');\n\n        bool over = activeEpoch > swapData.epoch();\n\n        return swapData.isOwner() || (account == swapData.account() && over);\n    }\n\n    // function points(uint256 total, uint256 bps) internal pure returns (uint256 res) {\n    //     res = QuadMath.mulDiv(total, bps, 10000);\n    // }\n\n    // function pointsWith(uint256 total, uint256 bps) internal pure returns (uint256 res) {\n    //     res = points(total, bps) + total;\n    // }\n\n    // function itemTokenId(uint256 itemid, uint256 tokenid) internal pure returns (uint256 res) {\n    //     res = (tokenid << 16) | itemid;\n    // }\n\n    // function tokenIdToAddress(uint256 tokenid) internal pure returns (address res) {\n    //     res = address(uint160((0x42069 << 140) | tokenid));\n    // }\n\n    // function addressToTokenId(address addr) internal pure returns (uint256 res) {\n    //     res = uint136(uint160(addr));\n    // }\n\n    // function isTokenIdAddress(address addr) internal view returns (bool res) {\n    //     if (uint160(addr) >> 80 == 0x42069 << 60) return true;\n    // }\n}\n"
    },
    "contracts/src/swap/SwapType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nlibrary SwapType {\n\n\n    function eth(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := and(shr(160, input), 0xFFFFFFFFFFFFFF)\n            let i := and(res, 0xff)\n            res := shl(mul(4, i), shr(8, res))\n            res := mul(res, 0xE8D4A51000)\n        }\n    }\n\n    // 14 f's\n    function eth(uint256 input, uint256 update) internal pure returns (uint256 res, uint256 rem) {\n        assembly {\n            let in := update\n            update := div(update, 0xE8D4A51000)\n            for {\n            } gt(update, 0xFFFFFFFFFFFF) {\n                // 13\n            } {\n                res := add(res, 0x01)\n                update := shr(4, update)\n            }\n            update := or(shl(8, update), res)\n            let out := shl(mul(4, res), shr(8, update))\n            rem := sub(in, mul(out, 0xE8D4A51000))\n            input := and(input, 0xffffffffff00000000000000ffffffffffffffffffffffffffffffffffffffff)\n            res := or(input, shl(160, update))\n        }\n    }\n\n    // 9 f's\n    function epoch(uint256 input, uint256 update) internal pure returns (uint256 res) {\n        assert(update <= 0xFFFFFFFFF);\n        assembly {\n            res := and(input, 0xf000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            res := or(res, shl(216, update))\n        }\n    }\n\n    function epoch(uint256 input) internal pure returns (uint256 res) {\n        assembly {\n            res := and(shr(216, input), 0xFFFFFFFFF)\n        }\n    }\n\n    function account(uint256 input) internal pure returns (uint160 res) {\n        assembly {\n            res := input\n        }\n    }\n\n    function account(uint256 input, uint160 update) internal pure returns (uint256 res) {\n        assembly {\n            input := and(input, 0xffffffffffffffffffffffff0000000000000000000000000000000000000000)\n            res := or(input, update)\n        }\n    }\n\n        function isOwner(uint256 input, bool) internal pure returns (uint256 res) {\n        assembly {\n            res := or(input, shl(255, 0x1))\n        }\n    }\n\n    function isOwner(uint256 input) internal pure returns (bool res) {\n        assembly {\n            res := and(shr(255, input), 0x1)\n        }\n    }\n\n}\n"
    },
    "contracts/src/libraries/EpochLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport './ShiftLib.sol';\n\nlibrary EpochLib {\n    using ShiftLib for uint256;\n\n    /**\n     * @dev #TODO\n     * @return res\n     */\n    function activeEpoch(uint256 genesis) internal view returns (uint256 res) {\n        res = toEpoch(genesis, block.number);\n    }\n\n    /**\n     * @notice gets unique base based on given epoch and converts encoded bytes to object that can be merged\n     * Note: by using the block hash no one knows what a nugg will look like before it's epoch.\n     * We considered making this harder to manipulate, but we decided that if someone were able to\n     * pull it off and make their own custom nugg, that would be really fucking cool.\n     */\n    function calculateSeed(uint256 genesis) internal view returns (uint256 res, uint256 epoch) {\n        epoch = toEpoch(genesis, block.number);\n        uint256 startblock = toStartBlock(genesis, epoch);\n        bytes32 bhash = blockhash(startblock - 1);\n        require(bhash != 0, 'EPC:SBL');\n        res = uint256(keccak256(abi.encodePacked(bhash, epoch, address(this))));\n    }\n\n    function interval() internal pure returns (uint256 res) {\n        res = 25;\n    }\n\n    /**\n     * @dev #TODO\n     * @return res\n     */\n    function toStartBlock(uint256 genesis, uint256 epoch) internal pure returns (uint256 res) {\n        res = (epoch * interval()) + genesis;\n    }\n\n    /**\n     * @dev #TODO\n     * @return res\n     */\n    function toEndBlock(uint256 genesis, uint256 epoch) internal pure returns (uint256 res) {\n        res = toStartBlock(genesis, epoch + 1) - 1;\n    }\n\n    function toEpoch(uint256 genesis, uint256 blocknum) internal pure returns (uint256 res) {\n        res = (blocknum - genesis) / interval();\n    }\n}\n"
    },
    "contracts/src/stake/StakeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../token/Token.sol';\nimport './StakeType.sol';\n\n/**\n * @title StakeMath\n * @notice a library for performing staking operations\n * @dev #TODO\n */\nlibrary StakeLib {\n    using QuadMath for uint256;\n    using StakeType for uint256;\n\n    event StakeEth(uint256 amount);\n    event UnStakeEth(uint256 amount);\n\n    function addStakedSharesAndEth(\n        Token.Storage storage nuggft,\n        uint256 shares,\n        uint256 eth\n    ) internal {\n        require(shares < ShiftLib.mask(64) && eth < ShiftLib.mask(192), 'SL:SS:0');\n\n        (uint256 activeShare, uint256 activeEth) = nuggft._stake.getStakedSharesAndEth();\n\n        nuggft._stake = nuggft._stake.setStakedShares(activeShare + shares).setStakedEth(activeEth + eth);\n        emit StakeEth(eth);\n    }\n\n    function addStakedShares(Token.Storage storage nuggft, uint256 amount) internal {\n        require(amount < ShiftLib.mask(64), 'SL:SS:0');\n\n        uint256 activeShares = nuggft._stake.getStakedShares();\n\n        nuggft._stake = nuggft._stake.setStakedShares(activeShares + amount);\n    }\n\n    function subStakedShares(Token.Storage storage nuggft, uint256 amount) internal {\n        uint256 activeShares = nuggft._stake.getStakedShares();\n\n        require(activeShares >= amount, 'SL:SS:0');\n\n        nuggft._stake = nuggft._stake.setStakedShares(activeShares - amount);\n    }\n\n    function addStakedEth(Token.Storage storage nuggft, uint256 amount) internal {\n        require(amount < ShiftLib.mask(192), 'SL:SS:0');\n\n        uint256 activeEth = nuggft._stake.getStakedEth();\n\n        nuggft._stake = nuggft._stake.setStakedEth(activeEth + amount);\n        emit StakeEth(amount);\n    }\n\n    function subStakedEth(Token.Storage storage nuggft, uint256 amount) internal {\n        uint256 activeEth = nuggft._stake.getStakedEth();\n\n        require(activeEth >= amount, 'SL:SS:0');\n\n        nuggft._stake = nuggft._stake.setStakedEth(activeEth - amount);\n        emit UnStakeEth(amount);\n    }\n\n    function getActiveEthPerShare(Token.Storage storage nuggft) internal view returns (uint256 res) {\n        uint256 stake = nuggft._stake;\n        res = sharesToEth(1, stake.getStakedEth(), stake.getStakedShares(), false);\n    }\n\n    function getActiveStakedShares(Token.Storage storage nuggft) internal view returns (uint256 res) {\n        res = nuggft._stake.getStakedShares();\n    }\n\n    function getActiveStakedEth(Token.Storage storage nuggft) internal view returns (uint256 res) {\n        res = nuggft._stake.getStakedEth();\n    }\n\n    function sharesToEth(\n        uint256 share_amount,\n        uint256 active_eth_supply,\n        uint256 active_shares,\n        bool roundup\n    ) private pure returns (uint256 res) {\n        res = roundup ? share_amount.mulDivRoundingUp(active_eth_supply, active_shares) : share_amount.mulDiv(active_eth_supply, active_shares);\n    }\n}\n"
    },
    "contracts/src/token/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '../swap/Swap.sol';\n\nimport '../vault/Vault.sol';\n\nimport '../../tests/Event.sol';\n\nlibrary Token {\n    using Address for address;\n\n    struct Storage {\n        // Token name\n        string _name;\n        // Token symbol\n        string _symbol;\n        // Token symbol\n        uint256 _stake;\n        // Token symbol\n        Vault.Storage _vault;\n        // Token symbol\n        mapping(uint256 => uint256) _ownedItems;\n        // Mapping from token ID to owner address\n        mapping(uint256 => address) _owners;\n        // Mapping from token ID to owner address\n        mapping(uint256 => uint256) _proofs;\n        // Mapping from token ID to owner address\n        mapping(uint256 => address) _resolvers;\n        // Mapping from token ID to owner address\n        mapping(uint256 => Swap.History) _swaps;\n        // Mapping owner address to token count\n        mapping(address => uint256) _balances;\n        // Mapping from token ID to approved address\n        mapping(uint256 => address) _tokenApprovals;\n        // Mapping from owner to operator approvals\n        mapping(address => mapping(address => bool)) _operatorApprovals;\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(Storage storage s, uint256 tokenId) internal view returns (bool) {\n        return s._owners[tokenId] != address(0);\n    }\n\n    function _hasResolver(Storage storage s, uint256 tokenId) internal view returns (bool) {\n        return s._resolvers[tokenId] != address(0);\n    }\n\n    function _isApprovedForAll(\n        Storage storage s,\n        address owner,\n        address operator\n    ) internal view returns (bool) {\n        return s._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function _getApproved(Storage storage s, uint256 tokenId) internal view returns (address) {\n        require(_exists(s, tokenId), 'ERC721: approved query for nonexistent token');\n        return s._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function _ownerOf(Storage storage s, uint256 tokenId) internal view returns (address owner) {\n        owner = s._owners[tokenId];\n        require(owner != address(0), 'ERC721: owner query for nonexistent token');\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function _proofOf(Storage storage s, uint256 tokenId) internal view returns (uint256 data) {\n        data = s._proofs[tokenId];\n        Event.log(data, 'data');\n        require(data != 0, 'TOKEN:PO:0');\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function _resolverOf(Storage storage s, uint256 tokenId) internal view returns (address resolver) {\n        resolver = s._resolvers[tokenId];\n        require(resolver != address(0), 'ERC721: resolver query for nonexistent token');\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function _balanceOf(Storage storage s, address owner) internal view returns (uint256) {\n        require(owner != address(0), 'ERC721: balance query for the zero address');\n        return s._balances[owner];\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/src/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/ShiftLib.sol';\nimport '../../tests/Event.sol';\nlibrary Vault {\n    struct Storage {\n        mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) items;\n        uint256 lengthData;\n    }\n\n    function set(Storage storage s, uint256[][] memory data) internal {\n        // require(feature < 8, 'VAULT:FEAT:0');'\n\n        uint256 lengths = s.lengthData;\n\n        for (uint256 i = 0; i < data.length; i++) {\n            uint256 feature = getFeature(data[i]);\n\n            uint256 len;\n\n            (lengths, len) = incrementLengthOf(lengths, feature);\n\n            for (uint256 j = 0; j < data[i].length; j++) {\n                s.items[feature][len - 1][j] = data[i][j];\n            }\n        }\n\n        s.lengthData = lengths;\n    }\n\n    function get(\n        Storage storage s,\n        uint256 feature,\n        uint256 id\n    ) internal view returns (uint256[] memory data) {\n        uint256 zero = s.items[feature][id][0];\n\n        uint256 length = getDataLength(zero);\n        Event.log(zero, \"zero\", length, \"length\", id, \"id\");\n\n        data = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            data[i] = s.items[feature][id][i];\n        }\n    }\n\n    function getBatch(Storage storage s, uint256[] memory ids) internal view returns (uint256[][] memory data) {\n        data = new uint256[][](ids.length);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            data[i] = get(s, ids[i] >> 12, ids[i] & ShiftLib.mask(12));\n        }\n    }\n\n    function getDataLength(uint256 data) internal pure returns (uint256 res) {\n        res = (data >> 250);\n    }\n\n    function setDataLength(uint256 lengthData, uint256 feature) internal pure returns (uint256 res) {\n        res = (lengthData >> (12 * feature)) & ShiftLib.mask(12);\n    }\n\n    function getFeature(uint256[] memory data) internal pure returns (uint256 res) {\n        res = (data[data.length - 1] >> 32) & 0x7;\n    }\n\n    function getLengthOf(uint256 lengthData, uint256 feature) internal pure returns (uint256 res) {\n        res = (lengthData >> (12 * feature)) & ShiftLib.mask(12);\n    }\n\n    function incrementLengthOf(uint256 lengthData, uint256 feature) internal pure returns (uint256 res, uint256 update) {\n        update = getLengthOf(lengthData, feature) + 1;\n\n        res = lengthData & ShiftLib.fullsubmask(12, 12 * feature);\n\n        res |= (update << (12 * feature));\n    }\n}\n"
    },
    "contracts/src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary ShiftLib {\n    function submask(uint256 bits, uint256 offset) internal pure returns (uint256 res) {\n        assembly {\n            res := shl(not(sub(exp(2, bits), 1)), offset)\n        }\n    }\n\n    function fullsubmask(uint256 bits, uint256 offset) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << offset);\n    }\n\n    function mask(uint256 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(exp(2, bits), 1)\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/QuadMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title QuadMath\n * @notice a library for performing Quadruple-precision floating-point format math operations\n * @dev #TODO\n */\nlibrary QuadMath {\n    /**\n     * @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @param a The multiplicand\n     * @param b The multiplier\n     * @param denominator The divisor\n     * @return result The 256-bit result\n     * @dev Credit to Uniswap under MIT license https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol\n     */\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n\n    /**\n     * @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @param a The multiplicand\n     * @param b The multiplier\n     * @param denominator The divisor\n     * @return result The 256-bit result\n     * @dev Credit to Remco Bloemen under MIT license https:/an--2-umb.com/21/muldiv\n     */\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        // fix for negation braking change in Solidity v8 - https://ethereum.stackexchange.com/a/96646\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n\n        // this unchecked block is required for this to work with Solidity v8\n        unchecked {\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/src/stake/StakeType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport '../libraries/ShiftLib.sol';\n\nlibrary StakeType {\n    function getStakedEth(uint256 state) internal pure returns (uint256 res) {\n        res = state & ShiftLib.mask(192);\n    }\n\n    function setStakedShares(uint256 state, uint256 update) internal pure returns (uint256 res) {\n        res = state & ShiftLib.mask(192);\n        res |= (update << 192);\n    }\n\n    function setStakedEth(uint256 state, uint256 update) internal pure returns (uint256 res) {\n        res = state & (ShiftLib.mask(64) << 192);\n        res |= update;\n    }\n\n    function getStakedShares(uint256 state) internal pure returns (uint256 res) {\n        res = state >> 192;\n    }\n\n    function getStakedSharesAndEth(uint256 state) internal pure returns (uint256 shares, uint256 eth) {\n        shares = getStakedShares(state);\n        eth = getStakedEth(eth);\n    }\n}\n"
    },
    "contracts/src/proof/ProofType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport '../vault/LengthType.sol';\n\nimport '../../tests/Event.sol';\n\nlibrary ProofType {\n    using LengthType for uint256;\n\n    uint256 constant ID_SIZE = 16;\n    uint256 constant ID_FEATURE_SIZE = 4;\n    uint256 constant ID_NUMBER_SIZE = 12;\n\n    function initFromSeed(uint256 lengthData, uint256 seed) internal pure returns (uint256 res) {\n        require(seed != 0, 'seed');\n\n        uint256 pick0 = ((seed >> (4 + ID_SIZE * 0)) & ShiftLib.mask(ID_NUMBER_SIZE)) % lengthData.length(0);\n        uint256 pick1 = ((seed >> (4 + ID_SIZE * 1)) & ShiftLib.mask(ID_NUMBER_SIZE)) % lengthData.length(1);\n        uint256 pick2 = ((seed >> (4 + ID_SIZE * 2)) & ShiftLib.mask(ID_NUMBER_SIZE)) % lengthData.length(2);\n\n        uint256 pick3 = (seed >> 69) % 256;\n\n        uint256 num = (seed >> (4 + ID_SIZE * 3)) & ShiftLib.mask(ID_NUMBER_SIZE);\n\n        if (pick3 < 96) {\n            pick3 = (3 << ID_NUMBER_SIZE) | (num % (lengthData.length(3)));\n        } else if (pick3 < 192) {\n            pick3 = (4 << ID_NUMBER_SIZE) | (num % (lengthData.length(4)));\n        } else if (pick3 < 250) {\n            pick3 = (5 << ID_NUMBER_SIZE) | (num % (lengthData.length(5)));\n        } else {\n            pick3 = (6 << ID_NUMBER_SIZE) | (num % (lengthData.length(6)));\n        }\n        pick1 |= 1 << ID_NUMBER_SIZE;\n        pick2 |= 2 << ID_NUMBER_SIZE;\n\n        res = (pick3 << (3 * ID_SIZE + 4)) | (pick2 << (2 * ID_SIZE + 4)) | (pick1 << (1 * ID_SIZE + 4)) | (pick0 << 4) | 4;\n    }\n\n    function size(uint256 input, uint256 update) internal pure returns (uint256 res) {\n        require(update < ShiftLib.mask(4), 'PT:DS:0');\n        res = input & ShiftLib.fullsubmask(4, 0);\n        res |= update;\n    }\n\n    function size(uint256 input) internal pure returns (uint256 res) {\n        res = input & ShiftLib.mask(4);\n    }\n\n    function items(uint256 input) internal pure returns (uint256[] memory res) {\n        uint256 s = size(input);\n        res = new uint256[](s);\n        input >>= 4;\n        for (uint256 i = 0; i < s; i++) {\n            res[i] = input & 0xffff;\n            input >>= 16;\n        }\n    }\n\n    function pushItem(\n        uint256 input,\n        uint16 itm,\n        uint8 at\n    ) internal pure returns (uint256 res) {\n        assembly {\n            let offset := add(4, mul(16, at))\n            res := and(input, not(shl(offset, 0xffff)))\n            res := or(input, shl(offset, itm))\n        }\n    }\n\n    function popItem(uint256 input, uint8 at) internal pure returns (uint256 res, uint16 itm) {\n        assembly {\n            let offset := add(4, mul(16, at))\n            res := and(input, not(shl(offset, 0xffff)))\n            itm := shr(offset, input)\n        }\n    }\n\n    function pushFirstEmpty(uint256 input, uint16 itemId) internal pure returns (uint256 res, uint8 index) {\n        uint256[] memory _items = items(input);\n        for (uint8 i = 0; i < _items.length; i++) {\n            if (_items[i] == 0) {\n                index = i + 1;\n                break;\n            }\n        }\n\n        require(index > 0, 'SL:PFM:A');\n\n        index--;\n\n        res = pushItem(input, itemId, index);\n    }\n\n    function popFirstMatch(uint256 input, uint16 itemId)\n        internal\n        view\n        returns (\n            uint256 res,\n            uint16 popped,\n            uint8 index\n        )\n    {\n        uint256[] memory _items = items(input);\n\n        Event.log(items(input), 'items(input)');\n        for (uint8 i = 0; i < _items.length; i++) {\n            if (_items[i] == itemId) {\n                index = i + 1;\n                break;\n            }\n        }\n        Event.log(input, 'input', itemId, 'itemId', index, 'index');\n        require(index > 0, 'SL:PFM:0');\n\n        index--;\n\n        (res, popped) = popItem(input, index);\n\n        require(popped == itemId, 'SL:PFM:1');\n    }\n}\n\n// 1.5 x each feature for a coordinate (0.75 x 2)\n// 2 byte each feature for expanders coordinate (16, 16, 16, 16)\n// 1 byte each feature for expanders amount (4, 4, 4, 4)\n\n// 3 | 1/2 bytes - base ---- 8 | .5 --- 8 | .5   ---- 1 vars\n\n// 8 | 1 bytes - head\n// 8 | 1 bytes - eyes\n// 8 | 1 bytes - mouth\n// 8 | 1 bytes - back\n// 8 | 1 bytes - hair\n// 8 | 1 bytes - neck ---- 48 | 6 --- 51 | 6.5    ----- 6 vars\n\n// 8 | 1 bytes - head\n// 8 | 1 bytes - eyes\n// 8 | 1 bytes - mouth\n// 8 | 1 bytes - back\n// 8 | 1 bytes - hair\n// 8 | 1 bytes - neck ---- 48 | 6  -- 99 | 12.5 ---- 6 vars\n\n// 12 | 1.5 bytes - head coordinate\n// 12 | 1.5 bytes - eyes coordinate\n// 12 | 1.5 bytes - mouth coordinate\n// 12 | 1.5 bytes - back coordinate\n// 12 | 1.5 bytes - hair coordinate\n// 12 | 1.5 bytes - neck coordinate ---- 159-    ----- 12 vars\n\n// 3            - expander 3 feat      ------- 3 vars\n\n// 3            - expander 1 feat\n// 24 | 3 bytes - expander 1\n// 3            - expander 2 feat\n// 24 | 3 bytes - expander 2\n// 24 | 3 bytes - expander 3       - 24 vars\n"
    },
    "contracts/src/vault/LengthType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/ShiftLib.sol';\n\nlibrary LengthType {\n    function length(uint256 input, uint256 index) internal pure returns (uint256 res) {\n        res = (input >> (12 * index)) & ShiftLib.mask(12);\n    }\n\n    function length(\n        uint256 input,\n        uint256 index,\n        uint256 update\n    ) internal pure returns (uint256 res) {\n        uint256 hello = ShiftLib.fullsubmask(12, 12 * index);\n        res = input & hello;\n        res |= (update << (12 * index));\n    }\n}\n"
    },
    "contracts/src/swap/SwapItemLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '../token/TokenLib.sol';\nimport '../proof/ProofLib.sol';\n\nimport './Swap.sol';\n\nimport './SwapLib.sol';\nimport './SwapType.sol';\n\nimport '../libraries/EpochLib.sol';\n\nlibrary SwapItemLib {\n    using EpochLib for uint256;\n    using ShiftLib for uint256;\n    using Address for address payable;\n    using QuadMath for uint256;\n\n    using SwapType for uint256;\n    using Swap for Swap.Storage;\n\n    using ProofLib for uint256;\n\n    using Token for Token.Storage;\n\n    event CommitItem(uint256 sellingTokenId, uint256 itemId, uint256 buyingTokenId, uint256 eth);\n\n    event OfferItem(uint256 sellingTokenId, uint256 itemId, uint256 buyingTokenId, uint256 eth);\n\n    event ClaimItem(uint256 sellingTokenId, uint256 itemId, uint256 buyingTokenId, uint256 endingEpoch);\n\n    event SwapItem(uint256 sellingTokenId, uint256 itemId, uint256 eth);\n\n    function getSwap(\n        Token.Storage storage nuggft,\n        uint256 sellingTokenId,\n        uint256 itemId\n    ) internal returns (Swap.Storage storage) {\n        return nuggft._swaps[sellingTokenId].items[itemId];\n    }\n\n    function delegateItem(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 sellingTokenId,\n        uint256 itemId,\n        uint160 sendingTokenId\n    ) internal {\n        require(nuggft._ownerOf(sendingTokenId) == msg.sender, 'AUC:TT:3');\n\n        Swap.Storage storage _swap = nuggft._swaps[sellingTokenId].items[itemId];\n\n        (uint256 swapData, uint256 offerData) = _swap.loadStorage(sendingTokenId);\n        Event.log(sellingTokenId, 'sellingTokenId', itemId, 'itemId', sendingTokenId, 'sendingTokenId');\n\n        Event.log(swapData, 'swapData', offerData, 'offerData', genesis, 'genesis');\n\n        if (offerData == 0 && swapData.isOwner()) {\n            commitItem(nuggft, genesis, sellingTokenId, itemId, sendingTokenId);\n        } else {\n            offerItem(nuggft, genesis, sellingTokenId, itemId, sendingTokenId);\n        }\n    }\n\n    function commitItem(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 sellingTokenId,\n        uint256 itemId,\n        uint160 sendingTokenId\n    ) internal {\n        require(itemId < 0xffff, 'ML:CI:0');\n\n        require(nuggft._ownerOf(sendingTokenId) == msg.sender, 'AUC:TT:3');\n\n        Swap.Storage storage _swap = nuggft._swaps[sellingTokenId].items[itemId];\n\n        SwapLib._commitCore(nuggft, _swap, genesis, sendingTokenId);\n\n        emit CommitItem(sellingTokenId, itemId, sendingTokenId, msg.value);\n    }\n\n    function offerItem(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 sellingTokenId,\n        uint256 itemId,\n        uint160 sendingTokenId\n    ) internal {\n        require(itemId < 256, 'ML:OI:0');\n\n        require(nuggft._ownerOf(sendingTokenId) == msg.sender, 'AUC:TT:3');\n\n        Swap.Storage storage _swap = nuggft._swaps[sellingTokenId].items[itemId];\n\n        SwapLib._offerCore(nuggft, _swap, genesis, sendingTokenId);\n\n        emit OfferItem(sellingTokenId, itemId, sendingTokenId, msg.value);\n    }\n\n    function claimItem(\n        Token.Storage storage nuggft,\n        uint256 genesis,\n        uint256 sellingTokenId,\n        uint256 itemId,\n        uint256 endingEpoch,\n        uint160 buyingTokenId\n    ) internal {\n        require(nuggft._ownerOf(buyingTokenId) == msg.sender, 'AUC:TT:3');\n\n        require(itemId < 0xffff, 'ML:CI:0');\n\n        Swap.Storage storage _swap = nuggft._swaps[sellingTokenId].items[itemId];\n\n        uint256 activeEpoch = genesis.activeEpoch();\n\n        (uint256 swapData, uint256 offerData) = _swap.loadStorage(buyingTokenId, endingEpoch);\n\n        delete _swap.offers[endingEpoch][buyingTokenId];\n\n        if (Swap.checkClaimer(buyingTokenId, swapData, offerData, activeEpoch)) {\n            delete _swap.data;\n\n            ProofLib.push(nuggft, buyingTokenId, itemId);\n        } else {\n            payable(msg.sender).sendValue(offerData.eth());\n        }\n\n        emit ClaimItem(sellingTokenId, itemId, buyingTokenId, endingEpoch);\n    }\n\n    function swapItem(\n        Token.Storage storage nuggft,\n        uint256 itemId,\n        uint256 floor,\n        uint160 sellingTokenId\n    ) internal {\n        require(nuggft._ownerOf(sellingTokenId) == msg.sender, 'AUC:TT:3');\n\n        require(itemId < 0xffff, 'ML:SI:0');\n\n        Swap.Storage storage _swap = nuggft._swaps[sellingTokenId].items[itemId];\n\n        (uint256 swapData, ) = _swap.loadStorage(sellingTokenId);\n\n        // make sure swap does not exist\n        require(swapData == 0, 'NS:SS:0');\n\n        // build starting swap data\n        (swapData, ) = swapData.account(sellingTokenId).isOwner(true).eth(floor);\n\n        _swap.data = swapData;\n\n        ProofLib.pop(nuggft, sellingTokenId, itemId);\n\n        emit SwapItem(sellingTokenId, itemId, floor);\n    }\n}\n"
    },
    "contracts/src/stake/Stakeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../token/Token.sol';\nimport './StakeLib.sol';\nimport '../interfaces/INuggFT.sol';\n\nabstract contract Stakeable is IStakeable {\n    using StakeLib for Token.Storage;\n\n    // Token.Storage internal nuggft();\n    function nuggft() internal view virtual returns (Token.Storage storage);\n\n    function totalSupply() public view override returns (uint256 res) {\n        res = totalStakedShares();\n    }\n\n    function totalStakedShares() public view override returns (uint256 res) {\n        res = nuggft().getActiveStakedShares();\n    }\n\n    function totalStakedEth() public view override returns (uint256 res) {\n        res = nuggft().getActiveStakedEth();\n    }\n\n    function activeEthPerShare() public view override returns (uint256 res) {\n        res = nuggft().getActiveEthPerShare();\n    }\n}\n"
    },
    "contracts/src/interfaces/INuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\ninterface IStakeable {\n    event StakeEth(uint256 amount);\n    event UnStakeEth(uint256 amount);\n\n    function totalSupply() external view returns (uint256);\n\n    function totalStakedShares() external view returns (uint256);\n\n    function totalStakedEth() external view returns (uint256);\n\n    function activeEthPerShare() external view returns (uint256);\n}\n\ninterface ITokenable is IERC721, IERC721Metadata {\n    function proofOf(uint256 tokenId) external view returns (uint256);\n\n    function parsedProofOf(uint256 tokenId)\n        external\n        view\n        returns (\n            uint256 proof,\n            uint256[] memory defaultIds,\n            uint256[] memory extraIds,\n            uint256[] memory overrides\n        );\n\n    function resolverOf(uint256 tokenId) external view returns (address);\n}\n\ninterface ISwapable {\n    function delegate(uint256 tokenid) external payable;\n\n    function delegateItem(\n        uint256 sellerTokenId,\n        uint256 itemid,\n        uint256 buyerTokenId\n    ) external payable;\n\n    function mint(uint256 tokenid) external payable;\n\n    function commit(uint256 tokenid) external payable;\n\n    function commitItem(\n        uint256 sellerTokenId,\n        uint256 itemid,\n        uint256 buyerTokenId\n    ) external payable;\n\n    function offer(uint256 tokenid) external payable;\n\n    function offerItem(\n        uint256 sellerTokenId,\n        uint256 itemid,\n        uint256 buyerTokenId\n    ) external payable;\n\n    function claim(uint256 tokenid, uint256 endingEpoch) external;\n\n    function claimItem(\n        uint256 sellerTokenId,\n        uint256 itemid,\n        uint256 buyerTokenId,\n        uint256 endingEpoch\n    ) external;\n\n    function swap(uint256 tokenid, uint256 floor) external;\n\n    function swapItem(\n        uint256 tokenid,\n        uint256 floor,\n        uint256 itemid\n    ) external;\n\n    function getOfferByAccount(\n        uint256 tokenid,\n        uint256 index,\n        address account\n    ) external view returns (uint256 eth);\n\n    function getActiveSwap(uint256 tokenid)\n        external\n        view\n        returns (\n            address leader,\n            uint256 eth,\n            uint256 _epoch,\n            bool isOwner\n        );\n\n    function genesis() external view returns (uint256 res);\n\n    function epoch() external view returns (uint256 res);\n}\n\ninterface INuggFT is ISwapable, ITokenable {\n    event PreMint(uint256 tokenId, uint256[] items);\n\n    event PopItem(uint256 tokenId, uint256 itemId);\n\n    event PushItem(uint256 tokenId, uint256 itemId);\n\n    event Mint(uint256 epoch, address account, uint256 eth);\n\n    event Commit(uint256 tokenid, address account, uint256 eth);\n\n    event Offer(uint256 tokenid, address account, uint256 eth);\n\n    event Claim(uint256 tokenid, uint256 endingEpoch, address account);\n\n    event Swap(uint256 tokenid, address account, uint256 eth);\n\n    event CommitItem(uint256 sellingTokenId, uint256 itemId, uint256 buyingTokenId, uint256 eth);\n\n    event OfferItem(uint256 sellingTokenId, uint256 itemId, uint256 buyingTokenId, uint256 eth);\n\n    event ClaimItem(uint256 sellingTokenId, uint256 itemId, uint256 buyingTokenId, uint256 endingEpoch);\n\n    event SwapItem(uint256 sellingTokenId, uint256 itemId, uint256 eth);\n\n    event OpenSlot(uint256 tokenId);\n\n    event Genesis();\n\n    function defaultResolver() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/src/swap/Swapable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../token/Token.sol';\nimport './Swap.sol';\nimport './SwapLib.sol';\nimport './SwapItemLib.sol';\n\nimport '../interfaces/INuggFT.sol';\n\nabstract contract Swapable is ISwapable {\n    function genesis() public view virtual override returns (uint256);\n\n    function nuggft() internal view virtual returns (Token.Storage storage);\n\n    using SwapType for uint256;\n    using EpochLib for uint256;\n\n    using Swap for Swap.Storage;\n\n    using SwapLib for Token.Storage;\n    using SwapItemLib for Token.Storage;\n\n    constructor() {}\n\n    function getActiveSwap(uint256 tokenid)\n        external\n        view\n        override\n        returns (\n            address leader,\n            uint256 amount,\n            uint256 _epoch,\n            bool isOwner\n        )\n    {\n        (uint256 swapData, ) = nuggft()._swaps[tokenid].self.loadStorage(address(0));\n        require(swapData != 0, 'NS:GS:0');\n        leader = address(swapData.account());\n        amount = swapData.eth();\n        _epoch = swapData.epoch();\n        isOwner = swapData.isOwner();\n    }\n\n    function getOfferByAccount(\n        uint256 tokenid,\n        uint256 index,\n        address account\n    ) external view override returns (uint256 amount) {\n        (, uint256 offerData) = nuggft()._swaps[tokenid].self.loadStorage(account, index);\n        require(offerData != 0, 'NS:GS:0');\n        amount = offerData.eth();\n    }\n\n    function epoch() external view override returns (uint256 res) {\n        res = genesis().activeEpoch();\n    }\n\n    function delegate(uint256 tokenid) external payable override {\n        nuggft().delegate(genesis(), tokenid);\n    }\n\n    function mint(uint256 tokenid) external payable override {\n        nuggft().mint(genesis(), tokenid);\n    }\n\n    function delegateItem(\n        uint256 sellingTokenId,\n        uint256 itemid,\n        uint256 buyingTokenId\n    ) external payable override {\n        nuggft().delegateItem(genesis(), sellingTokenId, itemid, uint160(buyingTokenId));\n    }\n\n    function commit(uint256 tokenid) external payable override {\n        nuggft().commit(genesis(), tokenid);\n    }\n\n    function commitItem(\n        uint256 sellingTokenId,\n        uint256 itemid,\n        uint256 buyingTokenId\n    ) external payable override {\n        nuggft().commitItem(genesis(), sellingTokenId, itemid, uint160(buyingTokenId));\n    }\n\n    function offer(uint256 tokenid) external payable override {\n        nuggft().offer(genesis(), tokenid);\n    }\n\n    function offerItem(\n        uint256 sellingTokenId,\n        uint256 itemid,\n        uint256 buyingTokenId\n    ) external payable override {\n        nuggft().offerItem(genesis(), sellingTokenId, itemid, uint160(buyingTokenId));\n    }\n\n    function claim(uint256 tokenid, uint256 endingEpoch) external override {\n        nuggft().claim(genesis(), tokenid, endingEpoch);\n    }\n\n    function claimItem(\n        uint256 sellingTokenId,\n        uint256 itemid,\n        uint256 buyingTokenId,\n        uint256 endingEpoch\n    ) external override {\n        nuggft().claimItem(genesis(), sellingTokenId, itemid, endingEpoch, uint160(buyingTokenId));\n    }\n\n    function swap(uint256 tokenid, uint256 floor) external override {\n        nuggft().swap(tokenid, floor);\n    }\n\n    function swapItem(\n        uint256 sellingTokenId,\n        uint256 itemid,\n        uint256 floor\n    ) external override {\n        nuggft().swapItem(itemid, floor, uint160(sellingTokenId));\n    }\n}\n"
    },
    "contracts/src/token/Tokenable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\n\nimport '../interfaces/INuggFT.sol';\n\nimport './Token.sol';\nimport './TokenLib.sol';\n\nimport '../proof/ProofLib.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract Tokenable is ITokenable, ERC165 {\n    using Address for address;\n    using Token for Token.Storage;\n    using EpochLib for uint256;\n    using TokenLib for Token.Storage;\n\n    // Token.Storage internal nuggft();\n    function nuggft() internal view virtual returns (Token.Storage storage);\n\n    function genesis() public view virtual returns (uint256);\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        nuggft()._name = name_;\n        nuggft()._symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-_}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        return nuggft()._balanceOf(owner);\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return nuggft()._ownerOf(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-_}.\n     */\n    function proofOf(uint256 tokenId) public view virtual override returns (uint256) {\n        if (tokenId == genesis().activeEpoch()) {\n            (uint256 p, , , ) = ProofLib.pendingProof(nuggft(), genesis());\n            return p;\n        }\n\n        return nuggft()._proofOf(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-_}.\n     */\n    function parsedProofOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 proof,\n            uint256[] memory defaultIds,\n            uint256[] memory extraIds,\n            uint256[] memory overrides\n        )\n    {\n        return ProofLib.parseProof(nuggft(), tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-_}.\n     */\n    function resolverOf(uint256 tokenId) public view virtual override returns (address) {\n        return nuggft()._resolverOf(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return nuggft()._name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return nuggft()._symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}. MODIFICATION 0\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory);\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = nuggft()._ownerOf(tokenId);\n        require(to != owner, 'ERC721: approval to current owner');\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), 'ERC721: approve caller is not owner nor approved for all');\n\n        nuggft()._approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        return nuggft()._getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != msg.sender, 'ERC721: approve to caller');\n\n        nuggft()._operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return nuggft()._isApprovedForAll(owner, operator);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function burn(uint256 tokenId) external virtual {\n        nuggft().burnForStake(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        // //solhint-disable-next-line max-line-length\n        // require(_isApprovedOrOwner(msg.sender, tokenId), 'ERC721: transfer caller is not owner nor approved');\n        // _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        // require(_isApprovedOrOwner(msg.sender, tokenId), 'ERC721: transfer caller is not owner nor approved');\n        // _safeTransfer(from, to, tokenId, _data);\n    }\n\n    // /**\n    //  * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n    //  * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n    //  *\n    //  * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n    //  *\n    //  * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n    //  * implement alternative mechanisms to perform token transfer, such as signature-based.\n    //  *\n    //  * Requirements:\n    //  *\n    //  * - `from` cannot be the zero address.\n    //  * - `to` cannot be the zero address.\n    //  * - `tokenId` token must exist and be owned by `from`.\n    //  * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    //  *\n    //  * Emits a {Transfer} event.\n    //  */\n    // function _safeTransfer(\n    //     address from,\n    //     address to,\n    //     uint256 tokenId,\n    //     bytes memory _data\n    // ) internal virtual {\n    //     _transfer(from, to, tokenId);\n    //     require(Token._checkOnERC721Received(from, to, tokenId, _data), 'ERC721: transfer to non ERC721Receiver implementer');\n    // }\n\n    // /**\n    //  * @dev Returns whether `tokenId` exists.\n    //  *\n    //  * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n    //  *\n    //  * Tokens start existing when they are minted (`_mint`),\n    //  * and stop existing when they are burned (`_burn`).\n    //  */\n    // function _exists(uint256 tokenId) internal view virtual returns (bool) {\n    //     return nuggft()._exists(tokenId);\n    // }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(nuggft()._exists(tokenId), 'ERC721: operator query for nonexistent token');\n        address owner = nuggft()._ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    // /**\n    //  * @dev Safely mints `tokenId` and transfers it to `to`.\n    //  *\n    //  * Requirements:\n    //  *\n    //  * - `tokenId` must not exist.\n    //  * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    //  *\n    //  * Emits a {Transfer} event.\n    //  */\n    // function _safeMint(address to, uint256 tokenId) internal virtual {\n    //     _safeMint(to, tokenId, '');\n    // }\n\n    // /**\n    //  * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n    //  * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n    //  */\n    // function _safeMint(\n    //     address to,\n    //     uint256 tokenId,\n    //     bytes memory _data\n    // ) internal virtual {\n    //     _mint(to, tokenId);\n    //     require(Token._checkOnERC721Received(address(0), to, tokenId, _data), 'ERC721: transfer to non ERC721Receiver implementer');\n    // }\n\n    // /**\n    //  * @dev Mints `tokenId` and transfers it to `to`.\n    //  *\n    //  * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n    //  *\n    //  * Requirements:\n    //  *\n    //  * - `tokenId` must not exist.\n    //  * - `to` cannot be the zero address.\n    //  *\n    //  * Emits a {Transfer} event.\n    //  */\n    // function _mint(address to, uint256 tokenId) internal virtual {\n    //     require(to != address(0), 'ERC721: mint to the zero address');\n    //     require(!_exists(tokenId), 'ERC721: token already minted');\n\n    //     _beforeTokenTransfer(address(0), to, tokenId);\n\n    //     nuggft()._balances[to] += 1;\n    //     nuggft()._owners[tokenId] = to;\n\n    //     emit Transfer(address(0), to, tokenId);\n    // }\n\n    // /**\n    //  * @dev Transfers `tokenId` from `from` to `to`.\n    //  *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n    //  *\n    //  * Requirements:\n    //  *\n    //  * - `to` cannot be the zero address.\n    //  * - `tokenId` token must be owned by `from`.\n    //  *\n    //  * Emits a {Transfer} event.\n    //  */\n    // function _transfer(\n    //     address from,\n    //     address to,\n    //     uint256 tokenId\n    // ) internal virtual {\n    //     require(nuggft()._ownerOf(tokenId) == from, 'ERC721: transfer of token that is not own');\n    //     require(to != address(0), 'ERC721: transfer to the zero address');\n\n    //     _beforeTokenTransfer(from, to, tokenId);\n\n    //     // Clear approvals from the previous owner\n    //     _approve(address(0), tokenId);\n\n    //     nuggft()._balances[from] -= 1;\n    //     nuggft()._balances[to] += 1;\n    //     nuggft()._owners[tokenId] = to;\n\n    //     emit Transfer(from, to, tokenId);\n    // }\n\n    // /**\n    //  * @dev Hook that is called before any token transfer. This includes minting\n    //  * and burning.\n    //  *\n    //  * Calling conditions:\n    //  *\n    //  * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n    //  * transferred to `to`.\n    //  * - When `from` is zero, `tokenId` will be minted for `to`.\n    //  * - When `to` is zero, ``from``'s `tokenId` will be burned.\n    //  * - `from` and `to` are never both zero.\n    //  *\n    //  * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n    //  */\n    // function _beforeTokenTransfer(\n    //     address from,\n    //     address to,\n    //     uint256 tokenId\n    // ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/src/NuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './interfaces/INuggFT.sol';\nimport './interfaces/IResolver.sol';\n\nimport './token/Token.sol';\nimport './token/Tokenable.sol';\nimport './swap/Swapable.sol';\nimport './stake/Stakeable.sol';\nimport './swap/Swap.sol';\n\ncontract NuggFT is INuggFT, Tokenable, Swapable, Stakeable {\n    using EpochLib for uint256;\n    using Vault for Vault.Storage;\n    using Token for Token.Storage;\n    using TokenLib for Token.Storage;\n\n    address public immutable override defaultResolver;\n\n    uint256 internal immutable _genesis;\n\n    Token.Storage internal _nuggft;\n\n    constructor(address _defaultResolver) Tokenable('NUGGFT', 'Nugg Fungible Token') {\n        defaultResolver = _defaultResolver;\n\n        _genesis = block.number;\n\n        emit Genesis();\n    }\n\n    function nuggft() internal view override(Swapable, Tokenable, Stakeable) returns (Token.Storage storage) {\n        return _nuggft;\n    }\n\n    function genesis() public view override(Swapable, ISwapable, Tokenable) returns (uint256) {\n        return _genesis;\n    }\n\n    function addToVault(uint256[][] calldata data) external {\n        _nuggft._vault.set(data);\n    }\n\n    function rawProcessURI(uint256 tokenId) public view returns (uint256[] memory res) {\n        require(_nuggft._exists(tokenId) || tokenId == _genesis.activeEpoch(), 'NFT:NTM:0');\n\n        (, uint256[] memory ids, , uint256[] memory overrides) = _nuggft._exists(tokenId) ? parsedProofOf(tokenId) : ProofLib.pendingProof(_nuggft, _genesis);\n\n        bytes memory data = abi.encode(tokenId, ids, overrides, address(this));\n\n        uint256[][] memory files = _nuggft._vault.getBatch(ids);\n\n        res = IProcessResolver(defaultResolver).process(files, data, '');\n    }\n\n    function tokenURI(uint256 tokenId) public view override(IERC721Metadata, Tokenable) returns (string memory res) {\n        res = string(tokenURI(tokenId, _nuggft._hasResolver(tokenId) ? _nuggft._resolverOf(tokenId) : defaultResolver));\n    }\n\n    function tokenURI(uint256 tokenId, address resolver) public view returns (bytes memory res) {\n        require(_nuggft._exists(tokenId) || tokenId == _genesis.activeEpoch(), 'NFT:NTM:0');\n\n        (, uint256[] memory ids, , uint256[] memory overrides) = _nuggft._exists(tokenId) ? parsedProofOf(tokenId) : ProofLib.pendingProof(_nuggft, _genesis);\n\n        uint256[][] memory files = _nuggft._vault.getBatch(ids);\n\n        bytes memory data = abi.encode(tokenId, ids, overrides, address(this));\n\n        bytes memory customData = IPreProcessResolver(resolver).preProcess(data);\n\n        uint256[] memory processedFile = IProcessResolver(resolver).process(files, data, customData);\n\n        return IPostProcessResolver(resolver).postProcess(processedFile, data, customData);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}