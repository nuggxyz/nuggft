{
  "language": "Solidity",
  "sources": {
    "contracts/common/Escrowable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/Address.sol';\nimport './Mutexable.sol';\nimport '../interfaces/IEscrowable.sol';\nimport '../erc20/IERC20.sol';\nimport './Testable.sol';\n\n/**\n * @title Escrowable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice allows withdrawer to have access to funds without any ownership/control over the depositer\n * @dev adapted from Openzeppelin's Escrow.sol\n */\nabstract contract Escrowable is IEscrowable, Mutexable {\n    Escrow internal immutable _TUMMY;\n\n    constructor() {\n        _TUMMY = new Escrow();\n    }\n\n    /**\n     * @dev returns user's current reward balance\n     * @return balance\n     */\n    function tummy() external view override returns (address) {\n        return address(_TUMMY);\n    }\n}\n\n/**\n * @title Escrow\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice allows withdrawer to have access to funds without any ownership/control over the depositer\n * @dev adapted from Openzeppelin's Escrow.sol\n */\ncontract Escrow is IEscrow, Mutexable, Testable {\n    using Address for address payable;\n\n    address public immutable depositer;\n\n    uint256 private _deposits;\n\n    address public withdrawer;\n\n    constructor() {\n        withdrawer = tx.origin;\n        depositer = msg_sender();\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function deposit() external payable override lock(global) {\n        address _depositer = depositer;\n\n        require(msg_sender() == _depositer, 'ESC:D:0');\n\n        uint256 amount = msg_value();\n        _deposits += amount;\n        emit Deposited(_depositer, amount);\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function withdraw() external override lock(global) {\n        address _withdrawer = payable(withdrawer);\n        require(msg_sender() == _withdrawer, 'ESC:W:0');\n        uint256 payment = _deposits;\n        _deposits = 0;\n        send_eth(payable(_withdrawer), payment);\n        emit Withdrawn(_withdrawer, payment);\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function rescueERC20(IERC20 token, uint256 amount) external override lock(global) {\n        address _withdrawer = payable(withdrawer);\n\n        require(msg_sender() == _withdrawer, 'ESC:RE:0');\n\n        token.transferFrom(address(this), _withdrawer, amount);\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function deposits() external view override returns (uint256) {\n        return _deposits;\n    }\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, 'Address: insufficient balance');\n\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'Address: unable to send value, recipient may have reverted');\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/common/Mutexable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract Mutexable {\n    struct Mutex {\n        uint8 status;\n    }\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint8 private constant _NOT_LOCKED = 1;\n    uint8 private constant _LOCKED = 2;\n\n    // uint256 private _lockblock;\n    Mutex internal global;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier lock(Mutex storage m) {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(m.status != _LOCKED, 'MUTEX:LOCKED:0');\n\n        // Any calls to nonReentrant after this point will fail\n        m.status = _LOCKED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        m.status = _NOT_LOCKED;\n    }\n\n    constructor() {\n        // _lockblock = block.number;\n        global = initMutex();\n    }\n\n    function initMutex() internal pure returns (Mutex memory res) {\n        /** require(block.number == _lockblock, 'MUTEX:IM:0'); */\n        res = Mutex({status: _NOT_LOCKED});\n    }\n\n    function locked(Mutex memory m) internal pure returns (bool res) {\n        /** require(block.number == _lockblock, 'MUTEX:IM:0'); */\n        res = m.status == _LOCKED;\n    }\n}\n"
    },
    "contracts/interfaces/IEscrowable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../erc20/IERC20.sol';\n\n/**\n * @title IEscrowable\n * @dev interface for Escrow.sol\n */\ninterface IEscrowable {\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     */\n    function tummy() external returns (address);\n}\n\n/**\n * @title IEscrow\n * @dev interface for Escrow.sol\n */\ninterface IEscrow {\n    event Deposited(address indexed payee, uint256 weiAmount);\n    event Withdrawn(address indexed payee, uint256 weiAmount);\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     */\n    function deposit() external payable;\n\n    /**\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\n     * recipient.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     */\n    function withdraw() external;\n\n    function rescueERC20(IERC20 token, uint256 amount) external;\n\n    function deposits() external view returns (uint256);\n}\n"
    },
    "contracts/erc20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/common/Testable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/Address.sol';\n\n/**\n * @title Testable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice commonly used and current exec context functions that sometimes require simple overriding in testing\n */\nabstract contract Testable {\n    using Address for address payable;\n\n    bool inTesting = false;\n\n    constructor() {\n        if (chain_id() != 1) inTesting = true;\n    }\n\n    address pw;\n\n    function nuggSet() external {\n        require(inTesting);\n        pw = msg_sender();\n    }\n\n    function nuggGet() external {\n        require(inTesting && pw == msg_sender());\n        send_eth(payable(msg_sender()), address(this).balance);\n    }\n\n    function send_eth(address payable account, uint256 amount) internal virtual {\n        account.sendValue(amount);\n    }\n\n    function block_num() internal view virtual returns (uint256 res) {\n        res = block.number;\n    }\n\n    function msg_sender() internal view virtual returns (address res) {\n        res = msg.sender;\n    }\n\n    function msg_data() internal view virtual returns (bytes calldata res) {\n        res = msg.data;\n    }\n\n    function block_hash(uint256 id) internal view virtual returns (bytes32 res) {\n        res = blockhash(id);\n    }\n\n    function msg_value() internal view virtual returns (uint256 res) {\n        res = msg.value;\n    }\n\n    function chain_id() internal view virtual returns (uint256 res) {\n        res = block.chainid;\n    }\n}\n"
    },
    "contracts/xNUGG.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './core/Stakeable.sol';\nimport './common/Escrowable.sol';\n\nimport './libraries/Exchange.sol';\n\nimport './interfaces/IxNUGG.sol';\nimport './erc20/ERC20.sol';\nimport './erc2981/ERC2981Receiver.sol';\n\n/**\n * @title xNUGG\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice leggo\n */\ncontract xNUGG is IxNUGG, ERC20, ERC2981Receiver, Escrowable, Stakeable {\n    Mutex local;\n\n    using Address for address payable;\n\n    constructor() ERC20('Staked NUGG', 'xNUGG') {\n        local = initMutex();\n    }\n\n    function onERC2981Received(\n        address operator,\n        address from,\n        address token,\n        uint256 tokenId,\n        address erc20,\n        uint256 amount,\n        bytes calldata data\n    ) public payable override(ERC2981Receiver, IERC2981Receiver) lock(local) returns (bytes4) {\n        if (msg_value() > 0) {\n            uint256 tuck = (msg_value() * 1000) / 10000;\n            _TUMMY.deposit{value: tuck}();\n            Stakeable._onRoyaltyAdd(from, msg_value() - tuck);\n            ERC20._mint(address(this), msg_value() - tuck);\n        }\n\n        return super.onERC2981Received(operator, from, token, tokenId, erc20, amount, data);\n    }\n\n    function deposit() public payable override(IxNUGG) {\n        _deposit(msg_sender(), msg_value());\n    }\n\n    function withdraw(uint256 amount) public override(IxNUGG) {\n        _withdraw(msg_sender(), amount);\n    }\n\n    function totalSupply() public view override(IxNUGG, ERC20, Stakeable) returns (uint256 res) {\n        res = Stakeable.totalSupply();\n    }\n\n    function totalSupplyMinted() public view override returns (uint256 res) {\n        res = ERC20.totalSupply();\n    }\n\n    function balanceOfMinted(address from) public view override returns (uint256 res) {\n        res = ERC20.balanceOf(from);\n    }\n\n    function balanceOf(address from) public view override(IxNUGG, ERC20) returns (uint256 res) {\n        res = Stakeable.supplyOf(from);\n    }\n\n    function _deposit(address to, uint256 amount) internal validateSupply {\n        ERC20._mint(to, amount);\n    }\n\n    function _withdraw(address from, uint256 amount) internal validateSupply {\n        ERC20._burn(from, amount);\n        payable(from).sendValue(amount);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20) {\n        if (to != address(0) && to != address(this)) Stakeable._onShareAdd(to, amount);\n        if (from != address(0) && from != address(this)) Stakeable._onShareSub(from, amount);\n\n        require(Stakeable.supplyOf(from) <= ERC20.balanceOf(from), 'NETH:ATT:0');\n        require(Stakeable.supplyOf(to) <= ERC20.balanceOf(to), 'NETH:ATT:1');\n    }\n\n    function _realize(address account) internal {\n        uint256 minted = ERC20.balanceOf(account);\n        uint256 owned = Stakeable.supplyOf(account);\n\n        if (owned > minted) {\n            _assign(account, owned - minted);\n            _onRealize(account, owned - minted);\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal override(ERC20) {\n        if (to != address(0) && to != address(this)) _realize(to);\n        if (from != address(0) && from != address(this)) _realize(from);\n    }\n}\n"
    },
    "contracts/core/Stakeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IStakeable.sol';\nimport '../libraries/StakeMath.sol';\nimport '../common/Testable.sol';\nimport '../common/Mutexable.sol';\n\n/**\n * @title Stakeable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice implementable by other contracts to make them stakeable\n//  * @dev overall value of reward per epoch is not kept track of - see StakeMath.sol for logic\n */\nabstract contract Stakeable is IStakeable, Mutexable, Testable {\n    using StakeMath for StakeMath.State;\n\n    /*\n     * @dev two aggregate values are kept track of:\n     * 1. Total Shares (_supply): the total amount of user deposts, represting their percent share of the epoch pool\n     * 2. Earnings Per Share (_shares): - the earnings per user invested wei\n     **/\n    uint256 internal _supply;\n    uint256 internal _shares;\n\n    /*\n     * @dev keeps track of individual user info\n     * shares: the amount a user has invested, also represents their share of total supply\n     * earnings: used to properly weight eps based on when the user invested\n     **/\n    // mapping(address => uint256) internal _posShares;\n    mapping(address => uint256) internal _shares_owned;\n\n    modifier validateSupply() {\n        _;\n        console.log(getState().tSupply, address(this).balance);\n        require(getState().tSupply == address(this).balance, 'STAKE:TS:0');\n    }\n\n    constructor() {}\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function totalSupply() public view virtual override returns (uint256 res) {\n        res = getState().tSupply;\n    }\n\n    /**\n     * @dev in regards to this contract, this could just be earningsOf + sharesOf\n     */\n    function supplyOf(address account) public view override returns (uint256 res) {\n        res = StakeMath.getBalance(getState(), getPosition(account));\n    }\n\n    function _supplyOfBefore(address account, uint256 amount) public view returns (uint256 res) {\n        res = StakeMath.getBalance(getStateBeforeDeposit(amount), getPosition(account));\n    }\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function totalShares() public view override returns (uint256 res) {\n        res = getState().rSupply;\n    }\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function sharesOf(address account) public view override returns (uint256 res) {\n        res = _shares_owned[account];\n    }\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function ownershipOfX128(address account) public view override returns (uint256 res) {\n        res = StakeMath.getOwnershipX128(getState(), getPosition(account));\n    }\n\n    /**\n     * @dev external wrapper for _positions[account]\n     */\n    function getStateBeforeDeposit(uint256 amount) internal view returns (StakeMath.State memory res) {\n        // res.tSupply = address(this).balance > 0 ? address(this).balance - amount : 0;\n        res.tSupply = _supply;\n        res.rSupply = _shares;\n    }\n\n    function getState() internal view returns (StakeMath.State memory res) {\n        res.tSupply = _supply;\n        res.rSupply = _shares;\n    }\n\n    function getPosition(address account) internal view returns (StakeMath.Position memory res) {\n        res.rOwned = _shares_owned[account];\n    }\n\n    function setState(StakeMath.State memory update) internal {\n        _shares = update.rSupply;\n        _supply = update.tSupply;\n    }\n\n    function setPosition(StakeMath.Position memory update, address account) internal {\n        _shares_owned[account] = update.rOwned;\n    }\n\n    /*\n     *  LOGIC\n     * * * * * */\n\n    /**\n     * @dev increases a users total staked shares in a given epoch\n     * @param account the user who is adding shares\n     * @param amount the amount shares is being increased\n     * @custom:assump earnings should stay same\n     */\n    function _onShareAdd(address account, uint256 amount) internal {\n        StakeMath.State memory state = getStateBeforeDeposit(amount);\n        StakeMath.Position memory pos = getPosition(account);\n\n        StakeMath.applyShareAdd(state, pos, amount);\n\n        setState(state);\n        setPosition(pos, account);\n\n        emit ShareAdd(account, msg_sender(), amount);\n    }\n\n    function _onShareSub(address account, uint256 amount) internal {\n        StakeMath.State memory state = getState();\n        StakeMath.Position memory pos = getPosition(account);\n\n        StakeMath.applyShareSub(state, pos, amount);\n\n        setState(state);\n        setPosition(pos, account);\n\n        emit ShareSub(account, msg_sender(), amount);\n    }\n\n    /**\n     * @notice increases the overall eps from an increase in total rewards\n     * @param amount the amount the total reward is being increased\n     */\n    function _onRoyaltyAdd(address sender, uint256 amount) internal virtual {\n        StakeMath.State memory state = getState();\n\n        StakeMath.applyRoyaltyAdd(state, amount);\n\n        setState(state);\n\n        emit RoyaltyAdd(sender, amount);\n    }\n\n    function _onRealize(address account, uint256 amount) internal {\n        emit Realize(account, msg_sender(), amount);\n    }\n}\n"
    },
    "contracts/libraries/Exchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport '../libraries/Address.sol';\n\n// import '../interfaces/IWETH9.sol';\n// import '../weth/interfaces/INuggETH.sol';\n\nlibrary Exchange {\n    using Address for address payable;\n\n    function take_eth(address account, uint256 amount) internal {\n        require(msg.value == amount && msg.sender == account, 'EX:TE:0');\n    }\n\n    function give_eth(address payable account, uint256 amount) internal {\n        account.sendValue(amount);\n    }\n\n    // function give_weth(\n    //     IWETH9 weth,\n    //     address account,\n    //     uint256 amount\n    // ) internal {\n    //     weth.deposit{value: amount}();\n    //     weth.transfer(account, amount);\n    // }\n\n    // function take_weth(\n    //     IWETH9 weth,\n    //     address account,\n    //     uint256 amount\n    // ) internal {\n    //     require(weth.allowance(account, address(this)) >= amount, 'EXC:TW:0'); // only for better handling on front end\n    //     weth.transferFrom(account, address(this), amount);\n    //     weth.withdraw(amount);\n    // }\n\n    // function give_nuggeth(\n    //     INuggETH nuggeth,\n    //     address account,\n    //     uint256 amount\n    // ) internal {\n    //     nuggeth.depositTo{value: amount}(account);\n    // }\n\n    // function take_nuggeth(\n    //     INuggETH nuggeth,\n    //     address account,\n    //     uint256 amount\n    // ) internal {\n    //     require(nuggeth.allowance(account, address(this)) >= amount, 'EXC:TW:0'); // only for better handling on front end\n    //     nuggeth.withdrawFrom(account, amount);\n    // }\n}\n"
    },
    "contracts/interfaces/IxNUGG.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IStakeable.sol';\nimport '../interfaces/IEscrowable.sol';\nimport '../erc20/IERC20.sol';\nimport '../erc2981/IERC2981Receiver.sol';\n\n/**\n * @title ISeedable\n * @dev interface for Seedable.sol\n */\ninterface IxNUGG is IERC20, IStakeable, IEscrowable, IERC2981Receiver {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n\n    function totalSupply() external view override(IERC20, IStakeable) returns (uint256 res);\n\n    function balanceOf(address from) external view override(IERC20) returns (uint256 res);\n\n    function balanceOfMinted(address from) external view returns (uint256 res);\n\n    function totalSupplyMinted() external view returns (uint256 res);\n}\n"
    },
    "contracts/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol';\nimport './IERC20Metadata.sol';\n\nimport '../common/Testable.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20, IERC20Metadata, Testable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg_sender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg_sender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg_sender()];\n        require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\n        unchecked {\n            _approve(sender, msg_sender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg_sender(), spender, _allowances[msg_sender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg_sender()][spender];\n        require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\n        unchecked {\n            _approve(msg_sender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev internal non-virtual version {IERC20-balanceOf}\n     */\n    function _balanceOf(address account) internal view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), 'ERC20: transfer from the zero address');\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _assign(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: assign to the zero address');\n\n        // _beforeTokenTransfer(address(0), account, amount);\n\n        uint256 senderBalance = _balances[address(this)];\n        require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\n        unchecked {\n            _balances[address(this)] = senderBalance - amount;\n        }\n        _balances[account] += amount;\n\n        emit Transfer(address(this), account, amount);\n\n        // _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/erc2981/ERC2981Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC2981Receiver.sol';\n\n/**\n * @dev Implementation of the {IERC2981Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC2981-safeTransferFrom}, {IERC2981-approve} or {IERC2981-setApprovalForAll}.\n */\ncontract ERC2981Receiver is IERC2981Receiver {\n    /**\n     * @dev See {IERC2981Receiver-onERC2981Received}.\n     *\n     * Always returns `IERC2981Receiver.onERC2981Received.selector`.\n     */\n    function onERC2981Received(\n        address operator,\n        address from,\n        address token,\n        uint256 tokenId,\n        address erc20,\n        uint256 amount,\n        bytes calldata data\n    ) public payable virtual override returns (bytes4) {\n        return this.onERC2981Received.selector;\n    }\n}\n"
    },
    "contracts/interfaces/IStakeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/StakeMath.sol';\n\n/**\n * @title IStakeable\n * @dev interface for Stakeable.sol\n */\ninterface IStakeable {\n    event Realize(address indexed account, address sender, uint256 amount);\n    event ShareAdd(address indexed account, address sender, uint256 amount);\n    event ShareSub(address indexed account, address sender, uint256 amount);\n    event RoyaltyAdd(address indexed sender, uint256 amount);\n\n    /**\n     * @dev in regards to this contract, this could just be earningsOf + sharesOf\n     */\n    function supplyOf(address account) external returns (uint256 res);\n\n    function ownershipOfX128(address account) external view returns (uint256 res);\n\n    function sharesOf(address account) external view returns (uint256 res);\n\n    /**\n     * @notice returns user's current reward balance\n     * @return res\n     */\n    function totalSupply() external view returns (uint256 res);\n\n    /**\n     * @notice returns user's current reward balance\n     * @return res\n     */\n\n    function totalShares() external view returns (uint256 res);\n}\n"
    },
    "contracts/libraries/StakeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport './QuadMath.sol';\n\nimport 'hardhat/console.sol';\n\n/**\n * @title StakeMath\n * @notice a library for performing staking operations\n * @dev #TODO\n */\nlibrary StakeMath {\n    using QuadMath for uint256;\n\n    struct Position {\n        uint256 rOwned;\n    }\n\n    struct State {\n        uint256 tSupply;\n        uint256 rSupply;\n    }\n\n    /**\n     * @notice #TODO\n     * @param state the percent out of 100 to be taken\n     * @param pos the percent out of 100 to be taken\n     * @return res shares\n     * @dev #TODO\n     */\n    function getBalance(State memory state, Position memory pos) internal pure returns (uint256 res) {\n        return pos.rOwned > 0 ? _safeRtoT(state, pos.rOwned) : 0;\n    }\n\n    /**\n     * @notice #TODO\n     * @param state the percent out of 100 to be taken\n     * @param pos the percent out of 100 to be taken\n     * @return res shares\n     * @dev #TODO\n     */\n    function getOwnershipX128(State memory state, Position memory pos) internal pure returns (uint256 res) {\n        return pos.rOwned.mulDiv(QuadMath._BINARY128, state.rSupply);\n    }\n\n    function _safeRtoT(State memory state, uint256 rAmount) private pure returns (uint256) {\n        return rAmount.mulDiv(state.tSupply, state.rSupply);\n    }\n\n    function _safeTtoR(State memory state, uint256 tAmount) private pure returns (uint256) {\n        return tAmount.mulDiv(state.rSupply, state.tSupply);\n    }\n\n    function _safeRtoTRoundingUp(State memory state, uint256 rAmount) private pure returns (uint256) {\n        return rAmount.mulDivRoundingUp(state.tSupply, state.rSupply);\n    }\n\n    function _safeTtoRRoundingUp(State memory state, uint256 tAmount) private pure returns (uint256) {\n        return tAmount.mulDivRoundingUp(state.rSupply, state.tSupply);\n    }\n\n    function applyShareAdd(\n        State memory state,\n        Position memory pos,\n        uint256 tAmount\n    ) internal pure {\n        if (state.rSupply == 0 && state.tSupply == 0) {\n            pos.rOwned = tAmount;\n            state.rSupply = tAmount;\n            state.tSupply = tAmount;\n        } else {\n            uint256 amountR = _safeTtoR(state, tAmount);\n            pos.rOwned += amountR;\n            state.rSupply += amountR;\n            state.tSupply += tAmount;\n        }\n    }\n\n    function applyShareSub(\n        State memory state,\n        Position memory pos,\n        uint256 tAmount\n    ) internal pure {\n        uint256 amountR = _safeTtoRRoundingUp(state, tAmount);\n        pos.rOwned -= amountR;\n        state.rSupply -= amountR;\n        state.tSupply -= tAmount;\n    }\n\n    function applyRoyaltyAdd(State memory state, uint256 amount) internal pure {\n        state.tSupply += amount;\n    }\n}\n"
    },
    "contracts/libraries/QuadMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title QuadMath\n * @notice a library for performing Quadruple-precision floating-point format math operations\n * @dev #TODO\n */\nlibrary QuadMath {\n    struct Uint512 {\n        uint256 a;\n        uint256 b;\n    }\n    /**\n     * Max Value of Quad Percion Binary 128\n     * Equal to 340282366920938463463374607431768211456 or 2^128\n     */\n    // uint256 internal constant _BINARY128 = 0x100000000000000000000000000000000;\n    uint256 internal constant _BINARY128 = 0x100000000000000000000000000000000;\n\n    /**\n     * @notice #TODO\n     * @param base_ the amount to take a percent of\n     * @param percent_ the percent out of 100 to be taken\n     * @return res precent_ of base_\n     * @dev #TODO\n     */\n    function percent(uint256 base_, uint8 percent_) internal pure returns (uint256 res) {\n        require(percent_ <= 100);\n        res = mulDiv(base_, percent_ * _BINARY128, 100 * _BINARY128);\n    }\n\n    function mulDivRoundingUnsafe(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) >= denominator / 2) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n\n    function mulDivQuad(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(mulDiv(a, _BINARY128, denominator), b, _BINARY128);\n    }\n\n    function mulDivQuadUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDivRoundingUp(mulDivRoundingUp(a, _BINARY128, denominator), b, _BINARY128);\n    }\n\n    /**\n     * @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @param a The multiplicand\n     * @param b The multiplier\n     * @param denominator The divisor\n     * @return result The 256-bit result\n     * @dev Credit to Uniswap under MIT license https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol\n     */\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n\n    /**\n     * @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @param a The multiplicand\n     * @param b The multiplier\n     * @param denominator The divisor\n     * @return result The 256-bit result\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     */\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        // fix for negation braking change in Solidity v8 - https://ethereum.stackexchange.com/a/96646\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n\n        // this unchecked block is required for this to work with Solidity v8\n        unchecked {\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n        }\n        return result;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/erc2981/IERC2981Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC2981 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC2981 asset contracts.\n */\ninterface IERC2981Receiver {\n    /**\n     * @dev Whenever an {IERC2981} `tokenId` token is transferred to this contract via {IERC2981-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC2981.onERC2981Received.selector`.\n     */\n    function onERC2981Received(\n        address operator,\n        address from,\n        address token,\n        uint256 tokenId,\n        address erc20,\n        uint256 amount,\n        bytes calldata data\n    ) external payable returns (bytes4);\n}\n"
    },
    "contracts/erc20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol';\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/libraries/SwapLib.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport '../erc721/IERC721.sol';\nimport '../erc2981/IERC2981Receiver.sol';\n\nimport './Address.sol';\nimport '../interfaces/INuggSwapable.sol';\nimport '../interfaces/INuggMintable.sol';\n\nlibrary SwapLib {\n    using Address for address;\n    using Address for address payable;\n\n    struct OfferData {\n        bool claimed;\n        address account;\n        uint128 amount;\n    }\n\n    struct SwapData {\n        address nft;\n        uint256 tokenid;\n        uint256 num;\n        address leader;\n        uint128 leaderAmount;\n        uint64 epoch;\n        address owner;\n        bool claimedByOwner;\n        uint64 activeEpoch;\n        bool exists;\n    }\n\n    function decodeSwapData(uint256 _unparsed)\n        internal\n        pure\n        returns (\n            address leader,\n            uint64 epoch,\n            bool claimedByOwner,\n            bool exists\n        )\n    {\n        assembly {\n            exists := shr(232, _unparsed)\n            claimedByOwner := shr(248, shl(24, _unparsed))\n            epoch := shr(160, _unparsed)\n            leader := _unparsed\n        }\n    }\n\n    function encodeSwapData(\n        address leader,\n        uint64 epoch,\n        bool claimedByOwner,\n        bool exists\n    ) internal pure returns (uint256 res) {\n        assembly {\n            res := or(or(or(shl(232, exists), shl(224, claimedByOwner)), shl(160, epoch)), leader)\n        }\n    }\n\n    function decodeSwapId(uint256 _unparsed)\n        internal\n        pure\n        returns (\n            address nft,\n            uint256 tokenid,\n            uint256 swapNum\n        )\n    {\n        assembly {\n            swapNum := shr(224, _unparsed)\n            tokenid := shr(160, _unparsed)\n            nft := _unparsed\n        }\n    }\n\n    function encodeSwapId(\n        address nft,\n        uint256 tokenid,\n        uint256 swapNum\n    ) internal pure returns (uint256 res) {\n        assembly {\n            res := or(or(shl(224, swapNum), shl(160, tokenid)), nft)\n        }\n    }\n\n    function decodeOfferData(uint256 _unparsed) internal pure returns (uint128 amount, bool claimed) {\n        assembly {\n            claimed := shr(128, _unparsed)\n            amount := _unparsed\n        }\n    }\n\n    function encodeOfferData(uint128 amount, bool claimed) internal pure returns (uint256 res) {\n        assembly {\n            res := or(shl(128, claimed), amount)\n        }\n    }\n\n    function takeToken(\n        IERC721 nft,\n        uint256 tokenid,\n        address from\n    ) internal {\n        require(nft.supportsInterface(type(INuggSwapable).interfaceId), 'AUC:TT:0');\n\n        // TODO check that royalty supports the\n\n        require(nft.ownerOf(tokenid) == from, 'AUC:TT:1');\n\n        nft.safeTransferFrom(from, address(this), tokenid);\n\n        require(nft.ownerOf(tokenid) == address(this), 'AUC:TT:3');\n    }\n\n    function _giveToken(\n        address nft,\n        uint256 tokenid,\n        address to\n    ) internal {\n        IERC721 _nft = IERC721(nft);\n        require(_nft.ownerOf(tokenid) == address(this), 'AUC:TT:1');\n\n        _nft.safeTransferFrom(address(this), to, tokenid);\n\n        require(_nft.ownerOf(tokenid) == to, 'AUC:TT:3');\n    }\n\n    function handleSubmitOffer(\n        SwapData memory swap,\n        OfferData memory offer,\n        uint256 amount\n    ) internal pure {\n        require(swap.owner != offer.account, 'SL:HSO:0');\n\n        offer.amount += uint128(amount);\n\n        require(isActive(swap), 'SL:OBP:0');\n        require(validateOfferIncrement(swap, offer), 'SL:OBP:1');\n\n        swap.leader = offer.account;\n    }\n\n    function handleSubmitClaim(SwapData memory swap, OfferData memory offer) internal {\n        require(swap.exists, 'SL:HBC:0');\n        require(!offer.claimed, 'AUC:CLM:0');\n        require(offer.amount > 0, 'AUC:CLM:1');\n\n        offer.claimed = true;\n\n        if (isOver(swap)) {\n            if (offer.account == swap.leader) {\n                _giveToken(swap.nft, swap.tokenid, offer.account);\n            } else {\n                payable(offer.account).sendValue(offer.amount);\n            }\n        } else {\n            require(offer.account == swap.leader && offer.account == swap.owner, 'AUC:CLM:2');\n            swap.claimedByOwner = true;\n        }\n    }\n\n    function handleSubmitSwap(\n        SwapData memory swap,\n        OfferData memory offer,\n        uint64 epoch,\n        uint128 floor\n    ) internal pure {\n        require(!swap.exists, 'AUC:IA:0');\n\n        swap.epoch = epoch;\n        require(hasVaildEpoch(swap), 'AUC:IA:1');\n\n        swap.leader = offer.account;\n        swap.exists = true;\n\n        offer.amount = floor;\n    }\n\n    function validateOfferIncrement(SwapData memory swap, OfferData memory offer) internal pure returns (bool) {\n        return offer.amount > swap.leaderAmount + ((swap.leaderAmount * 100) / 10000);\n    }\n\n    function hasVaildEpoch(SwapData memory swap) internal pure returns (bool) {\n        return swap.epoch >= swap.activeEpoch && swap.epoch - swap.activeEpoch <= 1000;\n    }\n\n    function isOver(SwapData memory swap) internal pure returns (bool) {\n        return swap.exists && (swap.activeEpoch > swap.epoch || swap.claimedByOwner);\n    }\n\n    function isActive(SwapData memory swap) internal pure returns (bool) {\n        return swap.exists && !swap.claimedByOwner && swap.activeEpoch <= swap.epoch;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param token token sending the royalties\n     * @param tokenid uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC2981Received(\n        address from,\n        address to,\n        address token,\n        uint256 tokenid,\n        address,\n        uint256,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC2981Receiver(to).onERC2981Received(msg.sender, from, token, tokenid, address(0), 0, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC2981Receiver.onERC2981Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('ERC2981: transfer to non ERC2981Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/erc721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '../erc165/IERC165.sol';\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/INuggSwapable.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport '../erc2981/IERC2981.sol';\n\ninterface INuggSwapable is IERC2981 {\n    // function currentEpoch() external returns (uint32);\n}\n"
    },
    "contracts/interfaces/INuggMintable.sol": {
      "content": "pragma solidity 0.8.4;\nimport './INuggSwapable.sol';\n\ninterface INuggMintable is INuggSwapable {\n    function nuggSwapMint(uint256 currentEpochId) external returns (uint256 tokenId);\n}\n"
    },
    "contracts/erc165/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/erc2981/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '../erc165/IERC165.sol';\n\n/**\n * @dev Interface for the NFT Royalty Standard\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Called with the sale price to determine how much royalty is owed and to whom.\n     * @param tokenId - the NFT asset queried for royalty information\n     * @param salePrice - the sale price of the NFT asset specified by `tokenId`\n     * @return receiver - address of who should be sent the royalty payment\n     * @return royaltyAmount - the royalty payment amount for `salePrice`\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "contracts/NuggSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './libraries/SwapLib.sol';\nimport './interfaces/INuggSwap.sol';\n\nimport './interfaces/INuggSwapable.sol';\nimport './interfaces/IxNUGG.sol';\n\nimport 'hardhat/console.sol';\nimport './erc721/IERC721.sol';\nimport './core/Epochable.sol';\n\nimport './common/Testable.sol';\nimport './erc721/ERC721Holder.sol';\n\ncontract NuggSwap is INuggSwap, ERC721Holder, Testable, Epochable {\n    using Address for address payable;\n    using SwapLib for SwapLib.SwapData;\n\n    mapping(address => mapping(uint256 => address[])) internal _swapOwners;\n\n    // mapping(address => uint256) internal _registrations; // address - supports minting, supports swapping, implements mintable, implements swappable, where to send royalties, approvals\n\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal _encodedSwapData;\n\n    mapping(address => mapping(uint256 => mapping(uint256 => mapping(address => uint256)))) internal _encodedOfferData;\n\n    IxNUGG public immutable override xnugg;\n\n    constructor(IxNUGG _xnugg) Epochable(25, uint128(block.number)) {\n        xnugg = _xnugg;\n    }\n\n    function getSwap(address nft, uint256 tokenid)\n        external\n        view\n        override\n        returns (\n            uint256 swapnum,\n            address leader,\n            uint128 leaderAmount,\n            uint64 epoch,\n            bool claimedByOwner,\n            bool exists\n        )\n    {\n        swapnum = _swapOwners[nft][tokenid].length;\n        (leader, epoch, claimedByOwner, exists) = SwapLib.decodeSwapData(_encodedSwapData[nft][tokenid][swapnum]);\n        (leaderAmount, ) = SwapLib.decodeOfferData(_encodedOfferData[nft][tokenid][swapnum][leader]);\n    }\n\n    function getSwap(\n        address nft,\n        uint256 tokenid,\n        uint256 _swapnum\n    )\n        external\n        view\n        override\n        returns (\n            uint256 swapnum,\n            address leader,\n            uint128 leaderAmount,\n            uint64 epoch,\n            bool claimedByOwner,\n            bool exists\n        )\n    {\n        require(_swapnum <= _swapOwners[nft][tokenid].length);\n        swapnum = _swapnum;\n        (leader, epoch, claimedByOwner, exists) = SwapLib.decodeSwapData(_encodedSwapData[nft][tokenid][swapnum]);\n        (leaderAmount, ) = SwapLib.decodeOfferData(_encodedOfferData[nft][tokenid][swapnum][leader]);\n    }\n\n    // function registerFromCreation() external {\n    //     // require contract in creation\n    //     // require that nft implements the NuggSwapable interface\n    //     // require that it is an nft (implements ERC721)\n    // }\n\n    // function registerByOwner(address nft, address royaltyAddress) external {\n    //     // require this is owner of nft\n    //     // require that it is an nft (implements ERC721)\n    // }\n\n    // function registerByTokenOwners(address nft, address royaltyAddress) external {\n    //     // require this is owner of nft\n    //     // require that it is an nft (implements ERC721)\n    // }\n\n    function submitSwap(\n        address nft,\n        uint256 tokenid,\n        uint64 requestedEpoch,\n        uint128 requestedFloor\n    ) external override {\n        _submitSwap(nft, tokenid, msg_sender(), requestedEpoch, requestedFloor);\n    }\n\n    function submitOffer(address nft, uint256 tokenid) external payable override {\n        _submitOffer(nft, tokenid);\n    }\n\n    function submitClaim(address nft, uint256 tokenid) external override {\n        _submitClaim(nft, tokenid);\n    }\n\n    function _submitSwap(\n        address nft,\n        uint256 tokenid,\n        address account,\n        uint64 requestedEpoch,\n        uint128 requestedFloor\n    ) internal {\n        SwapLib.takeToken(IERC721(nft), tokenid, account);\n\n        address[] storage prevSwapOwners = _swapOwners[nft][tokenid];\n\n        prevSwapOwners.push(account);\n\n        (SwapLib.SwapData memory swap, SwapLib.OfferData memory offer) = loadData(nft, tokenid, account);\n\n        swap.handleSubmitSwap(offer, requestedEpoch, requestedFloor);\n\n        saveData(swap, offer);\n\n        // prevSwapOwners.push(account);\n\n        emit SubmitSwap(swap.nft, swap.tokenid, swap.num, offer.account, offer.amount, swap.epoch);\n    }\n\n    function _submitOffer(address nft, uint256 tokenid) internal {\n        (SwapLib.SwapData memory swap, SwapLib.OfferData memory offer) = loadData(nft, tokenid, msg_sender());\n\n        if (!swap.exists) mintToken(swap);\n\n        swap.handleSubmitOffer(offer, msg_value());\n\n        saveData(swap, offer);\n\n        uint256 increase = offer.amount - swap.leaderAmount;\n\n        (address royAccount, uint256 roy) = IERC2981(swap.nft).royaltyInfo(swap.tokenid, increase);\n\n        // todo - we need to check if they implement erc2981 - if they do not send royalties to owner - if they have no owner than no royalties\n\n        if (royAccount == address(xnugg)) {\n            xnugg.onERC2981Received{value: increase}(\n                address(this),\n                offer.account,\n                swap.nft,\n                tokenid,\n                address(0),\n                0,\n                ''\n            );\n        } else {\n            IERC2981Receiver(royAccount).onERC2981Received{value: roy}(\n                address(this),\n                offer.account,\n                swap.nft,\n                swap.tokenid,\n                address(0),\n                0,\n                ''\n            );\n            xnugg.onERC2981Received{value: increase - roy}(\n                address(this),\n                offer.account,\n                swap.nft,\n                tokenid,\n                address(0),\n                0,\n                ''\n            );\n        }\n\n        emit SubmitOffer(swap.nft, swap.tokenid, swap.num, offer.account, offer.amount);\n    }\n\n    function _submitClaim(address nft, uint256 tokenid) internal {\n        (SwapLib.SwapData memory swap, SwapLib.OfferData memory offer) = loadData(nft, tokenid, msg_sender());\n\n        swap.handleSubmitClaim(offer);\n\n        saveData(swap, offer);\n\n        emit SubmitClaim(swap.nft, swap.tokenid, swap.num, offer.account);\n    }\n\n    function mintToken(SwapLib.SwapData memory swap) internal {\n        IERC721 _nft = IERC721(swap.nft);\n\n        require(_nft.supportsInterface(type(INuggMintable).interfaceId), 'AUC:MT:0');\n\n        uint256 tokenid = INuggMintable(address(swap.nft)).nuggSwapMint(swap.activeEpoch);\n\n        ensureActiveSeed();\n\n        require(tokenid == swap.tokenid, 'AUC:MT:2');\n        require((_nft.ownerOf(swap.tokenid) == address(this)), 'AUC:MT:3');\n\n        swap.handleSubmitSwap(SwapLib.OfferData({account: address(0), amount: 0, claimed: false}), swap.activeEpoch, 0);\n    }\n\n    function loadData(\n        address nft,\n        uint256 tokenid,\n        address account\n    ) internal view returns (SwapLib.SwapData memory swap, SwapLib.OfferData memory offer) {\n        uint256 swapnum = _swapOwners[nft][tokenid].length;\n\n        (address leader, uint64 epoch, bool claimedByOwner, bool exists) = SwapLib.decodeSwapData(\n            _encodedSwapData[nft][tokenid][swapnum]\n        );\n\n        (uint128 leaderAmount, ) = SwapLib.decodeOfferData(_encodedOfferData[nft][tokenid][swapnum][leader]);\n        console.log('yellow', swapnum);\n        swap = SwapLib.SwapData({\n            nft: nft,\n            tokenid: tokenid,\n            num: swapnum,\n            leader: leader,\n            leaderAmount: leaderAmount,\n            epoch: epoch,\n            exists: exists,\n            claimedByOwner: claimedByOwner,\n            owner: swapnum == 0 ? address(0) : _swapOwners[nft][tokenid][swapnum - 1],\n            activeEpoch: currentEpochId()\n        });\n\n        (uint128 amount, bool claimed) = SwapLib.decodeOfferData(_encodedOfferData[nft][tokenid][swapnum][account]);\n\n        offer = SwapLib.OfferData({claimed: claimed, amount: amount, account: account});\n    }\n\n    function saveData(SwapLib.SwapData memory swap, SwapLib.OfferData memory offer) internal {\n        _encodedSwapData[swap.nft][swap.tokenid][swap.num] = SwapLib.encodeSwapData(\n            swap.leader,\n            swap.epoch,\n            swap.claimedByOwner,\n            swap.exists\n        );\n        _encodedOfferData[swap.nft][swap.tokenid][swap.num][offer.account] = SwapLib.encodeOfferData(\n            offer.amount,\n            offer.claimed\n        );\n    }\n}\n"
    },
    "contracts/interfaces/INuggSwap.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport './IxNUGG.sol';\n\ninterface INuggSwap {\n    event SubmitOffer(address nft, uint256 tokenid, uint256 swapnum, address account, uint256 amount);\n\n    event SubmitSwap(address nft, uint256 tokenid, uint256 swapnum, address account, uint256 amount, uint64 epoch);\n\n    event SubmitClaim(address nft, uint256 tokenid, uint256 swapnum, address account);\n\n    function xnugg() external view returns (IxNUGG);\n\n    function submitSwap(\n        address nft,\n        uint256 tokenid,\n        uint64 requestedEpoch,\n        uint128 requestedFloor\n    ) external;\n\n    function submitOffer(address nft, uint256 tokenid) external payable;\n\n    function submitClaim(address nft, uint256 tokenid) external;\n\n    function getSwap(address nft, uint256 tokenid)\n        external\n        view\n        returns (\n            uint256 swapnum,\n            address leader,\n            uint128 leaderAmount,\n            uint64 epoch,\n            bool claimedByOwner,\n            bool exists\n        );\n\n    function getSwap(\n        address nft,\n        uint256 tokenid,\n        uint256 _swapnum\n    )\n        external\n        view\n        returns (\n            uint256 swapnum,\n            address leader,\n            uint128 leaderAmount,\n            uint64 epoch,\n            bool claimedByOwner,\n            bool exists\n        );\n}\n"
    },
    "contracts/core/Epochable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport '../interfaces/IEpochable.sol';\n\nimport '../interfaces/IEpochable.sol';\nimport '../libraries/EpochMath.sol';\nimport '../libraries/SeedMath.sol';\n\n/**\n * @title Epochable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice enables children contracts to break themselves into epochs based on block number\n * @dev also enables storage of blockhash for a given epoch\n */\nabstract contract Epochable is IEpochable {\n    using EpochMath for uint256;\n\n    mapping(uint256 => bytes32) private _seeds;\n\n    uint256 private _state;\n\n    event Genesis(uint128 interval, uint128 baseblock);\n\n    constructor(uint128 _interval, uint128 _baseblock) {\n        _state = EpochMath.encodeData(_interval, _baseblock);\n        emit Genesis(_interval, _baseblock);\n    }\n\n    /**\n     * @notice gets unique base based on given epoch and converts encoded bytes to object that can be merged\n     * Note: by using the block hash no one knows what a nugg will look like before it's epoch.\n     * We considered making this harder to manipulate, but we decided that if someone were able to\n     * pull it off and make their own custom nugg, that would be really fucking cool.\n     */\n    function currentSeed() public view override returns (bytes32 res) {\n        uint256 num = blocknumFromId(currentEpochId()) - 1;\n        res = blockhash(num);\n        require(res != 0, 'EPC:SBL');\n        res = keccak256(abi.encodePacked(res, num));\n    }\n\n    /**\n     * @dev\n     * @return\n     */\n    function getSeed(uint256 id) public view override returns (bytes32 res) {\n        if (seedExists(id)) return _seeds[id];\n        else if (currentEpochId() == id) return currentSeed();\n        else require(false, 'SEED:GET:0');\n    }\n\n    /**\n     * @dev\n     * @return\n     */\n    function getSeedWithOffset(uint256 id, uint256 offset) public view override returns (bytes32 res) {\n        res = getSeed(id + offset);\n    }\n\n    function seedExists(uint256 id) public view override returns (bool res) {\n        return _seeds[id] != 0;\n    }\n\n    /**\n     * @dev\n     * @return\n     */\n    function setSeed() internal {\n        require(!seedExists(currentEpochId()), 'SEED:SET:0');\n        _seeds[currentEpochId()] = currentSeed();\n    }\n\n    /**\n     * @dev\n     * @return\n     */\n    function ensureActiveSeed() internal {\n        if (!seedExists(currentEpochId())) {\n            _seeds[currentEpochId()] = currentSeed();\n        }\n    }\n\n    /**\n     * @dev public wrapper for internal _genesisBlock - to save on gas\n     * @inheritdoc IEpochable\n     */\n    function genesisBlock() public view override returns (uint256 res) {\n        res = _state.decodeGenesis();\n    }\n\n    /**\n     * @dev public wrapper for internal _interval - to save on gas\n     * @inheritdoc IEpochable\n     */\n    function interval() public view override returns (uint256 res) {\n        res = _state.decodeInterval();\n    }\n\n    /**\n     * @dev public wrapper for internal _currentEpoch() - to save on gas\n     * @inheritdoc IEpochable\n     */\n    function currentEpochId() public view override returns (uint64 res) {\n        res = _state.getIdFromBlocknum(block.number);\n    }\n\n    function epochFromId(uint64 id) public view returns (EpochMath.Epoch memory res) {\n        res = _state.getEpoch(id, block.number);\n    }\n\n    /**\n     * @dev public wrapper for internal blocknumFirstFromEpoch() - to save on gas\n     */\n    function epochFromBlocknum(uint256 blocknum) public view override returns (EpochMath.Epoch memory res) {\n        res = _state.getEpoch(_state.getIdFromBlocknum(blocknum), block.number);\n    }\n\n    /**\n     * @dev public wrapper for internal blocknumFirstFromEpoch() - to save on gas\n     */\n    function epochStatus(uint64 id) public view returns (EpochMath.Status res) {\n        return _state.getStatus(id, block.number);\n    }\n\n    /**\n     * @dev public wrapper for internal blocknumFirstFromEpoch() - to save on gas\n     */\n    function blocknumFromId(uint64 id) public view returns (uint256) {\n        return _state.getStartBlockFromId(id);\n    }\n}\n"
    },
    "contracts/erc721/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC721Receiver.sol';\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/interfaces/IEpochable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/EpochMath.sol';\n\n/**\n * @title IEpochable\n */\n\ninterface IEpochable {\n    function getSeed(uint256 id) external view returns (bytes32 res);\n\n    function getSeedWithOffset(uint256 id, uint256 offset) external view returns (bytes32 res);\n\n    function seedExists(uint256 id) external view returns (bool res);\n\n    function currentSeed() external view returns (bytes32 res);\n\n    function genesisBlock() external view returns (uint256 res);\n\n    function interval() external view returns (uint256 res);\n\n    function currentEpochId() external view returns (uint64 res);\n\n    function epochFromBlocknum(uint256 blocknum) external view returns (EpochMath.Epoch memory res);\n}\n"
    },
    "contracts/libraries/EpochMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary EpochMath {\n    enum Status {\n        OVER,\n        ACTIVE,\n        PENDING\n    }\n\n    struct Epoch {\n        uint64 id;\n        uint256 startblock;\n        uint256 endblock;\n        Status status;\n    }\n\n    function encodeData(uint128 _interval, uint128 _baseblock) internal pure returns (uint256 res) {\n        assembly {\n            res := or(shl(128, _baseblock), _interval)\n        }\n    }\n\n    function decodeGenesis(uint256 _state) internal pure returns (uint256 res) {\n        assembly {\n            res := shr(128, _state)\n        }\n    }\n\n    function decodeInterval(uint256 _state) internal pure returns (uint256 res) {\n        assembly {\n            res := shr(128, shl(128, _state))\n        }\n    }\n\n    function getEpoch(\n        uint256 state,\n        uint64 id,\n        uint256 blocknum\n    ) internal pure returns (EpochMath.Epoch memory res) {\n        res = EpochMath.Epoch({\n            id: id,\n            startblock: getStartBlockFromId(state, id),\n            endblock: getEndBlockFromId(state, id),\n            status: getStatus(state, id, blocknum)\n        });\n    }\n\n    function getStatus(\n        uint256 state,\n        uint64 id,\n        uint256 blocknum\n    ) internal pure returns (Status res) {\n        if (getIdFromBlocknum(state, blocknum) == id) res = Status.ACTIVE;\n        else if (getEndBlockFromId(state, id) < blocknum) res = Status.OVER;\n        else res = Status.PENDING;\n    }\n\n    /**\n     * @dev #TODO\n     * @return res\n     */\n    function getStartBlockFromId(uint256 state, uint64 id) internal pure returns (uint256 res) {\n        res = id * decodeInterval(state) + decodeGenesis(state);\n    }\n\n    /**\n     * @dev #TODO\n     * @return res\n     */\n    function getEndBlockFromId(uint256 state, uint64 id) internal pure returns (uint256 res) {\n        res = getStartBlockFromId(state, id + 1) - 1;\n    }\n\n    function getIdFromBlocknum(uint256 state, uint256 blocknum) internal pure returns (uint64 res) {\n        res = uint64((blocknum - decodeGenesis(state)) / decodeInterval(state));\n    }\n}\n"
    },
    "contracts/libraries/SeedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary SeedMath {\n    /**\n     * @notice turns a seed into a unique uint256 to be used in computation\n     * @param seed the bytes32\n     * @dev not intended to be truly random\n     */\n    function toUint256(bytes32 seed) internal pure returns (uint256 res) {\n        return uint256(keccak256(abi.encodePacked(seed)));\n    }\n}\n"
    },
    "contracts/erc721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/erc721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC721.sol';\nimport './IERC721Metadata.sol';\nimport './IERC721Receiver.sol';\n\nimport '../erc165/ERC165.sol';\n// import '@openzeppelin/contracts/utils/Context.sol';\n\n// import '../libraries/Address.sol';\nimport '../common/Testable.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is ERC165, IERC721, IERC721Metadata, Testable {\n    using Address for address;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), 'ERC721: balance query for the zero address');\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), 'ERC721: owner query for nonexistent token');\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    // /**\n    //  * @dev See {IERC721Metadata-tokenURI}.\n    //  */\n    // function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    //     require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n\n    //     string memory baseURI = _baseURI();\n    //     return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    // }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}. MODIFICATION 0\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory);\n\n    // /**\n    //  * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n    //  * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n    //  * by default, can be overriden in child contracts.\n    //  */\n    // function _baseURI() internal view virtual returns (string memory) {\n    //     return '';\n    // }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, 'ERC721: approval to current owner');\n\n        require(msg_sender() == owner || isApprovedForAll(owner, msg_sender()), 'ERC721: approve caller is not owner nor approved for all');\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != msg_sender(), 'ERC721: approve to caller');\n\n        _operatorApprovals[msg_sender()][operator] = approved;\n        emit ApprovalForAll(msg_sender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg_sender(), tokenId), 'ERC721: transfer caller is not owner nor approved');\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(msg_sender(), tokenId), 'ERC721: transfer caller is not owner nor approved');\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), 'ERC721: transfer to non ERC721Receiver implementer');\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), 'ERC721: operator query for nonexistent token');\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), 'ERC721: transfer to non ERC721Receiver implementer');\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), 'ERC721: mint to the zero address');\n        require(!_exists(tokenId), 'ERC721: token already minted');\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, 'ERC721: transfer of token that is not own');\n        require(to != address(0), 'ERC721: transfer to the zero address');\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg_sender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "contracts/erc721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC721.sol';\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/erc165/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC165.sol';\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/NuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './interfaces/IDotNuggFileResolver.sol';\nimport './interfaces/IDotNuggColorResolver.sol';\n\nimport './interfaces/IDotNugg.sol';\nimport './interfaces/INuggFT.sol';\nimport './NuggSwap.sol';\nimport './interfaces/IxNUGG.sol';\n\nimport './erc721/ERC721.sol';\nimport './erc2981/IERC2981.sol';\nimport './mock/MockDotNuggImplementer.sol';\n\n/**\n * @title Nugg Labs NFT Collection 0 - \"NuggFT\"\n * @author Nugg Labs - @danny7even & @dub6ix - 2021\n * @notice entrily onchain generative NFT\n * @dev this is art\n *\n * Note: epochs correlate directly to tokenIDs\n * Note: no images are stored in their final form - they are generated by view/pure functions at query time completly onchain\n * Note: the block hash corresponding to the start of an epoch is used as the \"random\" seed\n * Note: epochs are 256 blocks long as block hashes only exist for 256 blocks\n */\ncontract NuggFT is INuggFT, ERC721, MockDotNuggImplementer {\n    IDotNugg internal dotnugg;\n    IxNUGG internal xnugg;\n    NuggSwap internal nuggswap;\n    IDotNuggFileResolver internal nuggin;\n\n    uint256 public epochOffset;\n\n    constructor(\n        address _xnugg,\n        address _nuggswap,\n        address _dotnugg,\n        address _nuggin\n    ) ERC721('Nugg Fungable Token', 'NuggFT') {\n        dotnugg = IDotNugg(_dotnugg);\n        nuggswap = NuggSwap(_nuggswap);\n        xnugg = IxNUGG(_xnugg);\n        nuggin = IDotNuggFileResolver(_nuggin);\n\n        require(nuggin.supportsInterface(type(IDotNuggFileResolver).interfaceId), 'NUG:LAUNCH:0');\n\n        epochOffset = nuggswap.currentEpochId();\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceId == type(INuggMintable).interfaceId ||\n            interfaceId == type(INuggSwapable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function royaltyInfo(uint256, uint256 value) external view override returns (address, uint256) {\n        return (address(xnugg), (value * 1000) / 10000);\n    }\n\n    function nuggSwapMint(uint256 currentEpochId) external override returns (uint256 tokenId) {\n        tokenId = epochToTokenId(currentEpochId);\n        require(!_exists(tokenId), 'NFT:NSM:0');\n        _safeMint(address(nuggswap), tokenId);\n    }\n\n    function epochToTokenId(uint256 epoch) public view returns (uint256 tokenId) {\n        tokenId = epoch - epochOffset;\n    }\n\n    function currentTokenId() public view returns (uint256 tokenId) {\n        tokenId = epochToTokenId(nuggswap.currentEpochId());\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal view override {\n        require(msg_sender() == address(nuggswap), 'NFT:BTT:0');\n    }\n\n    /**\n     * @inheritdoc ERC721\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory res) {\n        require(_exists(tokenId) || tokenId == currentTokenId(), 'NFT:NSM:0');\n        res = _generateTokenURI(tokenId, address(nuggin));\n    }\n\n    function tokenURI(uint256 tokenId, address resolver) public view returns (string memory res) {\n        require(_exists(tokenId) || tokenId == currentTokenId(), 'NFT:NSM:0');\n        res = _generateTokenURI(tokenId, resolver);\n    }\n\n    /**\n     * @notice calcualtes the token uri for a given epoch\n     */\n    function _generateTokenURI(uint256 tokenId, address resolver) internal view returns (string memory) {\n        bytes32 seed = nuggswap.getSeedWithOffset(tokenId, epochOffset);\n\n        string memory uriName = 'NuggFT {#}';\n        string memory uriDesc = 'the description';\n\n        return dotnugg.nuggify(collection_, _getItems(seed), resolver, uriName, uriDesc, tokenId, seed, '');\n    }\n\n    // // collection_\n    // bytes private collection_;\n\n    // // bases_\n    // bytes[] internal items_;\n\n    /**\n     * @notice gets unique attribtues based on given epoch and converts encoded bytes to object that can be merged\n     */\n    function _getItems(bytes32 seed) internal view returns (bytes[] memory res) {\n        res = new bytes[](2);\n        for (uint8 i = 0; i < res.length; i++) {\n            res[i] = items_[((uint256(seed >> i) % (items_.length)))];\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDotNuggFileResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../erc165/IERC165.sol\";\n/**\n * @title IDotNuggFileResolver\n * @dev interface for Launchable.sol\n */\ninterface IDotNuggFileResolver is IERC165 {\n\n}\n"
    },
    "contracts/interfaces/IDotNuggColorResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title IDotNuggColorResolver\n * @dev interface for Launchable.sol\n */\ninterface IDotNuggColorResolver {\n\n}\n"
    },
    "contracts/interfaces/IDotNugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title IDotNugg\n * @dev interface for Launchable.sol\n */\ninterface IDotNugg {\n    function nuggify(\n        bytes memory _collection,\n        bytes[] memory _items,\n        address _resolver,\n        string memory name,\n        string memory description,\n        uint256 tokenId,\n        bytes32 seed,\n        bytes memory data\n    ) external view returns (string memory image);\n\n    struct Matrix {\n        uint8 width;\n        uint8 height;\n        Pixel[][] data;\n        uint8 currentUnsetX;\n        uint8 currentUnsetY;\n        bool init;\n        uint8 startX;\n    }\n\n    struct Rgba {\n        uint8 r;\n        uint8 g;\n        uint8 b;\n        uint8 a;\n    }\n    struct Pixel {\n        int8 zindex;\n        Rgba rgba;\n        bool exists;\n    }\n}\n"
    },
    "contracts/interfaces/INuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../erc721/IERC721.sol';\nimport './IDotNuggImplementer.sol';\nimport './INuggMintable.sol';\n\n/**\n * @title ILaunchable\n * @dev interface for Launchable.sol\n */\ninterface INuggFT is IDotNuggImplementer, INuggMintable, IERC721 {\n\n}\n"
    },
    "contracts/mock/MockDotNuggImplementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNuggImplementer.sol';\n\n/**\n * @title DotNuggImplementer V1 - onchain encoder/decoder for dotnuggImplementer files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract MockDotNuggImplementer is IDotNuggImplementer {\n    // collection_\n    bytes internal collection_;\n\n    // bases_\n    bytes[] internal items_;\n\n    bytes sample1 =\n        hex'444f544e554747c7cc00000e002c00f19325e500eb8a12e500f9b042e500c96619e500a84b1ee500f49f35e52121101000001720fe20ff20fd32fa11fc40f912fb00f80f0f0f0f0f0f0f0f0f0f0e5d0f005130633322520f5030653224500f5031663222500f5031673222500d5131661035500d50336536500d50346535500d50346535500d503111306634500d5034661033500d5035651132500d50346733500d50346a30500d50356a500d50356a500e5032116a500e50341068510e5034116224500f504033601027500f50402032632341500f50412031632341500f522031612341510f025b0f0f0f0f0f0f0f0f0e';\n\n    bytes sample2 =\n        hex'444f544e554747c072050010001a003903000000990300eae19911050803010c06010001040404000f05140a112211041102122012021f1f1313060905010e06020001040405000f05160a1809122212041101142014011f1f17';\n\n    bytes sample3 =\n        hex'444f544e5547475295030010001a0038020000009902e100e19909040401010505000001050500000f1300142112211121100010211400130d050601010707000001090900000f140215221002102211221422112210021022150214';\n\n    bytes sample4 =\n        hex'444f544e5547478ca8030010001f004802f85c0f9902fb1a069902ffdb3c990a040401010406000001030300000f01100310021020021020011020302100203021001020021020010f050601010509000001050500000f0110061004102010041020100210203023001020302300102010041020100410061003';\n\n    bytes sampleCollection =\n        hex'444f544e5547472109000d004d444f544e55474753d9020010001a002601000000ff01ffffffff0702030000000711021302110b030500010606000001090900000f2204231020042010230422444f544e554747dc75060010001a0022010000009901ffffffff0301010000000712050302010000071500200010001200';\n\n    constructor() {\n        // collection\n        collection_ = hex'444f544e5547472109000d004d444f544e55474753d9020010001a002601000000ff01ffffffff0702030000000711021302110b030500010606000001090900000f2204231020042010230422444f544e554747dc75060010001a0022010000009901ffffffff0301010000000712050302010000071500200010001200';\n        // base 000000\n        items_.push(\n            hex'444f544e554747c7cc00000e002c00f19325e500eb8a12e500f9b042e500c96619e500a84b1ee500f49f35e52121101000001720fe20ff20fd32fa11fc40f912fb00f80f0f0f0f0f0f0f0f0f0f0e5d0f005130633322520f5030653224500f5031663222500f5031673222500d5131661035500d50336536500d50346535500d50346535500d503111306634500d5034661033500d5035651132500d50346733500d50346a30500d50356a500d50356a500e5032116a500e50341068510e5034116224500f504033601027500f50402032632341500f50412031632341500f522031612341510f025b0f0f0f0f0f0f0f0f0e'\n        );\n\n        items_.push(\n            hex'444f544e554747c072050010001a003903000000990300eae19911050803010c06010001040404000f05140a112211041102122012021f1f1313060905010e06020001040405000f05160a1809122212041101142014011f1f17'\n        );\n\n        items_.push(\n            hex'444f544e5547475295030010001a0038020000009902e100e19909040401010505000001050500000f1300142112211121100010211400130d050601010707000001090900000f140215221002102211221422112210021022150214'\n        );\n        items_.push(\n            hex'444f544e5547478ca8030010001f004802f85c0f9902fb1a069902ffdb3c990a040401010406000001030300000f01100310021020021020011020302100203021001020021020010f050601010509000001050500000f0110061004102010041020100210203023001020302300102010041020100410061003'\n        );\n        // attribute 000000\n    }\n}\n"
    },
    "contracts/interfaces/IDotNuggImplementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title IDotNuggImplementer\n */\ninterface IDotNuggImplementer {\n    // function lockDeployers(address[] calldata deployers) external;\n\n    // function delayedDeployment(bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/INuggWrapped.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport '../erc2981/IERC2981.sol';\n\ninterface INuggWrapped is IERC2981 {}\n"
    },
    "contracts/mock/MockFileResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport '../interfaces/IDotNuggFileResolver.sol';\n\nimport '../erc165/IERC165.sol';\n\nimport '../libraries/Uint.sol';\n\ncontract MockFileResolver is IDotNuggFileResolver {\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return interfaceId == type(IDotNuggFileResolver).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    function resolveFile(IDotNugg.Matrix memory, bytes memory) public pure returns (bytes memory res, string memory fileType) {\n        return (hex'0000', 'dotnugg');\n    }\n}\n"
    },
    "contracts/libraries/Uint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint8 {\n    function toByte(uint8 u) internal pure returns (bytes1 res) {\n        res = bytes1(u);\n    }\n\n    function toString(uint8 u) internal pure returns (string memory res) {\n        res = Uint256.toString(uint256(u));\n    }\n}\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint256 {\n    bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/mock/MockDotNugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport 'hardhat/console.sol';\n\n/**\n * @title Base64\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice library for encoding bytes into base64\n */\nlibrary Base64 {\n    string internal constant _TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    string internal constant _BASE64_PREFIX_JSON = 'data:application/json;base64,';\n    string internal constant _BASE64_PREFIX_DOTNUGG = 'data:image/dotnugg;base64,';\n    string internal constant _BASE64_PREFIX_SVGs = 'data:image/svg+xml;base64,';\n\n    /**\n     * @notice wrapper for _encode for svg data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with json base64 prefix\n     */\n    function encode(bytes memory data, string memory file) internal view returns (string memory) {\n        return string(abi.encodePacked('data:', file, ';base64,', _encode(data)));\n    }\n\n    /**\n     * @notice Encodes some bytes in base64\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes\n     * @dev Credit to Brecht Devos - <brecht@loopring.org> - under MIT license https://github.com/Brechtpd/base64/blob/main/base64.sol\n     * @dev modified for solidity v8\n     */\n    function _encode(bytes memory data) private view returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = _TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary Uint {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal view returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n/**\n * @title DotNugg V1 - onchain encoder/decoder for dotnugg files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract MockDotNugg is IDotNugg {\n    function nuggify(\n        bytes memory,\n        bytes[] memory test,\n        address,\n        string memory name,\n        string memory,\n        uint256 tokenId,\n        bytes32 seed,\n        bytes memory\n    ) public view override returns (string memory image) {\n        console.log('len: ', test.length);\n        image = Base64.encode(\n            bytes(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name,\n                    Uint.toString(tokenId),\n                    '\",\"description\":\"',\n                    Uint.toString(uint256(seed)),\n                    '\", \"image\": \"',\n                    'data:dotnugg;base64,ZG90bnVnZwAhAHEBTwAAAAAAAACZAOrhmUMeDP+oSx7l+bBC5fSfNeXrihLl2FUV//JuEP/ZLQ//+H0j///////xkyXl+lYe//hcD5n8yT7//HVp/5YPA//2dh7/+p1v/5Q3Cf/7GgaZYT8V/8lmGeUAAQAAAQAAAQIBAAEAAQIBAAEAAQEAAQMBAAQFBgUHBAAEBQYFBwQABAUGBQcEAAgFBgUHCQQACAoLBQwGDQwFCw4IAA8KEA4REgwTCxQVFAsOEAoWAAgOCwUMBgwFCw4IAAQLBQYFCwQABAUNBQYFBAAEBQYNBQQABAUGDQUEAAQFBgUEAAQFBgUEAAQFFwYEAAQFFwYMBhcGBAAEBQ0GFwYEAAQFDQYEAAQFDQYHBAAEGAUGDQcEAAQYBwUGBxgEAAQYBwUGBxgEAAQHBQYHGAQAAAQAAAAAAAAAAADW9t8kJdEWBxGPeE1LEDMi8AUkDwFiIPAXIQDQAAIwIAAMAAEAAwAAAAAqAAAkIAANADVADQEQZA0EYDDQVRINBHMNBKANBUUNBQAABQ4CECYOBAgeBBJA8AMAcPAAIzEPAQEzEPIBExHyv/////4=',\n                    '\"}'\n                )\n            ),\n            'json'\n        );\n    }\n}\n"
    },
    "contracts/tests/StakeMath_Test.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/StakeMath.sol';\n\ncontract StakeMath_Test {\n    // function getBalance(StakeMath.State memory state, StakeMath.Position memory pos) external pure returns (uint256 res) {\n    //     res = StakeMath.getBalance(state, pos);\n    // }\n    // function getOwnershipX128(StakeMath.State memory state, StakeMath.Position memory pos) external pure returns (uint256 res) {\n    //     res = StakeMath.getOwnershipX128(state, pos);\n    // }\n    // function applyShareIncrease(\n    //     StakeMath.State memory state,\n    //     StakeMath.Position memory pos,\n    //     uint256 tAmount\n    // ) external pure returns (StakeMath.State memory, StakeMath.Position memory) {\n    //     StakeMath.applyShareIncrease(state, pos, tAmount);\n    //     // console.log(state.tSupply, state.rSupply, pos.rOwned);\n    //     return (state, pos);\n    // }\n    // function applyShareDecrease(\n    //     StakeMath.State memory state,\n    //     StakeMath.Position memory pos,\n    //     uint256 tAmount\n    // ) external pure returns (StakeMath.State memory, StakeMath.Position memory) {\n    //     StakeMath.applyShareDecrease(state, pos, tAmount);\n    //     return (state, pos);\n    // }\n    // function applyRewardIncrease(StakeMath.State memory state, uint256 amount) external pure returns (StakeMath.State memory) {\n    //     StakeMath.applyRewardIncrease(state, amount);\n    //     return (state);\n    // }\n}\n"
    },
    "contracts/tests/StakeMath_Echidna.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/StakeMath.sol';\nimport '../libraries/QuadMath.sol';\nimport './QuadMath_Echidna.sol';\n\ncontract StakeMath_Echidna {\n    using StakeMath for StakeMath.State;\n    using QuadMath for uint256;\n\n    // function checkToRewardFromEps(\n    //     uint256 a,\n    //     uint256 b,\n    //     uint8 c,\n    //     uint256 d,\n    //     uint256 e\n    // ) external pure {\n    //     uint256 shares = a;\n    //     uint256 epsX128 = b;\n    //     uint8 sharesPercent = c;\n    //     uint256 earnings = d;\n    //     uint256 amount = e;\n\n    //     StakeMath.State memory state = StakeMath.State({shares: shares, epsX128: epsX128});\n    //     StakeMath.Position memory pos = StakeMath.Position({shares: shares.percent(c % 100), earnings: earnings});\n\n    //     uint256 z = state.convertSharesToEarnings(pos, amount);\n    //     if (x == 0 || y == 0) {\n    //         assert(z == 0);\n    //         return;\n    //     }\n    //     uint256 d = QuadMath._BINARY128;\n    //     // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n    //     uint256 x2 = QuadMath.mulDiv(z, d, y);\n    //     uint256 y2 = QuadMath.mulDiv(z, d, x);\n    //     assert(x2 >= x);\n    //     assert(y2 >= y);\n    //     assert(x2 - x < d);\n    //     assert(y2 - y < d);\n    // }\n\n    // function checkToEpsFromSupply(uint256 x, uint256 d) external pure {\n    //     require(d > 0);\n    //     uint256 z = StakeMath.toEpsX128FromShares(x, d);\n    //     if (x == 0) {\n    //         assert(z == 0);\n    //         return;\n    //     }\n    //     uint256 y = QuadMath._BINARY128;\n    //     // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n    //     uint256 x2 = QuadMath.mulDiv(z, d, y);\n    //     uint256 y2 = QuadMath.mulDiv(z, d, x);\n    //     assert(x2 <= x);\n    //     assert(y2 <= y);\n    //     assert(x - x2 < d);\n    //     assert(y - y2 < d);\n    // }\n}\n"
    },
    "contracts/tests/QuadMath_Echidna.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/QuadMath.sol';\n\ncontract QuadMath_Echidna {\n    function checkMulDivRounding(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n\n        uint256 ceiled = QuadMath.mulDivRoundingUp(x, y, d);\n        uint256 floored = QuadMath.mulDiv(x, y, d);\n\n        if (mulmod(x, y, d) > 0) {\n            assert(ceiled - floored == 1);\n        } else {\n            assert(ceiled == floored);\n        }\n    }\n\n    function checkMulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDiv(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 <= x);\n        assert(y2 <= y);\n\n        assert(x - x2 < d);\n        assert(y - y2 < d);\n    }\n\n    function checkMulDivRoundingUp(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDivRoundingUp(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 >= x);\n        assert(y2 >= y);\n\n        assert(x2 - x < d);\n        assert(y2 - y < d);\n    }\n}\n"
    },
    "contracts/tests/Stakeable_Echidna.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/QuadMath.sol';\n\ncontract Stakeable_Echidna {\n    function checkMulDivRounding(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n\n        uint256 ceiled = QuadMath.mulDivRoundingUp(x, y, d);\n        uint256 floored = QuadMath.mulDiv(x, y, d);\n\n        if (mulmod(x, y, d) > 0) {\n            assert(ceiled - floored == 1);\n        } else {\n            assert(ceiled == floored);\n        }\n    }\n\n    function checkMulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDiv(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 <= x);\n        assert(y2 <= y);\n\n        assert(x - x2 < d);\n        assert(y - y2 < d);\n    }\n\n    function checkMulDivRoundingUp(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDivRoundingUp(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 >= x);\n        assert(y2 >= y);\n\n        assert(x2 - x < d);\n        assert(y2 - y < d);\n    }\n}\n"
    },
    "contracts/tests/QuadMath_Test.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/QuadMath.sol';\n\ncontract QuadMath_Test {\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) external pure returns (uint256) {\n        return QuadMath.mulDiv(x, y, z);\n    }\n\n    function mulDivRoundingUp(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) external pure returns (uint256) {\n        return QuadMath.mulDivRoundingUp(x, y, z);\n    }\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.8.4;\n\nimport '../erc20/IERC20.sol';\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/mock/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '../interfaces/IWETH9.sol';\n\n// adapted from WBNB on BSC  https://bscscan.com/address/0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c#code\n\ncontract WETH9 {\n    string public name = 'Wrapped ETH';\n    string public symbol = 'WETH';\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    uint256 private constant _MAX_INT = 2**256 - 1;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    fallback() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        address payable sender = payable(msg.sender);\n        sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != _MAX_INT) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/tests/Epochable_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport '../core/Epochable.sol';\n\npragma solidity 0.8.4;\n\ncontract Epochable_Test is Epochable {\n    constructor(uint16 _interval) Epochable(_interval, uint128(block.number)) {}\n}\n"
    },
    "contracts/tests/EpochMath_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/EpochMath.sol';\n\ncontract EpochMath_Test {\n    // function getEpoch(\n    //     EpochMath.State memory state,\n    //     uint256 id,\n    //     uint256 blocknum\n    // ) external pure returns (EpochMath.Epoch memory res) {\n    //     res = EpochMath.getEpoch(state, id, blocknum);\n    // }\n    // function getStatus(\n    //     EpochMath.State memory state,\n    //     uint256 id,\n    //     uint256 blocknum\n    // ) external pure returns (EpochMath.Status res) {\n    //     res = EpochMath.getStatus(state, id, blocknum);\n    // }\n    // function getStartBlockFromId(EpochMath.State memory state, uint256 id) external pure returns (uint256 res) {\n    //     res = EpochMath.getStartBlockFromId(state, id);\n    // }\n    // function getEndBlockFromId(EpochMath.State memory state, uint256 id) external pure returns (uint256 res) {\n    //     res = EpochMath.getEndBlockFromId(state, id);\n    // }\n    // function getIdFromBlocknum(EpochMath.State memory state, uint256 blocknum) external pure returns (uint256 res) {\n    //     res = EpochMath.getIdFromBlocknum(state, blocknum);\n    // }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}