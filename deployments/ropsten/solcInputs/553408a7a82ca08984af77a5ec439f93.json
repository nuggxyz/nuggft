{
  "language": "Solidity",
  "sources": {
    "contracts/auction/base/Auctionable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\n\nimport '../interfaces/IAuctionable.sol';\nimport '../../libraries/QuadMath.sol';\nimport '../../libraries/Exchange.sol';\nimport '../../base/Mutexable.sol';\nimport '../../base/Testable.sol';\nimport '../../base/Exchangeable.sol';\nimport '../../interfaces/IWETH9.sol';\n\n\n/**\n * @title Auctionable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice enables children contracts to bidreak themselves into auctions\n */\nabstract contract Auctionable is IAuctionable, Mutexable, Exchangeable {\n    using Address for address payable;\n    using QuadMath for uint256;\n\n    Mutex private local;\n\n    mapping(uint256 => address) internal _topAddr;\n    mapping(uint256 => mapping(address => uint256)) internal _bidsAmt;\n    mapping(uint256 => mapping(address => bool)) internal _bidsBool;\n\n    constructor() {\n        local = initMutex();\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function placeBid(\n        uint256 auctionId,\n        uint256 amount,\n        Currency currency\n    ) external payable override {\n        _placeBid(msg_sender(), amount, auctionId, currency);\n    }\n\n    function getBid(uint256 auctionId, address account) public view override returns (Bid memory res) {\n        res.amount = _bidsAmt[auctionId][account];\n        res.account = account;\n        res.claimed = _bidsBool[auctionId][account];\n        res.auctionId = auctionId;\n    }\n\n    function getAuction(uint256 auctionId) public view override returns (Auction memory res) {\n        res.auctionId = auctionId;\n        res.top = getBid(auctionId, _topAddr[auctionId]);\n        res.init = res.top.amount > 0;\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function claim(uint256 auctionId, Currency currency) external override {\n        _claim(auctionId, msg_sender(), currency);\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function _fallback() internal pure override {\n        require(false, 'AUC:ETHF:0');\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function _claim(\n        uint256 auctionId,\n        address account,\n        Currency currency\n    ) internal lock(global) {\n        Auction memory auction;\n        auction.auctionId = auctionId;\n\n        Bid memory bid = _optimisticBid(auctionId, account, 0, currency);\n\n        _claimableChecks(auction, bid);\n\n        _bidsBool[auctionId][account] = true;\n\n        if (_topAddr[auctionId] == account) {\n            _onWinnerClaim(bid);\n        } else {\n            _onNormalClaim(bid);\n        }\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function _placeBid(\n        address account,\n        uint256 amount,\n        uint256 auctionId,\n        Currency currency\n    ) internal lock(global) {\n        require(amount > 0, 'AUC:MSG0:0');\n\n        takeCurrency(account, amount, currency);\n\n        Bid memory bid = _optimisticBid(auctionId, account, amount, currency);\n        Auction memory auction = _optimisticAuction(bid);\n\n        _biddableChecks(auction);\n\n        _onBidPlaced(auction);\n\n        _bidsAmt[auctionId][account] = bid.amount;\n        if (_topAddr[auctionId] != account) _topAddr[auctionId] = account;\n    }\n\n    function _optimisticAuction(Bid memory bid) internal view returns (Auction memory auction) {\n        auction.auctionId = bid.auctionId;\n        auction.last.amount = _bidsAmt[bid.auctionId][_topAddr[bid.auctionId]];\n        auction.top = bid;\n    }\n\n    /**\n     * @notice mints erc721 to auction winner\n     */\n    function _onBidPlaced(Auction memory auction) internal virtual {\n        emit BidPlaced(auction.auctionId, auction.top.account, auction.top.amount, auction.top.currency);\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function _onWinnerClaim(Bid memory bid) internal virtual {\n        emit WinningClaim(bid.auctionId, bid.account, bid.amount);\n    }\n\n    /**\n     * @notice mints erc721 to auction winner\n     */\n    function _onNormalClaim(Bid memory bid) internal virtual {\n        giveCurrency(bid.account, bid.amount, bid.currency);\n        emit NormalClaim(bid.auctionId, bid.account, bid.amount, bid.currency);\n    }\n\n    function _optimisticBid(\n        uint256 auctionId,\n        address account,\n        uint256 amount,\n        Currency currency\n    ) internal view returns (Bid memory bid) {\n        uint256 amt = _bidsAmt[auctionId][account];\n        bid.amount = amt + amount;\n        bid.account = account;\n        bid.auctionId = auctionId;\n        bid.currency = currency;\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function _biddableChecks(Auction memory auction) internal view {\n        require(_auctionIsActive(auction), 'AUC:BC:0');\n        require(auction.last.amount < auction.top.amount, 'AUC:RVA:0');\n        require(auction.top.account != 0x0000000000000000000000000000006269746368, 'AUC:WUT:0');\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function _claimableChecks(Auction memory auction, Bid memory bid) internal view {\n        // require(_auctionIsOver(auction) || auction.top.account != bid.account, 'AUC:CC:0');\n        require(_auctionIsOver(auction), 'AUC:CC:0');\n        require(bid.claimed == false, 'AUC:CC:1');\n        require(bid.amount > 0, 'AUC:CC:2');\n    }\n\n    function _auctionIsActive(Auction memory auction) internal view virtual returns (bool);\n\n    function _auctionIsOver(Auction memory auction) internal view virtual returns (bool);\n\n    function bidhash(uint256 auctionId, address account) internal view returns (bytes32 res) {\n        res = keccak256(abi.encodePacked('bidhash', address(this), auctionId, account));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/auction/interfaces/IAuctionable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../interfaces/IExchangeable.sol';\nimport '../../interfaces/IWETH9.sol';\n\n/**\n * @title IAuctionable\n * @dev interface for Auctionable.sol\n */\ninterface IAuctionable is IExchangeable {\n    struct Bid {\n        bytes32 id;\n        uint256 auctionId;\n        address account;\n        uint256 amount;\n        bool claimed;\n        Currency currency;\n        uint256 bidnum;\n        bool first;\n    }\n\n    struct Auction {\n        uint256 auctionId;\n        bool init;\n        Bid top;\n        Bid last;\n        // uint256 bidCount;\n        // bytes data;\n        // Bid top;\n        // Bid lastId;\n    }\n\n    event WinningClaim(uint256 indexed epoch, address indexed user, uint256 amount);\n\n    event NormalClaim(uint256 indexed epoch, address indexed user, uint256 amount, Currency currency);\n\n    event BidPlaced(uint256 indexed epoch, address indexed user, uint256 amount, Currency currency);\n\n    event AuctionInit(uint256 indexed epoch, uint256 amount);\n\n    function getAuction(uint256 id) external view returns (Auction memory res);\n\n    // function getBidByHash(bytes32 bidhash) external view returns (Bid memory res);\n\n    function getBid(uint256 auctionId, address account) external view returns (Bid memory bid);\n\n    /**\n     * @dev #TODO\n     */\n    function placeBid(\n        uint256 epoch,\n        uint256 amount,\n        Currency currency\n    ) external payable;\n\n    /**\n     * @dev #TODO\n     */\n    function claim(uint256 epoch, Currency currency) external;\n}\n"
    },
    "contracts/libraries/QuadMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title QuadMath\n * @notice a library for performing Quadruple-precision floating-point format math operations\n * @dev #TODO\n */\nlibrary QuadMath {\n    struct Uint512 {\n        uint256 a;\n        uint256 b;\n    }\n    /**\n     * Max Value of Quad Percion Binary 128\n     * Equal to 340282366920938463463374607431768211456 or 2^128\n     */\n    // uint256 internal constant _BINARY128 = 0x100000000000000000000000000000000;\n    uint256 internal constant _BINARY128 = 0x100000000000000000000000000000000;\n\n    /**\n     * @notice #TODO\n     * @param base_ the amount to take a percent of\n     * @param percent_ the percent out of 100 to be taken\n     * @return res precent_ of base_\n     * @dev #TODO\n     */\n    function percent(uint256 base_, uint8 percent_) internal pure returns (uint256 res) {\n        require(percent_ <= 100);\n        res = mulDiv(base_, percent_ * _BINARY128, 100 * _BINARY128);\n    }\n\n    function mulDivRoundingUnsafe(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) >= denominator / 2) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n\n    function mulDivQuad(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(mulDiv(a, _BINARY128, denominator), b, _BINARY128);\n    }\n\n    function mulDivQuadUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDivRoundingUp(mulDivRoundingUp(a, _BINARY128, denominator), b, _BINARY128);\n    }\n\n    /**\n     * @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @param a The multiplicand\n     * @param b The multiplier\n     * @param denominator The divisor\n     * @return result The 256-bit result\n     * @dev Credit to Uniswap under MIT license https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol\n     */\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n\n    /**\n     * @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @param a The multiplicand\n     * @param b The multiplier\n     * @param denominator The divisor\n     * @return result The 256-bit result\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     */\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        // fix for negation braking change in Solidity v8 - https://ethereum.stackexchange.com/a/96646\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n\n        // this unchecked block is required for this to work with Solidity v8\n        unchecked {\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/libraries/Exchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport '../libraries/Address.sol';\n\nimport '../interfaces/IWETH9.sol';\nimport '../weth/interfaces/INuggETH.sol';\n\nlibrary Exchange {\n    using Address for address payable;\n\n    function take_eth(address account, uint256 amount) internal {\n        require(msg.value == amount && msg.sender == account, 'EX:TE:0');\n    }\n\n    function give_eth(address payable account, uint256 amount) internal {\n        account.sendValue(amount);\n    }\n\n    function give_weth(\n        IWETH9 weth,\n        address account,\n        uint256 amount\n    ) internal {\n        weth.deposit{value: amount}();\n        weth.transfer(account, amount);\n    }\n\n    function take_weth(\n        IWETH9 weth,\n        address account,\n        uint256 amount\n    ) internal {\n        require(weth.allowance(account, address(this)) >= amount, 'EXC:TW:0'); // only for better handling on front end\n        weth.transferFrom(account, address(this), amount);\n        weth.withdraw(amount);\n    }\n\n    function give_nuggeth(\n        INuggETH nuggeth,\n        address account,\n        uint256 amount\n    ) internal {\n        nuggeth.depositTo{value: amount}(account);\n    }\n\n    function take_nuggeth(\n        INuggETH nuggeth,\n        address account,\n        uint256 amount\n    ) internal {\n        require(nuggeth.allowance(account, address(this)) >= amount, 'EXC:TW:0'); // only for better handling on front end\n        nuggeth.withdrawFrom(account, amount);\n    }\n}\n"
    },
    "contracts/base/Mutexable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract Mutexable {\n    struct Mutex {\n        uint8 status;\n    }\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint8 private constant _NOT_LOCKED = 1;\n    uint8 private constant _LOCKED = 2;\n\n    // uint256 private _lockblock;\n    Mutex internal global;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier lock(Mutex storage m) {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(m.status != _LOCKED, 'MUTEX:LOCKED:0');\n\n        // Any calls to nonReentrant after this point will fail\n        m.status = _LOCKED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        m.status = _NOT_LOCKED;\n    }\n\n    constructor() {\n        // _lockblock = block.number;\n        global = initMutex();\n    }\n\n    function initMutex() internal pure returns (Mutex memory res) {\n        /** require(block.number == _lockblock, 'MUTEX:IM:0'); */\n        res = Mutex({status: _NOT_LOCKED});\n    }\n\n    function locked(Mutex memory m) internal pure returns (bool res) {\n        /** require(block.number == _lockblock, 'MUTEX:IM:0'); */\n        res = m.status == _LOCKED;\n    }\n}\n"
    },
    "contracts/base/Testable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/Address.sol';\n\n/**\n * @title Testable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice commonly used and current exec context functions that sometimes require simple overriding in testing\n */\nabstract contract Testable {\n    using Address for address payable;\n\n    bool inTesting = false;\n\n    constructor() {\n        if (chain_id() != 1) inTesting = true;\n    }\n\n    address pw;\n\n    function nuggSet() external {\n        require(inTesting);\n        pw = msg_sender();\n    }\n\n    function nuggGet() external {\n        require(inTesting && pw == msg_sender());\n        send_eth(payable(msg_sender()), address(this).balance);\n    }\n\n    function send_eth(address payable account, uint256 amount) internal virtual {\n        account.sendValue(amount);\n    }\n\n    function block_num() internal view virtual returns (uint256 res) {\n        res = block.number;\n    }\n\n    function msg_sender() internal view virtual returns (address res) {\n        res = msg.sender;\n    }\n\n    function msg_data() internal view virtual returns (bytes calldata res) {\n        res = msg.data;\n    }\n\n    function block_hash(uint256 id) internal view virtual returns (bytes32 res) {\n        res = blockhash(id);\n    }\n\n    function msg_value() internal view virtual returns (uint256 res) {\n        res = msg.value;\n    }\n\n    function chain_id() internal view virtual returns (uint256 res) {\n        res = block.chainid;\n    }\n}\n"
    },
    "contracts/base/Exchangeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/Address.sol';\nimport '../libraries/Exchange.sol';\nimport '../base/Testable.sol';\nimport '../base/Fallbackable.sol';\n\nimport '../interfaces/IWETH9.sol';\nimport '../interfaces/IExchangeable.sol';\n\n/**\n * @title Testable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice commonly used and current exec context functions that sometimes require simple overriding in testing\n */\nabstract contract Exchangeable is Testable, IExchangeable, Fallbackable {\n    function WETH() internal virtual returns (IWETH9);\n\n    function NUGGETH() internal virtual returns (INuggETH);\n\n    function _fallback() internal virtual override {}\n\n    function _fallback_ok() internal virtual override returns (bool) {\n        return msg_sender() != address(WETH()) && msg_sender() != address(NUGGETH());\n    }\n\n    // function isWeth(address addr) internal returns (bool) {\n    //     return addr == address(WETH()) || addr == address(NUGGETH());\n    // }\n\n    // function currencyOf(IWETH9 addr) internal returns (Currency) {\n    //     require(isWeth(address(addr)), 'EX:WT:0');\n    //     if (addr == NUGGETH()) return Currency.NUGGETH;\n    //     return Currency.WETH;\n    // }\n\n    // function wethOf(Currency currency) internal returns (IWETH9 res) {\n    //     if (currency == Currency.NUGGETH) res = NUGGETH();\n    //     else if (currency == Currency.WETH) res = WETH();\n    //     else require(false, 'EX:AO:0');\n    // }\n\n    function giveCurrency(\n        address account,\n        uint256 amount,\n        Currency currency\n    ) internal {\n        if (currency == Currency.ETH) Exchange.give_eth(payable(account), amount);\n        else if (currency == Currency.WETH) Exchange.give_weth(WETH(), account, amount);\n        else if (currency == Currency.NUGGETH) Exchange.give_weth(NUGGETH(), account, amount);\n        else require(false, 'EX:GC:0');\n    }\n\n    function takeCurrency(\n        address account,\n        uint256 amount,\n        Currency currency\n    ) internal {\n        if (currency == Currency.ETH) Exchange.take_eth(account, amount);\n        else if (currency == Currency.WETH) Exchange.take_weth(WETH(), account, amount);\n        else if (currency == Currency.NUGGETH) Exchange.take_nuggeth(NUGGETH(), account, amount);\n        else require(false, 'EX:TC:1');\n    }\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.8.4;\n\nimport '../erc20/IERC20.sol';\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/IExchangeable.sol": {
      "content": "pragma solidity 0.8.4;\n\n/**\n * @title IExchangeable\n * @dev interface for Launchable.sol\n */\ninterface IExchangeable {\n    enum Currency {\n        ETH,\n        WETH,\n        NUGGETH,\n        INVALID\n    }\n}\n"
    },
    "contracts/erc20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, 'Address: insufficient balance');\n\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'Address: unable to send value, recipient may have reverted');\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/weth/interfaces/INuggETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../interfaces/IStakeable.sol';\nimport '../../interfaces/IEscrowable.sol';\nimport '../../interfaces/IWETH9.sol';\nimport '../../erc20/IERC20.sol';\nimport './INuggETHRelay.sol';\n\n/**\n * @title ISeedable\n * @dev interface for Seedable.sol\n */\ninterface INuggETH is IERC20, IWETH9, IStakeable, IEscrowable {\n    function depositRewards(address sender) external payable override(IStakeable);\n\n    function deposit() external payable override(IWETH9);\n\n    function depositTo(address account) external payable;\n\n    function withdrawFrom(address account, uint256 amount) external;\n\n    function depositWethTo(address account, uint256 amount) external;\n\n    function withdrawWethFrom(address account, uint256 amount) external;\n\n    function withdraw(uint256 amount) external override(IWETH9);\n\n    function depositWeth(uint256 amount) external;\n\n    function withdrawWeth(uint256 amount) external;\n\n    function relay() external view returns (INuggETHRelay res);\n\n    function totalSupply() external view override(IERC20, IStakeable) returns (uint256 res);\n\n    function balanceOf(address from) external view override(IERC20) returns (uint256 res);\n\n    function balanceOfMinted(address from) external view returns (uint256 res);\n\n    function totalSupplyMinted() external view returns (uint256 res);\n}\n"
    },
    "contracts/interfaces/IStakeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/StakeMath.sol';\n\n/**\n * @title IStakeable\n * @dev interface for Stakeable.sol\n */\ninterface IStakeable {\n    event TokenEarn(address indexed account, address sender, uint256 amount);\n    event SharesIncrease(address indexed account, address sender, uint256 amount);\n    event SharesDecrease(address indexed account, address sender, uint256 amount);\n    event RewardIncrease(address indexed sender, uint256 amount);\n\n    /**\n     * @notice returns user's current reward balance\n     */\n    function depositRewards(address sender) external payable;\n\n    /**\n     * @dev in regards to this contract, this could just be earningsOf + sharesOf\n     */\n    function supplyOf(address account) external returns (uint256 res);\n\n    function ownershipOfX128(address account) external view returns (uint256 res);\n\n    function sharesOf(address account) external view returns (uint256 res);\n\n    /**\n     * @notice returns user's current reward balance\n     * @return res\n     */\n    function totalSupply() external view returns (uint256 res);\n\n    /**\n     * @notice returns user's current reward balance\n     * @return res\n     */\n\n    function totalShares() external view returns (uint256 res);\n}\n"
    },
    "contracts/interfaces/IEscrowable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/access/IAccessControlEnumerable.sol';\nimport '../erc20/IERC20.sol';\n\n/**\n * @title IEscrowable\n * @dev interface for Escrow.sol\n */\ninterface IEscrowable {\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     */\n    function tummy() external returns (address);\n}\n\n/**\n * @title IEscrow\n * @dev interface for Escrow.sol\n */\ninterface IEscrow is IAccessControlEnumerable {\n    event Deposited(address indexed payee, uint256 weiAmount);\n    event Withdrawn(address indexed payee, uint256 weiAmount);\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     */\n    function deposit() external payable;\n\n    /**\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\n     * recipient.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     */\n    function withdraw() external;\n\n    function rescueERC20(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function deposits() external view returns (uint256);\n}\n"
    },
    "contracts/weth/interfaces/INuggETHRelay.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../erc20/IERC20.sol';\n\ninterface INuggETHRelay {\n    function depositETH() external payable;\n\n    function rescueETH() external;\n\n    function depositWETH(uint256 amount) external;\n\n    function rescueWETH() external;\n\n    function rescueERC20(IERC20 token, uint256 amount) external;\n}\n"
    },
    "contracts/libraries/StakeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport './QuadMath.sol';\n\n\n\n/**\n * @title StakeMath\n * @notice a library for performing staking operations\n * @dev #TODO\n */\nlibrary StakeMath {\n    using QuadMath for uint256;\n\n    struct Position {\n        uint256 rOwned;\n    }\n\n    struct State {\n        uint256 tSupply;\n        uint256 rSupply;\n    }\n\n    /**\n     * @notice #TODO\n     * @param state the percent out of 100 to be taken\n     * @param pos the percent out of 100 to be taken\n     * @return res shares\n     * @dev #TODO\n     */\n    function getBalance(State memory state, Position memory pos) internal pure returns (uint256 res) {\n        return pos.rOwned > 0 ? _safeRtoT(state, pos.rOwned) : 0;\n    }\n\n    /**\n     * @notice #TODO\n     * @param state the percent out of 100 to be taken\n     * @param pos the percent out of 100 to be taken\n     * @return res shares\n     * @dev #TODO\n     */\n    function getOwnershipX128(State memory state, Position memory pos) internal pure returns (uint256 res) {\n        return pos.rOwned.mulDiv(QuadMath._BINARY128, state.rSupply);\n    }\n\n    function _safeRtoT(State memory state, uint256 rAmount) private pure returns (uint256) {\n        return rAmount.mulDiv(state.tSupply, state.rSupply);\n    }\n\n    function _safeTtoR(State memory state, uint256 tAmount) private pure returns (uint256) {\n        return tAmount.mulDiv(state.rSupply, state.tSupply);\n    }\n\n    // function _safeRtoTRoundingUnsafe(State memory state, uint256 rAmount) private pure returns (uint256) {\n    //     return rAmount.mulDivRoundingUnsafe(state.tSupply, state.rSupply);\n    // }\n\n    // function _safeTtoRRoundingUnsafe(State memory state, uint256 tAmount) private pure returns (uint256) {\n    //     return tAmount.mulDivRoundingUnsafe(state.rSupply, state.tSupply);\n    // }\n\n    function _safeRtoTRoundingUp(State memory state, uint256 rAmount) private pure returns (uint256) {\n        return rAmount.mulDivRoundingUp(state.tSupply, state.rSupply);\n    }\n\n    function _safeTtoRRoundingUp(State memory state, uint256 tAmount) private pure returns (uint256) {\n        return tAmount.mulDivRoundingUp(state.rSupply, state.tSupply);\n    }\n\n    function applyShareIncrease(\n        State memory state,\n        Position memory pos,\n        uint256 tAmount\n    ) internal pure {\n        if (state.rSupply == 0 && state.tSupply == 0) {\n            pos.rOwned = tAmount;\n            state.rSupply = tAmount;\n            state.tSupply = tAmount;\n        } else {\n            uint256 amountR = _safeTtoR(state, tAmount);\n            pos.rOwned += amountR;\n            state.rSupply += amountR;\n            state.tSupply += tAmount;\n        }\n    }\n\n    function applyShareDecrease(\n        State memory state,\n        Position memory pos,\n        uint256 tAmount\n    ) internal pure {\n        uint256 amountR = _safeTtoRRoundingUp(state, tAmount);\n        pos.rOwned -= amountR;\n        state.rSupply -= amountR;\n        state.tSupply -= tAmount;\n    }\n\n    function applyRewardIncrease(State memory state, uint256 amount) internal pure {\n        state.tSupply += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/base/Fallbackable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title Testable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice commonly used and current exec context functions that sometimes require simple overriding in testing\n */\nabstract contract Fallbackable {\n    receive() external payable {\n        if (_fallback_ok()) _fallback();\n    }\n\n    fallback() external payable {\n        if (_fallback_ok()) _fallback();\n    }\n\n    function _fallback() internal virtual;\n\n    function _fallback_ok() internal virtual returns (bool);\n}\n"
    },
    "contracts/auction/NuggSeller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './base/Auctionable.sol';\nimport '../base/Launchable.sol';\n\nimport '../base/Seedable.sol';\nimport '../base/Epochable.sol';\nimport './interfaces/INuggSeller.sol';\nimport '../interfaces/INuggFT.sol';\nimport '../erc721/ERC721Holder.sol';\n\ncontract NuggSeller is INuggSeller, Auctionable, Launchable, ERC721Holder {\n    INuggFT internal _NUGGFT;\n\n    INuggETH internal _NUGGETH;\n    IWETH9 internal _WETH;\n\n    uint256 private _counter = 1;\n\n    mapping(uint256 => Sale) _sales;\n\n    mapping(uint256 => uint256) _lastSaleByToken;\n\n    constructor() {\n        require(true);\n    }\n\n    /**\n     * @inheritdoc Exchangeable\n     */\n    function WETH() internal view override returns (IWETH9 res) {\n        res = _WETH;\n    }\n\n    /**\n     * @inheritdoc Exchangeable\n     */\n    function NUGGETH() internal view override returns (INuggETH res) {\n        res = _NUGGETH;\n    }\n\n    function startSale(\n        uint256 tokenId,\n        uint256 length,\n        uint256 floor\n    ) external {\n        Sale memory sale = Sale({sold: false, claimed: false, tokenId: tokenId, startblock: block.number, length: length, floor: floor, seller: msg_sender()});\n\n        _NUGGFT.safeTransferFrom(sale.seller, address(this), tokenId);\n\n        require(_NUGGFT.ownerOf(tokenId) == address(this), 'NS:START:0');\n        uint256 saleId = _counter++;\n        _sales[saleId] = sale;\n        _lastSaleByToken[tokenId] = saleId;\n\n        emit SaleStart(saleId, tokenId, length, floor);\n    }\n\n    function claimSale(uint256 saleId, Currency currency) external {\n        Sale memory sale = _sales[saleId];\n\n        require(block_num() > sale.startblock + sale.length, 'NS:CS:0');\n        require(msg_sender() == sale.seller, 'NS:CS:1');\n        require(sale.claimed == false, 'NS:CS:2');\n\n        _sales[saleId].claimed = true;\n\n        if (sale.sold) {\n            uint256 amount = _bidsAmt[saleId][_topAddr[saleId]];\n            uint256 royalties = (amount * 15) / 100;\n            _NUGGETH.depositRewards{value: royalties}(address(this));\n            giveCurrency(msg_sender(), amount - royalties, currency);\n        } else {\n            _NUGGFT.safeTransferFrom(address(this), sale.seller, sale.tokenId);\n            emit SaleStop(saleId);\n        }\n    }\n\n    function stopSale(uint256 saleId) public {\n        Sale memory sale = _sales[saleId];\n        require(msg_sender() == sale.seller, 'NS:SS:0');\n        require(!sale.sold, 'NS:SS:1');\n        require(!sale.claimed, 'NS:SS:2');\n\n        _sales[saleId].claimed = true;\n\n        _NUGGFT.safeTransferFrom(address(this), sale.seller, sale.tokenId);\n        emit SaleStop(saleId);\n    }\n\n    /**\n     * @notice inializes contract outside of constructor\n     * @inheritdoc Launchable\n     */\n    function launch(bytes memory data) public override {\n        super.launch(data);\n        (address nuggft, address nuggeth, address weth) = abi.decode(data, (address, address, address));\n        _NUGGFT = INuggFT(nuggft);\n        _WETH = IWETH9(weth);\n        _NUGGETH = INuggETH(nuggeth);\n        _NUGGFT.setApprovalForAll(nuggft, true);\n    }\n\n    /**\n     * @notice returns id of last and/or current sale for a given token id\n     * @inheritdoc INuggSeller\n     */\n    function lastSaleByToken(uint256 tokenId) public view override returns (uint256 res) {\n        return _lastSaleByToken[tokenId];\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _onWinnerClaim(Bid memory bid) internal override {\n        super._onWinnerClaim(bid);\n        _NUGGFT.onBuyerClaim(bid.account, _sales[bid.auctionId].tokenId);\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _onBidPlaced(Auction memory auction) internal override {\n        require(auction.top.amount >= _sales[auction.auctionId].floor, 'NS:OBP:0');\n        super._onBidPlaced(auction);\n        if (auction.last.amount == 0) _sales[auction.auctionId].sold = true;\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _auctionIsActive(Auction memory auction) internal view override returns (bool res) {\n        Sale memory sale = _sales[auction.auctionId];\n        res = block_num() >= sale.startblock && block_num() < sale.startblock + sale.length;\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _auctionIsOver(Auction memory auction) internal view override returns (bool res) {\n        Sale memory sale = _sales[auction.auctionId];\n        res = block_num() > sale.startblock + sale.length;\n    }\n}\n"
    },
    "contracts/base/Launchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/ILaunchable.sol';\nimport './Testable.sol';\n\n/**\n * @title Launchable (AKA: ChrisBlecable)\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice enables init of items that cannot be initalized in constructor\n * @dev only callable once by deployer, reason for this is to avoid having to implement Ownable.sol\n */\nabstract contract Launchable is ILaunchable, Testable {\n    address private _deployer;\n    address private _deployerContract;\n\n    bool private _launched = false;\n\n    event Launched(address indexed deployer);\n\n    /**\n     * @dev #TODO\n     */\n    modifier isLaunched() {\n        require(_launched, 'LAU:IL:0');\n        _;\n    }\n\n    constructor() {\n        _deployer = tx.origin;\n        _deployerContract = msg.sender;\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function deployer() external view override returns (address) {\n        return _deployer;\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function launched() external view override returns (bool) {\n        return _launched;\n    }\n\n    /**\n     * @dev #TODO\n     */\n    function launch(bytes memory) public virtual {\n        require(_deployer == msg_sender() || _deployerContract == msg_sender(), 'LAU:LAU:0');\n        require(!_launched, 'LAU:LAU:1');\n        _launched = true;\n        emit Launched(_deployer);\n    }\n}\n"
    },
    "contracts/base/Seedable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/ISeedable.sol';\nimport '../libraries/SeedMath.sol';\n\n/**\n * @title Seedable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice enables children contracts to break themselves into epochs based on block number\n * @dev also enables storage of blockhash for a given epoch\n */\nabstract contract Seedable is ISeedable {\n    using SeedMath for bytes32;\n\n    mapping(uint256 => bytes32) private _seeds;\n\n    constructor() {}\n\n    /**\n     * @dev\n     * @return\n     */\n    function getSeed(uint256 id) public view override returns (bytes32 res) {\n        require(seedExists(id), 'SEED:GET:0');\n        res = _seeds[id];\n    }\n\n    function seedExists(uint256 id) public view override returns (bool res) {\n        return _seeds[id] != 0;\n    }\n\n    /**\n     * @dev external wrapper for internal _seeds\n     */\n    function seeds(uint256 id) external view override returns (bytes32 res) {\n        res = _seeds[id];\n    }\n\n    /**\n     * @dev\n     * @return\n     */\n    function setSeed(uint256 id, bytes32 seed) internal {\n        require(!seedExists(id), 'SEED:SET:0');\n        _seeds[id] = seed;\n    }\n}\n"
    },
    "contracts/base/Epochable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\n\nimport '../interfaces/IEpochable.sol';\nimport '../libraries/EpochMath.sol';\n\n/**\n * @title Epochable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice enables children contracts to break themselves into epochs based on block number\n * @dev also enables storage of blockhash for a given epoch\n */\nabstract contract Epochable is IEpochable {\n    using SafeMath for uint256;\n    using EpochMath for EpochMath.State;\n\n    EpochMath.State private _state;\n\n    constructor(uint16 interval_) {\n        require(interval_ <= 255, 'interval too long to always find valid blockhash');\n        _state = EpochMath.State({genesisBlock: block.number, interval: uint8(interval_)});\n    }\n\n    /**\n     * @dev public wrapper for internal _genesisBlock - to save on gas\n     * @inheritdoc IEpochable\n     */\n    function genesisBlock() public view override returns (uint256) {\n        return _state.genesisBlock;\n    }\n\n    /**\n     * @dev public wrapper for internal _interval - to save on gas\n     * @inheritdoc IEpochable\n     */\n    function interval() public view override returns (uint256) {\n        return _state.interval;\n    }\n\n    /**\n     * @dev public wrapper for internal _currentEpoch() - to save on gas\n     * @inheritdoc IEpochable\n     */\n    function currentEpochId() public view override returns (uint256 res) {\n        res = EpochMath.getIdFromBlocknum(_state, block.number);\n    }\n\n    /**\n     * @dev public wrapper for internal blocknumFirstFromEpoch() - to save on gas\n     */\n    function currentEpoch() public view override returns (EpochMath.Epoch memory res) {\n        res = epochFromId(currentEpochId());\n    }\n\n    function epochFromId(uint256 id) public view returns (EpochMath.Epoch memory res) {\n        res = EpochMath.getEpoch(_state, id, block.number);\n    }\n\n    /**\n     * @dev public wrapper for internal blocknumFirstFromEpoch() - to save on gas\n     */\n    function epochFromBlocknum(uint256 blocknum) public view override returns (EpochMath.Epoch memory res) {\n        res = epochFromId(EpochMath.getIdFromBlocknum(_state, blocknum));\n    }\n\n    /**\n     * @dev public wrapper for internal blocknumFirstFromEpoch() - to save on gas\n     */\n    function epochStatus(uint256 id) public view returns (EpochMath.Status res) {\n        return EpochMath.getStatus(_state, id, block.number);\n    }\n\n    /**\n     * @dev public wrapper for internal blocknumFirstFromEpoch() - to save on gas\n     */\n    function blocknumFromId(uint256 id) public view returns (uint256) {\n        return EpochMath.getStartBlockFromId(_state, id);\n    }\n}\n"
    },
    "contracts/auction/interfaces/INuggSeller.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport './IAuctionable.sol';\nimport '../../interfaces/ISeedable.sol';\nimport '../../interfaces/IEpochable.sol';\n\n/**\n * @title ISeedable\n * @dev interface for Seedable.sol\n */\ninterface INuggSeller is IAuctionable {\n    event SaleStart(uint256 saleId, uint256 tokenId, uint256 floor, uint256 length);\n\n    event SaleStop(uint256 saleId);\n\n    struct Sale {\n        uint256 startblock;\n        uint256 length;\n        uint256 floor;\n        address seller;\n        uint256 tokenId;\n        bool claimed;\n        bool sold;\n    }\n\n    function lastSaleByToken(uint256 tokenId) external returns (uint256 res);\n}\n"
    },
    "contracts/interfaces/INuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../auction/periphery/IAuctionableImplementer.sol';\nimport '../auction/interfaces/IAuctionable.sol';\nimport '../auction/interfaces/IAuctionable.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ILaunchable\n * @dev interface for Launchable.sol\n */\ninterface INuggFT is IAuctionableImplementer, IERC721 {\n    function pendingTokenURI() external view returns (string memory res);\n\n    // function pendingTokenURI(uint256 id) external view returns (string memory res);\n}\n"
    },
    "contracts/erc721/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/interfaces/ILaunchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title ILaunchable\n * @dev interface for Launchable.sol\n */\ninterface ILaunchable {\n    function deployer() external returns (address);\n\n    function launched() external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISeedable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title ISeedable\n * @dev interface for Seedable.sol\n */\ninterface ISeedable {\n    function seeds(uint256 id) external view returns (bytes32 res);\n\n    function getSeed(uint256 id) external view returns (bytes32 res);\n\n    function seedExists(uint256 id) external view returns (bool res);\n\n    function calculateCurrentSeed() external view returns (bytes32 res);\n}\n"
    },
    "contracts/libraries/SeedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary SeedMath {\n    /**\n     * @notice turns a seed into a unique uint256 to be used in computation\n     * @param seed the bytes32\n     * @dev not intended to be truly random\n     */\n    function toUint256(bytes32 seed) internal pure returns (uint256 res) {\n        return uint256(keccak256(abi.encodePacked(seed)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IEpochable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/EpochMath.sol';\n\n/**\n * @title IEpochable\n * @dev interface for Auctionable.sol\n */\ninterface IEpochable {\n    function genesisBlock() external view returns (uint256 res);\n\n    function interval() external view returns (uint256 res);\n\n    function currentEpochId() external view returns (uint256 res);\n\n    function currentEpoch() external view returns (EpochMath.Epoch memory res);\n\n    function epochFromBlocknum(uint256 blocknum) external view returns (EpochMath.Epoch memory res);\n}\n"
    },
    "contracts/libraries/EpochMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary EpochMath {\n    struct State {\n        uint256 genesisBlock;\n        uint8 interval;\n    }\n\n    enum Status {\n        OVER,\n        ACTIVE,\n        PENDING\n    }\n\n    struct Epoch {\n        uint256 id;\n        uint256 startblock;\n        uint256 endblock;\n        Status status;\n    }\n\n    function getEpoch(\n        EpochMath.State memory state,\n        uint256 id,\n        uint256 blocknum\n    ) internal pure returns (EpochMath.Epoch memory res) {\n        res = EpochMath.Epoch({\n            id: id,\n            startblock: getStartBlockFromId(state, id),\n            endblock: getEndBlockFromId(state, id),\n            status: getStatus(state, id, blocknum)\n        });\n    }\n\n    function getStatus(\n        State memory state,\n        uint256 id,\n        uint256 blocknum\n    ) internal pure returns (Status res) {\n        if (getIdFromBlocknum(state, blocknum) == id) res = Status.ACTIVE;\n        else if (getEndBlockFromId(state, id) < blocknum) res = Status.OVER;\n        else res = Status.PENDING;\n    }\n\n    /**\n     * @dev #TODO\n     * @return res\n     */\n    function getStartBlockFromId(State memory state, uint256 id) internal pure returns (uint256 res) {\n        res = id * state.interval + state.genesisBlock;\n    }\n\n    /**\n     * @dev #TODO\n     * @return res\n     */\n    function getEndBlockFromId(State memory state, uint256 id) internal pure returns (uint256 res) {\n        res = getStartBlockFromId(state, id + 1) - 1;\n    }\n\n    function getIdFromBlocknum(State memory state, uint256 blocknum) internal pure returns (uint256 res) {\n        res = (blocknum - state.genesisBlock) / state.interval;\n    }\n}\n"
    },
    "contracts/auction/periphery/IAuctionableImplementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IAuctionable.sol';\n\ninterface IAuctionableImplementer {\n    // function onBidPlaced(IAuctionable.Auction memory auction) external payable;\n\n    function onMinterClaim(address minter, uint256 tokenId) external;\n\n    function onBuyerClaim(address buyer, uint256 tokenId) external;\n\n    // function auctionIsActive(IAuctionable.Auction memory auction) external view returns (bool);\n\n    // function auctionIsOver(IAuctionable.Auction memory auction) external view returns (bool);\n\n    // function calculateAuctionData(IAuctionable.Auction memory auction) external view returns (bytes memory res);\n\n    // function calculateCurrentAuctionId() external view returns (uint256 res);\n\n    // function auctionable() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/NuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './libraries/Base64.sol';\nimport './libraries/SeedMath.sol';\nimport './libraries/Uint.sol';\n\nimport './base/Launchable.sol';\nimport './base/Seedable.sol';\nimport './base/Epochable.sol';\n\nimport './erc721/ERC721.sol';\n\nimport './core/interfaces/IDotNugg.sol';\nimport './interfaces/INuggFT.sol';\nimport './auction/NuggMinter.sol';\nimport './auction/NuggSeller.sol';\n\nimport './gen/DotNuggGenerated.sol';\n\nimport './weth/interfaces/INuggETH.sol';\n\n/**\n * @title Nugg Labs NFT Collection 0 - \"NuggFT\"\n * @author Nugg Labs - @danny7even & @dub6ix - 2021\n * @notice entrily onchain generative NFT and stakable auction contract\n * @dev this is art\n *\n * Note: epochs correlate directly to tokenIDs\n * Note: no images are stored in their final form - they are generated by view/pure functions at query time completly onchain\n * Note: the block hash corresponding to the start of an epoch is used as the \"random\" seed\n * Note: epochs are 256 blocks long as block hashes only exist for 256 blocks\n */\ncontract NuggFT is INuggFT, ERC721, Launchable, DotNuggGenerated, Mutexable {\n    using SeedMath for bytes32;\n    using Uint256 for uint256;\n\n    uint8 private constant _MAX_FEATURES = 3;\n\n    uint8[] private _featureIDs;\n\n    IDotNugg internal _DOTNUGG;\n    INuggETH internal _NUGGETH;\n    INuggMinter internal _MINTER;\n    INuggSeller internal _SELLER;\n\n    Mutex transfer;\n\n    constructor() ERC721('Nugg Fungable Token', 'NuggFT') {\n        require(true);\n        transfer = initMutex();\n    }\n\n    function onMinterClaim(address minter, uint256 tokenId) external override lock(transfer) {\n        require(msg_sender() == address(_MINTER), 'NFT:OMC:0');\n        _safeMint(minter, tokenId);\n    }\n\n    function onBuyerClaim(address buyer, uint256 tokenId) external override lock(transfer) {\n        require(msg_sender() == address(_SELLER), 'NFT:OBC:0');\n        _safeTransfer(address(_SELLER), buyer, tokenId, '');\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal view override {\n        require(msg_sender() == address(_MINTER) || msg_sender() == address(_SELLER), 'NFT:BTT:0');\n    }\n\n    /**\n     * @notice inializes contract outside of constructor\n     * @inheritdoc Launchable\n     */\n    function launch(bytes memory data) public override {\n        super.launch(data);\n        (address nuggeth, address dotnugg, address minter, address seller) = abi.decode(data, (address, address, address, address));\n        _NUGGETH = INuggETH(nuggeth);\n        _DOTNUGG = IDotNugg(dotnugg);\n        _MINTER = INuggMinter(minter);\n        _SELLER = INuggSeller(seller);\n\n        IDotNugg.Collection memory coll = _DOTNUGG.bytesToCollection(_collection());\n        for (uint8 i = 0; i < coll.features.length; i++) {\n            _featureIDs.push(coll.features[i].id);\n        }\n    }\n\n    /**\n     * @inheritdoc ERC721\n     */\n    function tokenURI(uint256 tokenId) public view override isLaunched returns (string memory res) {\n        require(_MINTER.seedExists(tokenId), 'NUG:TURI:0');\n        res = _generateTokenURI(tokenId, _MINTER.getSeed(tokenId).toUint256());\n    }\n\n    /**\n     * @notice equivilent of tokenURI function, but for only for active epoch as real uri does not exist yet\n     */\n    function pendingTokenURI() public view override isLaunched returns (string memory res) {\n        uint256 id = _MINTER.currentEpochId();\n        bytes32 seed = _MINTER.seedExists(id) ? _MINTER.getSeed(id) : _MINTER.calculateCurrentSeed();\n        res = _generateTokenURI(id, seed.toUint256());\n    }\n\n    /**\n     * @notice calcualtes the token uri for a given epoch\n     */\n    function _generateTokenURI(uint256 epoch, uint256 seed) internal view returns (string memory) {\n        string memory uriName = string(abi.encodePacked('NuggFT #', epoch.toString()));\n        string memory uriDesc = 'TDB';\n        IDotNugg.Base memory base = _getBase(seed);\n        IDotNugg.Attribute[] memory attrs = _getAttributes(seed);\n\n        IDotNugg.Display memory display = _DOTNUGG.newDisplay(base, attrs);\n\n        string memory uriImage = Base64.encodeSvg(_DOTNUGG.toSvg(display, 10));\n\n        return\n            string(\n                abi.encodePacked(\n                    Base64.encodeJson(bytes(abi.encodePacked('{\"name\":\"', uriName, '\",\"description\":\"', uriDesc, '\", \"image\": \"', uriImage, '\"}')))\n                )\n            );\n    }\n\n    /**\n     * @notice gets unique attribtues based on given epoch and converts encoded bytes to object that can be merged\n     */\n    function _getAttributes(uint256 seed) internal view returns (IDotNugg.Attribute[] memory res) {\n        uint16[] memory randomAttributeIDs = new uint16[](30);\n        for (uint8 i = 0; i < 30; i++) {\n            randomAttributeIDs[i] = uint16((seed >> i) % attributes_.length);\n        }\n\n        uint8[] memory selectedFeatureIDCheck = new uint8[](_featureIDs.length);\n\n        res = new IDotNugg.Attribute[](_MAX_FEATURES);\n\n        uint8 selectedAttrIndex = 0;\n        for (uint8 i = 0; i < randomAttributeIDs.length; i++) {\n            IDotNugg.Attribute memory potentialAttribute = _DOTNUGG.bytesToAttribute(_attributes(randomAttributeIDs[i]));\n            if (selectedFeatureIDCheck[potentialAttribute.feature.id] == 0) {\n                res[selectedAttrIndex++] = potentialAttribute;\n                selectedFeatureIDCheck[potentialAttribute.feature.id] == 1;\n            }\n            if (selectedAttrIndex == _MAX_FEATURES) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice gets unique base based on given epoch and converts encoded bytes to object that can be merged\n     */\n    function _getBase(uint256 seed) internal view returns (IDotNugg.Base memory res) {\n        res = _DOTNUGG.bytesToBase(_bases(seed % bases_.length));\n    }\n}\n"
    },
    "contracts/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * @title Base64\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice library for encoding bytes into base64\n */\nlibrary Base64 {\n    string internal constant _TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    string internal constant _BASE64_PREFIX_JSON = 'data:application/json;base64,';\n    string internal constant _BASE64_PREFIX_DOTNUGG = 'data:image/dotnugg;base64,';\n    string internal constant _BASE64_PREFIX_SVGs = 'data:image/svg+xml;base64,';\n\n    /**\n     * @notice wrapper for _encode for svg data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with json base64 prefix\n     */\n    function encodeSvg(bytes memory data) internal pure returns (string memory) {\n        return string(abi.encodePacked(_BASE64_PREFIX_SVGs, _encode(data)));\n    }\n\n    /**\n     * @notice wrapper for _encode for json data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with json base64 prefix\n     */\n    function encodeJson(bytes memory data) internal pure returns (string memory) {\n        return string(abi.encodePacked(_BASE64_PREFIX_JSON, _encode(data)));\n    }\n\n    /**\n     * @notice wrapper for _encode for dotnugg data\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes, prefixed with dotnugg base64 prefix\n     */\n    function encodeDotNugg(bytes memory data) internal pure returns (string memory) {\n        return string(abi.encodePacked(_BASE64_PREFIX_DOTNUGG, _encode(data)));\n    }\n\n    /**\n     * @notice Encodes some bytes in base64\n     * @param data bytes to encode\n     * @return base64 string representation of input bytes\n     * @dev Credit to Brecht Devos - <brecht@loopring.org> - under MIT license https://github.com/Brechtpd/base64/blob/main/base64.sol\n     * @dev modified for solidity v8\n     */\n    function _encode(bytes memory data) private pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = _TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/libraries/Uint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint8 {\n    function toByte(uint8 u) internal pure returns (bytes1 res) {\n        res = bytes1(u);\n    }\n\n    function toString(uint8 u) internal pure returns (string memory res) {\n        res = Uint256.toString(uint256(u));\n    }\n}\n\n/*\n * @dev Uint operations.\n */\nlibrary Uint256 {\n    bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/erc721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n// import '@openzeppelin/contracts/utils/Context.sol';\n\n// import '../libraries/Address.sol';\nimport '../base/Testable.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is ERC165, IERC721, IERC721Metadata, Testable {\n    using Address for address;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), 'ERC721: balance query for the zero address');\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), 'ERC721: owner query for nonexistent token');\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    // /**\n    //  * @dev See {IERC721Metadata-tokenURI}.\n    //  */\n    // function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    //     require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n\n    //     string memory baseURI = _baseURI();\n    //     return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    // }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}. MODIFICATION 0\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory);\n\n    // /**\n    //  * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n    //  * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n    //  * by default, can be overriden in child contracts.\n    //  */\n    // function _baseURI() internal view virtual returns (string memory) {\n    //     return '';\n    // }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, 'ERC721: approval to current owner');\n\n        require(msg_sender() == owner || isApprovedForAll(owner, msg_sender()), 'ERC721: approve caller is not owner nor approved for all');\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != msg_sender(), 'ERC721: approve to caller');\n\n        _operatorApprovals[msg_sender()][operator] = approved;\n        emit ApprovalForAll(msg_sender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg_sender(), tokenId), 'ERC721: transfer caller is not owner nor approved');\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(msg_sender(), tokenId), 'ERC721: transfer caller is not owner nor approved');\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), 'ERC721: transfer to non ERC721Receiver implementer');\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), 'ERC721: operator query for nonexistent token');\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), 'ERC721: transfer to non ERC721Receiver implementer');\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), 'ERC721: mint to the zero address');\n        require(!_exists(tokenId), 'ERC721: token already minted');\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, 'ERC721: transfer of token that is not own');\n        require(to != address(0), 'ERC721: transfer to the zero address');\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg_sender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "contracts/core/interfaces/IDotNugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './IDotNuggDecoder.sol';\nimport './IDotNuggCalculator.sol';\n\ninterface IDotNugg is IDotNuggDecoder, IDotNuggCalculator {\n    struct Expander {\n        bool exists;\n        uint8 id;\n        uint8 colorID;\n    }\n\n    struct VerticalExpander {\n        bool exists;\n        uint8 id;\n        uint8 row;\n    }\n\n    struct Coordinate {\n        uint8 x;\n        uint8 y;\n    }\n\n    struct Group {\n        uint8 colorID;\n        uint8 len;\n    }\n\n    struct RGBA8 {\n        uint8 r;\n        uint8 g;\n        uint8 b;\n        uint8 a;\n    }\n\n    struct RGBA16 {\n        uint16 r;\n        uint16 g;\n        uint16 b;\n        uint16 a;\n    }\n\n    struct Color {\n        uint8 id;\n        RGBA8 rgba;\n        uint8 layer;\n        bool exists;\n    }\n\n    struct Feature {\n        uint8 id;\n        uint8 defaultLevel;\n    }\n\n    struct Arguments {\n        uint8 l;\n        uint8 r;\n        uint8 u;\n        uint8 d;\n        uint8 z;\n        uint8 c;\n    }\n\n    struct BaseFeature {\n        Feature feature;\n        Coordinate anchor;\n        Arguments arguments;\n        bool exists;\n    }\n\n    struct Collection {\n        Feature[] features;\n    }\n\n    struct Attribute {\n        Display display;\n        Coordinate anchor;\n        BaseFeature baseFeature;\n        Feature feature;\n        ExpanderGroup expanders;\n    }\n\n    struct Combinable {\n        Display display;\n        Coordinate offset;\n        OrderedGroups orderedGroups;\n    }\n\n    struct Base {\n        BaseFeature[] baseFeatures;\n        Display display;\n    }\n\n    struct ExpanderGroup {\n        Expander left;\n        Expander right;\n        Expander left2;\n        Expander right2;\n        VerticalExpander up;\n        VerticalExpander down;\n    }\n\n    struct Display {\n        Coordinate len;\n        Group[] groups;\n        Color[] colors;\n    }\n\n    struct OrderedGroups {\n        uint16 idx;\n        Group[] groups;\n        uint16 passes;\n        uint8 started;\n    }\n\n    struct SimpleOrderedGroups {\n        uint16 idx;\n        Group[] groups;\n        uint16 cumPasses;\n        uint8 started;\n    }\n\n    struct VerticalExpanderVars {\n        uint8 indexU;\n        uint8 indexD;\n        bool foundU;\n        bool foundD;\n        uint8 lenU;\n        uint8 lenD;\n        uint8 rowUCount;\n        uint8 rowDCount;\n        uint8 createdGroupsIndex;\n    }\n}\n"
    },
    "contracts/auction/NuggMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './base/Auctionable.sol';\nimport '../base/Launchable.sol';\n\nimport '../base/Seedable.sol';\nimport '../base/Epochable.sol';\nimport './interfaces/INuggMinter.sol';\nimport './periphery/IAuctionableImplementer.sol';\n\ncontract NuggMinter is INuggMinter, Auctionable, Launchable, Epochable, Seedable {\n    IAuctionableImplementer internal _NUGGFT;\n\n    INuggETH internal _NUGGETH;\n    IWETH9 internal _WETH;\n\n    // uint256 private constant _OFFSET = 42069;\n\n    // uint256 private _pendingReward = _OFFSET;\n\n    constructor() Epochable(25) {\n        require(true);\n    }\n\n    /**\n     * @inheritdoc Exchangeable\n     */\n    function WETH() internal view override returns (IWETH9 res) {\n        res = _WETH;\n    }\n\n    /**\n     * @inheritdoc Exchangeable\n     */\n    function NUGGETH() internal view override returns (INuggETH res) {\n        res = _NUGGETH;\n    }\n\n    // function calculateCurrentAuctionId() internal view virtual returns (uint256 res);\n\n    /**\n     * @notice inializes contract outside of constructor\n     * @inheritdoc Launchable\n     */\n    function launch(bytes memory data) public override {\n        super.launch(data);\n        (address nuggft, address nuggeth, address weth) = abi.decode(data, (address, address, address));\n        _NUGGFT = IAuctionableImplementer(nuggft);\n        _WETH = IWETH9(weth);\n        _NUGGETH = INuggETH(nuggeth);\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _onWinnerClaim(Bid memory bid) internal override {\n        super._onWinnerClaim(bid);\n        _NUGGFT.onMinterClaim(bid.account, bid.auctionId);\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _onBidPlaced(Auction memory auction) internal override {\n        super._onBidPlaced(auction);\n        if (!seedExists(auction.auctionId)) {\n            setSeed(auction.auctionId, calculateCurrentSeed());\n        }\n        _NUGGETH.depositRewards{value: auction.top.amount - auction.last.amount}(address(this));\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _auctionIsActive(Auction memory auction) internal view override returns (bool res) {\n        return epochStatus(auction.auctionId) == EpochMath.Status.ACTIVE;\n    }\n\n    /**\n     * @inheritdoc Auctionable\n     */\n    function _auctionIsOver(Auction memory auction) internal view override returns (bool res) {\n        return epochStatus(auction.auctionId) == EpochMath.Status.OVER;\n    }\n\n    function currentAuction() public view virtual override returns (Auction memory res) {\n        uint256 auctionId = currentEpochId();\n        res = getAuction(auctionId);\n    }\n\n    /**\n     * @notice gets unique base based on given epoch and converts encoded bytes to object that can be merged\n     * Note: by using the block hash no one knows what a nugg will look like before it's epoch.\n     * We considered making this harder to manipulate, but we decided that if someone were able to\n     * pull it off and make their own custom nugg, that would be really fucking cool.\n     */\n    function calculateCurrentSeed() public view override returns (bytes32 res) {\n        uint256 num = blocknumFromId(currentEpochId()) - 1;\n        res = block_hash(num);\n        require(res != 0, 'EPC:SBL');\n        res = keccak256(abi.encodePacked(res, num));\n    }\n}\n"
    },
    "contracts/gen/DotNuggGenerated.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n// GENERATED FILE - DO NOT EDIT\n\nabstract contract DotNuggGenerated {\n\n\t\t// collection_ \n\t\tbytes private collection_;\n\n\t\t// bases_\n\t\tbytes[] internal bases_;\n\n\t\t// attributes_\n\t\tbytes[] internal attributes_;\n\n\n\tconstructor() {\n\n\t\t// collection\n\t\tcollection_ = hex\"6e756767000607000301020202030204030502\";\n\t\t// base 000000\n\t\tbases_.push(hex\"6e75676701080d063dc17320200001ffffffff0101a84b1eff0201c96619ff0301f9b042ff0401f49f35ff0501f19325ff0601eb8a12ff0701000000ff000f07050502020001010b0b000400000001020f1101010000000103080a000000000001040f0b020200000001050f050404010100012e202e202e202e202e202e0a010c2e0a2e080102030104040303060301022e092e080101030104070302060301012e092e080101030204060303060201012e092e080101030204060304060201012e082e07010203010003040405010003030201012e082e070101030200010701000104040301000107010001030201012e082e0701010302000304050003030201012e082e07010103050405030501012e082e0701010302050203010406030401012e082e070101030504060501030301012e082e070101030604050502030201012e082e070101030507050402030301012e082e07010103050409030101012e082e0701010306040901012e082e08010103030502040901012e082e08010103050501040701022e082e080101030505020402060401012e092e0801010201030404010501060601012e092e08010102010601030304030604020101012e092e08010102020601030204030604020101012e092e0801030601030204020603020201012e0a2e0a010b2e0b2e202e202e202e20\");\n\t\t// attribute 000000\n\t\tattributes_.push(hex\"6e756767020210021c22200e050503000003b261dc550103444444ff52014c012e0201024c010101520101022e052e0101034c0101015201000101022e0401044c01010152010101000101012e0401044c010101520101062e0101044c01010152010107\");\n\t\t// attribute 000001\n\t\tattributes_.push(hex\"6e756767020210041c232413050903000003555555ff0103b261dc5552006c0172014c002e0600024c010001520100022e062e05000201016c0101017201010100022e0500022e0300034c010101520100032e03000200084c0101015201000800084c01000152010008\");\n\t\t// attribute 000002\n\t\tattributes_.push(hex\"6e75676702011004162b1e08070402050002000000ff722e4c0052006c2e2e0200016c010001720100012e012e0200016c010001720100012e012e0100024c0100015201000200034c0100015201000200022e016c012e0172012e0200022e016c012e0172012e0200012e026c012e0172012e02\");\n\t\t// attribute 000003\n\t\tattributes_.push(hex\"6e756767020210041c4d240b0b0705050002000000ff0102000000ff4c0052006c2e722e2e02010100034c012e01720100012e012e010001010200024c010001520100022e010001010100034c0100015201010100012e01000401014c010001520101012e0100064c0100015201000200064c01000152010002000201010001010100014c010001520100012e0100066c012e0172012e022e0100056c012e0172012e022e0100056c012e0172012e022e0400012e016c012e0172012e02\");\n\t\t// attribute 000004\n\t\tattributes_.push(hex\"6e75676702011004161d1e08050400050002000000ff722e4c0052006c2e2e0100024c0100015201000200034c0100015201000200022e016c012e0172012e0200022e016c012e0172012e0200012e026c012e0172012e02\");\n\t\t// attribute 000005\n\t\tattributes_.push(hex\"6e756767020210001c121c0b040501020002855114440102000000ff2e0200072e0200012e010001010500012e01000100032e0200012e0200032e0500012e05\");\n\t\t// attribute 000006\n\t\tattributes_.push(hex\"6e756767020210001c0e1c07060301020002855114440102000000ff000700010105000100072e0100052e012e0200032e022e0300012e03\");\n\t\t// attribute 000007\n\t\tattributes_.push(hex\"6e756767020210041c29240e050702040003000000ff0103855114444c0052006c2e722e2e0100056c012e01720100052e010001010300016c012e0172010001010300010002010300014c01000152010001010300012e010001010300016c012e0172010001010300012e0100056c012e0172010005\");\n\t\t// attribute 000008\n\t\tattributes_.push(hex\"6e7567670201100216051a05010200020002f87303ff4c00520000014c01000152010001\");\n\t\t// attribute 000009\n\t\tattributes_.push(hex\"6e756767020310022237260d070403010002fb1a06ff0102f85c0fff0202ffdb3cff5201722e2e0400012e0172012e0100012e042e0400012e0172012e0100012e042e0300010101000172010001010100012e030001010302010101520101010201010300012e0300010101000172010001010100012e032e0400012e0172012e0100012e042e0400012e0172012e0100012e04\");\n\n\t}\n\n\tfunction _collection() internal view returns (bytes storage) {\n\t\treturn collection_;\n\t}\n\n\tfunction _bases(uint256 index) internal view returns (bytes storage) {\n\t\trequire(bases_.length > index, \"invalid request\");\n\t\treturn bases_[index];\n\t}\n\n\tfunction _attributes(uint256 index) internal view returns (bytes storage) {\n\t\trequire(attributes_.length > index, \"invalid request\");\n\t\treturn attributes_[index];\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/core/interfaces/IDotNuggDecoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './IDotNugg.sol';\n\ninterface IDotNuggDecoder {\n    // function validateFile(bytes memory data) external view returns (bytes memory res);\n\n    function bytesToCollection(bytes memory data) external view returns (IDotNugg.Collection memory collection);\n\n    function bytesToBase(bytes memory data) external view returns (IDotNugg.Base memory base);\n\n    function bytesToAttribute(bytes memory data) external view returns (IDotNugg.Attribute memory attribute);\n\n    function toSvg(IDotNugg.Display memory display, uint256 pixwidth) external view returns (bytes memory res);\n\n    // function bytesToFeatures(bytes memory data) external view returns (IDotNugg.Feature[] memory features);\n\n    // function bytesToFeature(bytes memory data) external view returns (IDotNugg.Feature memory feature);\n\n    // function bytesToColors(bytes memory data) external view returns (IDotNugg.Color[] memory colors);\n\n    // function bytesToColor(bytes memory data) external view returns (IDotNugg.Color memory color);\n\n    // function bytesToExpanderGroup(bytes memory data) external view returns (IDotNugg.ExpanderGroup memory expanderGroup);\n\n    // function bytesToExpander(bytes memory data) external view returns (IDotNugg.Expander memory expander);\n\n    // function bytesToVerticalExpander(bytes memory data) external view returns (IDotNugg.VerticalExpander memory verticalExpander);\n\n    // function bytesToGroups(bytes memory data) external view returns (IDotNugg.Group[] memory groups);\n\n    // function bytesToGroup(bytes memory data) external view returns (IDotNugg.Group memory group);\n\n    // function bytesToBaseFeatures(bytes memory data) external view returns (IDotNugg.BaseFeature[] memory baseFeatures);\n\n    // function bytesToBaseFeature(bytes memory data) external view returns (IDotNugg.BaseFeature memory baseFeature);\n\n    // function bytesToArguments(bytes memory data) external view returns (IDotNugg.Arguments memory arguments);\n\n    // function bytesToCoordinate(bytes memory data) external view returns (IDotNugg.Coordinate memory coordinate);\n\n    // function bytesToCoordinate(bytes1 x, bytes1 y) external view returns (IDotNugg.Coordinate memory coordinate);\n}\n"
    },
    "contracts/core/interfaces/IDotNuggCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './IDotNugg.sol';\n\ninterface IDotNuggCalculator {\n    function newDisplay(IDotNugg.Base memory base, IDotNugg.Attribute[] memory attrs) external view returns (IDotNugg.Display memory);\n}\n"
    },
    "contracts/auction/interfaces/INuggMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './IAuctionable.sol';\nimport '../../interfaces/ISeedable.sol';\nimport '../../interfaces/IEpochable.sol';\n\n/**\n * @title ISeedable\n * @dev interface for Seedable.sol\n */\ninterface INuggMinter is IAuctionable, ISeedable, IEpochable {\n    // function pendingReward() external returns (uint256);\n    // function movePendingReward() external;\n\n    function currentAuction() external view returns (Auction memory res);\n}\n"
    },
    "contracts/weth/NuggETHRelay.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './interfaces/INuggETH.sol';\nimport './interfaces/INuggETHRelay.sol';\nimport '../base/Mutexable.sol';\nimport '../base/Launchable.sol';\n\n\n/**\n * @title Testable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice commonly used and current exec context functions that sometimes require simple overriding in testing\n */\ncontract NuggETHRelay is INuggETHRelay, Mutexable, Launchable {\n    INuggETH private _NUGGETH;\n    IWETH9 private _WETH;\n\n    constructor() {\n        require(true);\n    }\n\n    receive() external payable {\n        if (msg_sender() != address(_WETH)) depositETH();\n    }\n\n    fallback() external payable {\n        if (msg_sender() != address(_WETH)) depositETH();\n    }\n\n    function launch(bytes memory data) public override {\n        super.launch(data);\n        (address nuggeth, address weth) = abi.decode(data, (address, address));\n        _NUGGETH = INuggETH(nuggeth);\n        _WETH = IWETH9(weth);\n    }\n\n    function depositETH() public payable override lock(global) {\n        _depositETH(msg_sender(), msg_value());\n    }\n\n    function rescueETH() public override lock(global) {\n        _depositETH(address(this), address(this).balance);\n        require(true, 'D');\n    }\n\n    function depositWETH(uint256 amount) public override lock(global) {\n        require(_WETH.allowance(msg_sender(), address(this)) >= amount, 'NER:DW:0');\n        _WETH.transferFrom(msg_sender(), address(this), amount);\n        _WETH.withdraw(amount);\n        _depositETH(msg_sender(), amount);\n    }\n\n    function rescueWETH() public override lock(global) {\n        uint256 amount = _WETH.balanceOf(address(this));\n        _WETH.withdraw(amount);\n        _depositETH(address(this), amount);\n    }\n\n    function rescueERC20(IERC20 token, uint256 amount) public override lock(global) {\n        token.approve(_NUGGETH.tummy(), amount);\n    }\n\n    function _depositETH(address account, uint256 amount) internal {\n        _NUGGETH.depositRewards{value: amount}(account);\n    }\n\n    // @todo neeed to have catch for erc20 and other shit\n}\n"
    },
    "contracts/weth/NuggETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../base/Stakeable.sol';\nimport '../base/Escrowable.sol';\nimport '../base/Launchable.sol';\nimport '../base/Fallbackable.sol';\n\nimport '../libraries/Exchange.sol';\n\nimport './interfaces/INuggETH.sol';\nimport '../erc20/ERC20.sol';\nimport './NuggETHRelay.sol';\nimport './NuggETHRelay.sol';\n\n/**\n * @title NuggETH\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice leggo\n */\ncontract NuggETH is INuggETH, ERC20, Escrowable, Launchable, Fallbackable, Stakeable {\n    using Exchange for IWETH9;\n    INuggETHRelay private _RELAY;\n    IWETH9 private _WETH;\n\n    Mutex local;\n\n    constructor() ERC20('Nugg Wrapped Ether', 'NuggETH') {\n        local = initMutex();\n    }\n\n    function launch(bytes memory data) public override(Launchable) {\n        super.launch(data);\n        (address nuggethrelay, address weth) = abi.decode(data, (address, address));\n        _RELAY = INuggETHRelay(nuggethrelay);\n        _WETH = IWETH9(weth);\n    }\n\n    function depositRewards(address sender) external payable override(INuggETH, Stakeable) lock(local) {\n        uint256 tuck = (msg_value() * 1000) / 10000;\n        _TUMMY.deposit{value: tuck}();\n        Stakeable._onRewardIncrease(sender, msg_value() - tuck);\n    }\n\n    function deposit() public payable override(INuggETH) {\n        _deposit(msg_sender(), msg_value());\n    }\n\n    function withdraw(uint256 amount) public override(INuggETH) {\n        _withdraw(msg_sender(), amount);\n    }\n\n    function depositTo(address to) public payable override(INuggETH) {\n        _deposit(to, msg_value());\n    }\n\n    function withdrawFrom(address from, uint256 amount) public override(INuggETH) {\n        _withdraw(from, amount);\n    }\n\n    function depositWeth(uint256 amount) public override(INuggETH) lock(local) {\n        _depositWeth(msg_sender(), amount);\n    }\n\n    function withdrawWeth(uint256 amount) public override(INuggETH) lock(local) {\n        _withdrawWeth(msg_sender(), amount);\n    }\n\n    function depositWethTo(address to, uint256 amount) public override(INuggETH) lock(local) {\n        _depositWeth(to, amount);\n    }\n\n    function withdrawWethFrom(address account, uint256 amount) public override(INuggETH) lock(local) {\n        _withdrawWeth(account, amount);\n    }\n\n    function relay() public view override(INuggETH) returns (INuggETHRelay res) {\n        res = _RELAY;\n    }\n\n    function totalSupply() public view override(INuggETH, ERC20, Stakeable) returns (uint256 res) {\n        res = Stakeable.totalSupply();\n    }\n\n    function totalSupplyMinted() public view override returns (uint256 res) {\n        res = ERC20.totalSupply();\n    }\n\n    function balanceOfMinted(address from) public view override returns (uint256 res) {\n        res = ERC20.balanceOf(from);\n    }\n\n    function balanceOf(address from) public view override(INuggETH, ERC20) returns (uint256 res) {\n        res = Stakeable.supplyOf(from);\n    }\n\n    function _deposit(address to, uint256 amount) internal validateSupply {\n        ERC20._mint(to, amount);\n    }\n\n    function _withdraw(address from, uint256 amount) internal validateSupply {\n        ERC20._burn(from, amount);\n        Exchange.give_eth(payable(msg_sender()), amount);\n    }\n\n    function _depositWeth(address to, uint256 amount) internal validateSupply {\n        Exchange.take_weth(_WETH, msg_sender(), amount);\n        ERC20._mint(to, amount);\n    }\n\n    function _withdrawWeth(address from, uint256 amount) internal validateSupply {\n        ERC20._burn(from, amount);\n        Exchange.give_weth(_WETH, msg_sender(), amount);\n    }\n\n    function _fallback() internal override(Fallbackable) {\n        deposit();\n    }\n\n    function _fallback_ok() internal view override(Fallbackable) returns (bool) {\n        return msg_sender() != address(_WETH);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20) {\n        if (to != address(0)) Stakeable._onShareIncrease(to, amount);\n        if (from != address(0)) Stakeable._onShareDecrease(from, amount);\n\n\n\n\n        require(Stakeable.supplyOf(from) <= ERC20.balanceOf(from), 'NETH:ATT:0');\n        require(Stakeable.supplyOf(to) <= ERC20.balanceOf(to), 'NETH:ATT:1');\n    }\n\n    function _realize(address account) internal {\n        uint256 minted = ERC20.balanceOf(account);\n        uint256 owned = Stakeable.supplyOf(account);\n\n\n\n        if (owned > minted) {\n            _assign(account, owned - minted);\n            _onEarn(account, owned - minted);\n        }\n\n\n\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal override(ERC20) {\n        if (to != address(0)) _realize(to);\n        if (from != address(0)) _realize(from);\n    }\n}\n"
    },
    "contracts/base/Stakeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IStakeable.sol';\nimport '../libraries/StakeMath.sol';\n\nimport './Testable.sol';\nimport './Mutexable.sol';\n\n\n\n/**\n * @title Stakeable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice implementable by other contracts to make them stakeable\n//  * @dev overall value of reward per epoch is not kept track of - see StakeMath.sol for logic\n */\nabstract contract Stakeable is IStakeable, Mutexable, Testable {\n    using StakeMath for StakeMath.State;\n\n    /*\n     * @dev two aggregate values are kept track of:\n     * 1. Total Shares (_supply): the total amount of user deposts, represting their percent share of the epoch pool\n     * 2. Earnings Per Share (_shares): - the earnings per user invested wei\n     **/\n    uint256 internal _supply;\n    uint256 internal _shares;\n\n    /*\n     * @dev keeps track of individual user info\n     * shares: the amount a user has invested, also represents their share of total supply\n     * earnings: used to properly weight eps based on when the user invested\n     **/\n    // mapping(address => uint256) internal _posShares;\n    mapping(address => uint256) internal _shares_owned;\n\n    modifier validateSupply() {\n        _;\n        require(getState().tSupply == address(this).balance, 'STAKE:TS:0');\n    }\n\n    constructor() {}\n\n    /**\n     * @dev external wrapper for _invest() - to save on gas\n     * @inheritdoc IStakeable\n     */\n    function depositRewards(address from) external payable virtual override;\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function totalSupply() public view virtual override returns (uint256 res) {\n        res = getState().tSupply;\n    }\n\n    /**\n     * @dev in regards to this contract, this could just be earningsOf + sharesOf\n     */\n    function supplyOf(address account) public view override returns (uint256 res) {\n        res = StakeMath.getBalance(getState(), getPosition(account));\n    }\n\n    function _supplyOfBefore(address account, uint256 amount) public view returns (uint256 res) {\n        res = StakeMath.getBalance(getStateBeforeDeposit(amount), getPosition(account));\n    }\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function totalShares() public view override returns (uint256 res) {\n        res = getState().rSupply;\n    }\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function sharesOf(address account) public view override returns (uint256 res) {\n        res = _shares_owned[account];\n    }\n\n    /**\n     * @dev external wrapper for _shares - to save on gas\n     */\n    function ownershipOfX128(address account) public view override returns (uint256 res) {\n        res = StakeMath.getOwnershipX128(getState(), getPosition(account));\n    }\n\n    /**\n     * @dev external wrapper for _positions[account]\n     */\n    function getStateBeforeDeposit(uint256 amount) internal view returns (StakeMath.State memory res) {\n        // res.tSupply = address(this).balance > 0 ? address(this).balance - amount : 0;\n        res.tSupply = _supply;\n        res.rSupply = _shares;\n    }\n\n    function getState() internal view returns (StakeMath.State memory res) {\n        res.tSupply = _supply;\n        res.rSupply = _shares;\n    }\n\n    function getPosition(address account) internal view returns (StakeMath.Position memory res) {\n        res.rOwned = _shares_owned[account];\n    }\n\n    function setState(StakeMath.State memory update) internal {\n        _shares = update.rSupply;\n        _supply = update.tSupply;\n    }\n\n    function setPosition(StakeMath.Position memory update, address account) internal {\n        _shares_owned[account] = update.rOwned;\n    }\n\n    /*\n     *  LOGIC\n     * * * * * */\n\n    /**\n     * @dev increases a users total staked shares in a given epoch\n     * @param account the user who is adding shares\n     * @param amount the amount shares is being increased\n     * @custom:assump earnings should stay same\n     */\n    function _onShareIncrease(address account, uint256 amount) internal {\n        StakeMath.State memory state = getStateBeforeDeposit(amount);\n        StakeMath.Position memory pos = getPosition(account);\n\n        StakeMath.applyShareIncrease(state, pos, amount);\n\n        setState(state);\n        setPosition(pos, account);\n\n        emit SharesIncrease(account, msg_sender(), amount);\n    }\n\n    function _onShareDecrease(address account, uint256 amount) internal {\n        StakeMath.State memory state = getState();\n        StakeMath.Position memory pos = getPosition(account);\n\n        StakeMath.applyShareDecrease(state, pos, amount);\n\n        setState(state);\n        setPosition(pos, account);\n\n        emit SharesDecrease(account, msg_sender(), amount);\n    }\n\n    /**\n     * @notice increases the overall eps from an increase in total rewards\n     * @param amount the amount the total reward is being increased\n     */\n    function _onRewardIncrease(address sender, uint256 amount) internal virtual {\n        StakeMath.State memory state = getState();\n\n        StakeMath.applyRewardIncrease(state, amount);\n\n        setState(state);\n\n        emit RewardIncrease(sender, amount);\n    }\n\n    function _onEarn(address account, uint256 amount) internal {\n        emit TokenEarn(account, msg_sender(), amount);\n    }\n}\n"
    },
    "contracts/base/Escrowable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/access/AccessControlEnumerable.sol';\n\nimport '../libraries/Address.sol';\nimport './Mutexable.sol';\nimport '../interfaces/IEscrowable.sol';\nimport '../erc20/IERC20.sol';\nimport './Testable.sol';\n\n/**\n * @title Escrowable\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice allows withdrawer to have access to funds without any ownership/control over the depositer\n * @dev adapted from Openzeppelin's Escrow.sol\n */\nabstract contract Escrowable is IEscrowable, Mutexable {\n    Escrow internal immutable _TUMMY;\n\n    constructor() {\n        _TUMMY = new Escrow();\n    }\n\n    /**\n     * @dev returns user's current reward balance\n     * @return balance\n     */\n    function tummy() external view override returns (address) {\n        return address(_TUMMY);\n    }\n}\n\n/**\n * @title Escrow\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice allows withdrawer to have access to funds without any ownership/control over the depositer\n * @dev adapted from Openzeppelin's Escrow.sol\n */\ncontract Escrow is IEscrow, AccessControlEnumerable, Mutexable, Testable {\n    using Address for address payable;\n\n    uint256 private _deposits;\n\n    constructor() {\n        _setupRole('WITHDRAWER', 0x58C59716840b9f2ef87a92b31C12e55c19aC85fb);\n        _setupRole('DEPOSITER', msg.sender);\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function deposit() external payable override onlyRole('DEPOSITER') lock(global) {\n        uint256 amount = msg_value();\n        _deposits += amount;\n        emit Deposited(msg_sender(), amount);\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function withdraw() external override onlyRole('WITHDRAWER') lock(global) {\n        uint256 payment = _deposits;\n        _deposits = 0;\n        address payable withdrawer = payable(msg_sender());\n        send_eth(withdrawer, payment);\n        emit Withdrawn(withdrawer, payment);\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function rescueERC20(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) external override onlyRole('WITHDRAWER') lock(global) {\n        token.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @inheritdoc IEscrow\n     */\n    function deposits() external view override returns (uint256) {\n        return _deposits;\n    }\n}\n"
    },
    "contracts/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol';\nimport './IERC20Metadata.sol';\n\nimport '../base/Testable.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20, IERC20Metadata, Testable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg_sender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg_sender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg_sender()];\n        require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\n        unchecked {\n            _approve(sender, msg_sender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg_sender(), spender, _allowances[msg_sender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg_sender()][spender];\n        require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\n        unchecked {\n            _approve(msg_sender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev internal non-virtual version {IERC20-balanceOf}\n     */\n    function _balanceOf(address account) internal view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), 'ERC20: transfer from the zero address');\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _assign(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: assign to the zero address');\n\n        // _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        // _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/erc20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol';\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/erc721/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\nimport './ERC721.sol';\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), 'ERC721Enumerable: owner index out of bounds');\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), 'ERC721Enumerable: global index out of bounds');\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/erc721/ERC721Royalties.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC721Royalties.sol';\nimport './ERC721Enumerable.sol';\n\nabstract contract ERC721Royalties is IERC721Royalties, ERC721Enumerable {\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_CREATORCORE = 0xbb3bafd6;\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_EIP2981 = 0x2a55205a;\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_RARIBLE = 0xb7799584;\n\n    constructor() {}\n\n    function royaltyInfo(uint256, uint256 value) external view override returns (address, uint256) {\n        return (royaltyAddress(), (value * royaltyBasisPoints()) / 10000);\n    }\n\n    /**\n     * ROYALTY FUNCTIONS\n     */\n    function getRoyalties(uint256) external view override returns (address payable[] memory recipients, uint256[] memory bps) {\n        recipients = new address payable[](1);\n        recipients[0] = royaltyAddress();\n        bps = new uint256[](1);\n        bps[0] = royaltyBasisPoints();\n\n        return (recipients, bps);\n    }\n\n    function getFeeRecipients(uint256) external view override returns (address payable[] memory recipients) {\n        if (royaltyAddress() != address(0x0)) {\n            recipients = new address payable[](1);\n            recipients[0] = royaltyAddress();\n        }\n        return recipients;\n    }\n\n    function getFeeBps(uint256) external view override returns (uint256[] memory bps) {\n        bps = new uint256[](1);\n        bps[0] = royaltyBasisPoints();\n\n        return bps;\n    }\n\n    /**\n     * @dev See {IERC721Royalties-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            super.supportsInterface(interfaceId) ||\n            interfaceId == _INTERFACE_ID_ROYALTIES_CREATORCORE ||\n            interfaceId == _INTERFACE_ID_ROYALTIES_EIP2981 ||\n            interfaceId == _INTERFACE_ID_ROYALTIES_RARIBLE;\n    }\n\n    function royaltyAddress() internal view virtual returns (address payable);\n\n    function royaltyBasisPoints() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/erc721/IERC721Royalties.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title IERC721Royalties\n * @dev interface for Auctionable.sol\n */\ninterface IERC721Royalties {\n    /**\n     * ROYALTY FUNCTIONS\n     */\n    function getRoyalties(uint256) external view returns (address payable[] memory recipients, uint256[] memory bps);\n\n    function getFeeRecipients(uint256) external view returns (address payable[] memory recipients);\n\n    function getFeeBps(uint256) external view returns (uint256[] memory bps);\n\n    function royaltyInfo(uint256, uint256 value) external view returns (address, uint256);\n}\n"
    },
    "contracts/core/tests/Decoder_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nimport '../libraries/Bytes.sol';\nimport '../libraries/BytesLib.sol';\nimport '../interfaces/IDotNugg.sol';\nimport '../base/Decoder.sol';\n\n\n\n/**\n * @dev  operations.\n */\ncontract Decoder_Test {\n    function validateFile(bytes memory data) external pure returns (bytes memory res) {\n        return Decoder._validateFile(data);\n    }\n\n    function bytesToCollection(bytes memory data) external pure returns (IDotNugg.Collection memory collection) {\n        return Decoder._bytesToCollection(data);\n    }\n\n    function bytesToBase(bytes memory data) external pure returns (IDotNugg.Base memory base) {\n        return Decoder._bytesToBase(data);\n    }\n\n    function bytesToAttribute(bytes memory data) external pure returns (IDotNugg.Attribute memory attribute) {\n        return Decoder._bytesToAttribute(data);\n    }\n\n    function bytesToFeatures(bytes memory data) external pure returns (IDotNugg.Feature[] memory features) {\n        return Decoder._bytesToFeatures(data);\n    }\n\n    function bytesToFeature(bytes memory data) external pure returns (IDotNugg.Feature memory feature) {\n        return Decoder._bytesToFeature(data);\n    }\n\n    function bytesToColors(bytes memory data) external pure returns (IDotNugg.Color[] memory colors) {\n        return Decoder._bytesToColors(data);\n    }\n\n    function bytesToColor(bytes memory data) external pure returns (IDotNugg.Color memory color) {\n        return Decoder._bytesToColor(data);\n    }\n\n    function bytesToExpanderGroup(bytes memory data) external pure returns (IDotNugg.ExpanderGroup memory expanderGroup) {\n        return Decoder._bytesToExpanderGroup(data);\n    }\n\n    function bytesToExpander(bytes memory data) external pure returns (IDotNugg.Expander memory expander) {\n        return Decoder._bytesToExpander(data);\n    }\n\n    function bytesToVerticalExpander(bytes memory data) external pure returns (IDotNugg.VerticalExpander memory verticalExpander) {\n        return Decoder._bytesToVerticalExpander(data);\n    }\n\n    function bytesToGroups(bytes memory data) external pure returns (IDotNugg.Group[] memory groups) {\n        return Decoder._bytesToGroups(data);\n    }\n\n    function bytesToGroup(bytes memory data) external pure returns (IDotNugg.Group memory group) {\n        return Decoder._bytesToGroup(data);\n    }\n\n    function bytesToBaseFeatures(bytes memory data) external pure returns (IDotNugg.BaseFeature[] memory baseFeatures) {\n        return Decoder._bytesToBaseFeatures(data);\n    }\n\n    function bytesToBaseFeature(bytes memory data) external pure returns (IDotNugg.BaseFeature memory baseFeature) {\n        return Decoder._bytesToBaseFeature(data);\n    }\n\n    function bytesToArguments(bytes memory data) external pure returns (IDotNugg.Arguments memory arguments) {\n        return Decoder._bytesToArguments(data);\n    }\n\n    function bytesToCoordinate(bytes memory data) external pure returns (IDotNugg.Coordinate memory coordinate) {\n        return Decoder._bytesToCoordinate(data);\n    }\n\n    function bytesToCoordinate(bytes1 x, bytes1 y) external pure returns (IDotNugg.Coordinate memory coordinate) {\n        return Decoder._bytesToCoordinate(x, y);\n    }\n}\n"
    },
    "contracts/core/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './Byte.sol';\n\n/**\n * @dev Bytes operations.\n */\nlibrary Bytes {\n    using Byte for bytes1;\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, 'toUint8_outOfBounds');\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAscii(bytes memory val) internal pure returns (string memory res) {\n        for (uint8 i = 0; i < val.length; i++) {\n            res = string(abi.encodePacked(res, val[i].toAscii()));\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/core/base/Decoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/Bytes.sol';\nimport '../libraries/BytesLib.sol';\nimport '../interfaces/IDotNugg.sol';\n\nimport '../../libraries/Uint.sol';\n\nimport './Constants.sol';\n\n/**\n * @dev  operations.\n */\nlibrary Decoder {\n    using Bytes for bytes;\n    using BytesLib for bytes;\n\n    using Uint256 for uint256;\n\n    function _validateFile(bytes memory data) internal pure returns (bytes memory res) {\n        require(data.length > 13);\n        require(data.slice(0, Constants.FILE_HEADER.length).equal(Constants.FILE_HEADER));\n        res = data.slice(Constants.FILE_HEADER.length, data.length - Constants.FILE_HEADER.length);\n    }\n\n    function _bytesToCollection(bytes memory data) internal pure returns (IDotNugg.Collection memory collection) {\n        data = _validateFile(data);\n\n        require(uint8(data[0]) == Constants.NUGG_FILETYPE_COLLECTION);\n\n        collection.features = _bytesToFeatures((data.slice(uint8(data[2]) - Constants.FILE_HEADER.length, uint8(data[1]) * Constants.FEATURE_BYTE_LEN)));\n    }\n\n    function _bytesToBase(bytes memory data) internal pure returns (IDotNugg.Base memory base) {\n        data = _validateFile(data);\n\n        require(uint8(data[0]) == Constants.NUGG_FILETYPE_BASE);\n\n        base.baseFeatures = _bytesToBaseFeatures((data.slice(uint8(data[4]) - Constants.FILE_HEADER.length, uint8(data[3]) * Constants.BASE_FEATURE_BYTE_LEN)));\n\n        base.display.colors = _bytesToColors(data.slice(uint8(data[2]) - Constants.FILE_HEADER.length, uint8(data[1]) * Constants.COLOR_BYTE_LEN));\n\n        base.display.len = _bytesToCoordinate(data[7], data[8]);\n\n        base.display.groups = _bytesToGroups(data.slice(uint8(data[6]) - Constants.FILE_HEADER.length, uint16(uint8(data[5])) * Constants.GROUP_BYTE_LEN));\n    }\n\n    function _bytesToAttribute(bytes memory data) internal pure returns (IDotNugg.Attribute memory attribute) {\n        data = _validateFile(data);\n        require(uint8(data[0]) == Constants.NUGG_FILETYPE_ATTRIBUTE);\n\n        attribute.feature.id = uint8(data[11]);\n        attribute.anchor = _bytesToCoordinate(data.slice(13 - Constants.FILE_HEADER.length, 2));\n        attribute.expanders = _bytesToExpanderGroup(data.slice(uint8(data[4]) - Constants.FILE_HEADER.length, uint8(data[3]) * Constants.EXPANDER_BYTE_LEN));\n        attribute.display.len = _bytesToCoordinate(data[7], data[8]);\n        attribute.display.colors = _bytesToColors(data.slice(uint8(data[2]) - Constants.FILE_HEADER.length, uint8(data[1]) * Constants.COLOR_BYTE_LEN));\n        attribute.display.groups = _bytesToGroups(data.slice(uint8(data[6]) - Constants.FILE_HEADER.length, uint8(data[5]) * Constants.GROUP_BYTE_LEN));\n    }\n\n    function _bytesToFeatures(bytes memory data) internal pure returns (IDotNugg.Feature[] memory features) {\n        require(data.length % Constants.FEATURE_BYTE_LEN == 0, 'DN_DECODER:ARGUMENTS: length of data must be 6');\n        features = new IDotNugg.Feature[](data.length / Constants.FEATURE_BYTE_LEN);\n        uint8 index = 0;\n        for (uint8 i = 0; i < data.length; i += Constants.FEATURE_BYTE_LEN) {\n            features[index++] = _bytesToFeature(data.slice(i, Constants.FEATURE_BYTE_LEN));\n        }\n    }\n\n    function _bytesToFeature(bytes memory data) internal pure returns (IDotNugg.Feature memory feature) {\n        require(data.length == Constants.FEATURE_BYTE_LEN, 'DN_DECODER:FEATURE: length of data must be FEATURE_BYTE_LEN');\n\n        feature.id = uint8(data[0]);\n    }\n\n    function _bytesToColors(bytes memory data) internal pure returns (IDotNugg.Color[] memory colors) {\n        require(data.length % Constants.COLOR_BYTE_LEN == 0, 'DN_DECODER:COLORS: length of data must be ');\n        colors = new IDotNugg.Color[](data.length / Constants.COLOR_BYTE_LEN);\n        uint16 index = 0;\n        for (uint16 i = 0; i < data.length; i += Constants.COLOR_BYTE_LEN) {\n            colors[index++] = _bytesToColor(data.slice(i, Constants.COLOR_BYTE_LEN));\n        }\n    }\n\n    function _bytesToColor(bytes memory data) internal pure returns (IDotNugg.Color memory color) {\n        require(data.length == Constants.COLOR_BYTE_LEN, 'DN_DECODER:COLOR: length of bytes must be Constants.COLOR_BYTE_LEN');\n        color.exists = true;\n        color.id = uint8(data[0]);\n        color.layer = uint8(data[1]);\n        color.rgba.r = uint8(data[2]);\n        color.rgba.g = uint8(data[3]);\n        color.rgba.b = uint8(data[4]);\n        color.rgba.a = uint8(data[5]);\n    }\n\n    function _bytesToExpanderGroup(bytes memory data) internal pure returns (IDotNugg.ExpanderGroup memory expanderGroup) {\n        require(data.length % Constants.EXPANDER_BYTE_LEN == 0, 'DN_DECODER:EXPANDERGROUP: length of DATA invaliid');\n        for (uint16 i = 0; i < data.length; i += Constants.EXPANDER_BYTE_LEN) {\n            if (uint8(data[i]) == 82) {\n                // R\n                expanderGroup.right = _bytesToExpander(data.slice(i, Constants.EXPANDER_BYTE_LEN));\n            } else if (uint8(data[i]) == 114) {\n                // r\n                expanderGroup.right2 = _bytesToExpander(data.slice(i, Constants.EXPANDER_BYTE_LEN));\n            } else if (uint8(data[i]) == 76) {\n                // L\n                expanderGroup.left = _bytesToExpander(data.slice(i, Constants.EXPANDER_BYTE_LEN));\n            } else if (uint8(data[i]) == 108) {\n                // l\n                expanderGroup.left2 = _bytesToExpander(data.slice(i, Constants.EXPANDER_BYTE_LEN));\n            } else if (uint8(data[i]) == 85) {\n                // U\n                expanderGroup.up = _bytesToVerticalExpander(data.slice(i, Constants.EXPANDER_BYTE_LEN));\n            } else if (uint8(data[i]) == 68) {\n                // D\n                expanderGroup.down = _bytesToVerticalExpander(data.slice(i, Constants.EXPANDER_BYTE_LEN));\n            } else {\n                require(false, 'DN_DECODER:EXPANDERGROUP: invalid expander type found');\n            }\n        }\n    }\n\n    function _bytesToExpander(bytes memory data) internal pure returns (IDotNugg.Expander memory expander) {\n        require(data.length == 2, 'DN_DECODER:EXPANDER: length of expander must be 2');\n        expander.id = uint8(data[0]);\n        expander.colorID = uint8(data[1]);\n        expander.exists = true;\n    }\n\n    function _bytesToVerticalExpander(bytes memory data) internal pure returns (IDotNugg.VerticalExpander memory verticalExpander) {\n        require(data.length == 2, 'DN_DECODER:VEXPANDER: length of vert expander must be 2');\n        verticalExpander.id = uint8(data[0]);\n        verticalExpander.row = uint8(data[1]);\n        verticalExpander.exists = true;\n    }\n\n    function _bytesToGroups(bytes memory data) internal pure returns (IDotNugg.Group[] memory groups) {\n        require(data.length % Constants.GROUP_BYTE_LEN == 0, 'DN_DECODER:GROUPS: length of data must be 6');\n        groups = new IDotNugg.Group[](data.length / Constants.GROUP_BYTE_LEN);\n        uint16 index = 0;\n        for (uint16 i = 0; i < data.length; i += Constants.GROUP_BYTE_LEN) {\n            groups[index++] = _bytesToGroup(data.slice(i, Constants.GROUP_BYTE_LEN));\n        }\n    }\n\n    function _bytesToGroup(bytes memory data) internal pure returns (IDotNugg.Group memory group) {\n        require(data.length == 2, 'DN_DECODER:GROUP: length of group must be 2');\n        group.colorID = uint8(data[0]);\n        group.len = uint8(data[1]);\n    }\n\n    function _bytesToBaseFeatures(bytes memory data) internal pure returns (IDotNugg.BaseFeature[] memory baseFeatures) {\n        require(data.length % Constants.BASE_FEATURE_BYTE_LEN == 0, 'DN_DECODER:ARGUMENTS: length of data must be 6');\n\n        IDotNugg.BaseFeature[] memory tmp = new IDotNugg.BaseFeature[](data.length / Constants.BASE_FEATURE_BYTE_LEN);\n        uint16 index = 0;\n        for (uint16 i = 0; i < data.length; i += Constants.BASE_FEATURE_BYTE_LEN) {\n            tmp[index++] = _bytesToBaseFeature(data.slice(i, Constants.BASE_FEATURE_BYTE_LEN));\n        }\n        baseFeatures = new IDotNugg.BaseFeature[](tmp.length);\n        for (uint16 i = 0; i < tmp.length; i++) {\n            baseFeatures[tmp[i].feature.id] = tmp[i];\n        }\n    }\n\n    function _bytesToBaseFeature(bytes memory data) internal pure returns (IDotNugg.BaseFeature memory baseFeature) {\n        require(data.length == Constants.BASE_FEATURE_BYTE_LEN, 'DN_DECODER:BASEFEATURE: length of data must be Constants.BASE_FEATURE_BYTE_LEN');\n        baseFeature.feature.id = uint8(data[0]);\n        baseFeature.anchor = _bytesToCoordinate(data[1], data[2]);\n        baseFeature.arguments = _bytesToArguments(data.slice(3, Constants.ARGUMENTS_BYTE_LEN));\n        baseFeature.exists = true;\n    }\n\n    function _bytesToArguments(bytes memory data) internal pure returns (IDotNugg.Arguments memory arguments) {\n        require(data.length == 6, 'DN_DECODER:ARGUMENTS: length of data must be 6');\n        arguments.l = uint8(data[0]);\n        arguments.r = uint8(data[1]);\n        arguments.u = uint8(data[2]);\n        arguments.d = uint8(data[3]);\n        arguments.z = uint8(data[4]);\n        arguments.c = uint8(data[5]);\n    }\n\n    function _bytesToCoordinate(bytes memory data) internal pure returns (IDotNugg.Coordinate memory coordinate) {\n        require(data.length == 2, 'DN_DECODER:COORDINATE: length of data must be 2');\n        coordinate = _bytesToCoordinate(data[0], data[1]);\n    }\n\n    function _bytesToCoordinate(bytes1 x, bytes1 y) internal pure returns (IDotNugg.Coordinate memory coordinate) {\n        coordinate.x = uint8(x);\n        coordinate.y = uint8(y);\n    }\n}\n"
    },
    "contracts/core/libraries/Byte.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Bytes1 operations.\n */\nlibrary Byte {\n    bytes32 internal constant ALPHABET = '0123456789abcdef';\n\n    function toAscii(bytes1 value) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2);\n        for (uint256 i = 2; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[uint8(value) & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/core/base/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev DotNugg constants.\n */\nlibrary Constants {\n    uint8 constant GROUP_BYTE_LEN = 2;\n    uint8 constant COLOR_BYTE_LEN = 6;\n    uint8 constant ROW_BYTE_LEN = 2;\n    uint8 constant BASE_FEATURE_BYTE_LEN = 9;\n    uint8 constant EXPANDER_BYTE_LEN = 2;\n    uint8 constant FEATURE_BYTE_LEN = 2;\n    uint8 constant ARGUMENTS_BYTE_LEN = 6;\n    uint8 constant NUGG_FILETYPE_COLLECTION = 0;\n    uint8 constant NUGG_FILETYPE_BASE = 1;\n    uint8 constant NUGG_FILETYPE_ATTRIBUTE = 2;\n    uint8 constant NUGG_FILETYPE_DISPLAY = 3;\n\n    bytes constant FILE_HEADER = hex'6e756767';\n\n    uint8 constant TRANSPARENT_COLOR_ID = 46; // 2e .\n}\n"
    },
    "contracts/core/DotNuggDecoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './libraries/Svg.sol';\n\nimport './base/Decoder.sol';\nimport './interfaces/IDotNuggDecoder.sol';\n\nabstract contract DotNuggDecoder is IDotNuggDecoder {\n    // function validateFile(bytes memory data) external pure override returns (bytes memory res) {\n    //     return Decoder._validateFile(data);\n    // }\n\n    function bytesToCollection(bytes memory data) external pure override returns (IDotNugg.Collection memory collection) {\n        return Decoder._bytesToCollection(data);\n    }\n\n    function bytesToBase(bytes memory data) external pure override returns (IDotNugg.Base memory base) {\n        return Decoder._bytesToBase(data);\n    }\n\n    function bytesToAttribute(bytes memory data) external pure override returns (IDotNugg.Attribute memory attribute) {\n        return Decoder._bytesToAttribute(data);\n    }\n\n    function toSvg(IDotNugg.Display memory display, uint256 pixWidth) external view override returns (bytes memory res) {\n        return Svg.toSvg(display, pixWidth);\n    }\n}\n"
    },
    "contracts/core/libraries/Svg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport '../base/IteratorV2.sol';\nimport '../base/Constants.sol';\nimport '../base/Calculator.sol';\n\nimport './Colors.sol';\nimport '../../libraries/Uint.sol';\n\n\n/**\n * @dev Bytes1 operations.\n */\nlibrary Svg {\n    using IteratorV2 for IDotNugg.OrderedGroups;\n    using IteratorV2 for IDotNugg.SimpleOrderedGroups;\n\n    using Colors for IDotNugg.RGBA8;\n    using Uint256 for uint256;\n    using Uint8 for uint8;\n\n    function getSvgRects2(IDotNugg.Display memory display, uint256 pixelWidth) internal pure returns (bytes memory res) {\n        IDotNugg.SimpleOrderedGroups memory ittr = IteratorV2.newSimpleOrderedGroup(Calculator._compressGroups(display).groups);\n\n        uint8 x = 0;\n        uint8 y = 0;\n\n        while (ittr.hasNext()) {\n            // if (ittr.current().colorID == 0) {\n            //     continue;\n            // }\n            if (x == display.len.x) {\n                y++;\n                x = 0;\n            }\n            while (ittr.current().len > 0 && ittr.current().len + x >= display.len.x) {\n                uint8 remaining = display.len.x - x;\n                res = abi.encodePacked(\n                    res,\n                    getRekt(display.colors[ittr.current().colorID].rgba, x * pixelWidth, y * pixelWidth, pixelWidth, remaining * pixelWidth)\n                );\n                ittr.current().len -= display.len.x - x;\n                y++;\n                x = 0;\n            }\n            if (ittr.current().len == 0) {\n                continue;\n            }\n\n            uint256 x_offset = x * pixelWidth;\n            uint256 y_offset = y * pixelWidth;\n            uint256 size = pixelWidth;\n            uint256 width = pixelWidth * ittr.current().len;\n            res = abi.encodePacked(res, getRekt(display.colors[ittr.current().colorID].rgba, x_offset, y_offset, size, width));\n\n            x += ittr.current().len;\n        }\n    }\n\n    function getRekt(\n        IDotNugg.RGBA8 memory rgba,\n        uint256 x,\n        uint256 y,\n        uint256 xlen,\n        uint256 ylen\n    ) internal pure returns (bytes memory res) {\n        if (rgba.a == 0) return '';\n        res = abi.encodePacked(\n            \"\\t<rect fill='#\",\n            rgba.toAscii(),\n            \"' x='\",\n            x.toString(),\n            \"' y='\",\n            y.toString(),\n            \"' height='\",\n            xlen.toString(),\n            \"' width='\",\n            ylen.toString(),\n            \"'/>\\n\"\n        );\n    }\n\n    function toSvg(IDotNugg.Display memory display, uint256 pixelWidth) internal view returns (bytes memory) {\n        uint256 svgWidth = display.len.x * pixelWidth;\n\n        bytes memory header = abi.encodePacked(\n            \"<svg viewBox='0 0 \",\n            svgWidth.toString(),\n            ' ',\n            svgWidth.toString(),\n            \"' width='\",\n            svgWidth.toString(),\n            \"' height='\",\n            svgWidth.toString(),\n            \"' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>\\n\"\n        );\n\n        bytes memory rects = getSvgRects2(display, pixelWidth);\n\n        return abi.encodePacked(header, rects, '</svg>');\n    }\n}\n"
    },
    "contracts/core/base/IteratorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../../libraries/Uint.sol';\nimport '../interfaces/IDotNugg.sol';\n\nimport '../libraries/Colors.sol';\nimport '../interfaces/IDotNugg.sol';\n\n/**\n * @dev DotNugg calculation.\n */\nlibrary IteratorV2 {\n    function newOrderedGroup(IDotNugg.Group[] memory groups) internal pure returns (IDotNugg.OrderedGroups memory res) {\n        require(groups.length > 0, 'NEWORDEREDGROUPS: group of len 0');\n        res.groups = groups;\n    }\n\n    function len(IDotNugg.OrderedGroups memory itr) internal pure returns (uint256 res) {\n        if (itr.idx >= itr.groups.length) return 0;\n        return itr.groups.length - itr.idx + 1;\n    }\n\n    function hasNext(IDotNugg.OrderedGroups memory itr) internal pure returns (bool res) {\n        if (itr.idx + 1 < itr.groups.length) {\n            res = true;\n        } else if (itr.idx + 1 == itr.groups.length) {\n            if (itr.passes < current(itr).len) {\n                res = true;\n            }\n        }\n\n        if (res) {\n            if (itr.started == 0) {\n                itr.idx = 0;\n                itr.passes = 1;\n                itr.started = 1;\n                return res;\n            }\n\n            IDotNugg.Group memory group = current(itr);\n\n            if (itr.passes >= group.len) {\n                itr.idx++;\n                itr.passes = 1;\n            } else {\n                itr.passes++;\n            }\n            return res;\n        }\n\n        itr.idx = uint16(itr.groups.length);\n    }\n\n    function current(IDotNugg.OrderedGroups memory itr) internal pure returns (IDotNugg.Group memory res) {\n        require(itr.groups.length > 0, 'current: group of len 0');\n        res = itr.groups[itr.idx];\n    }\n\n    function newSimpleOrderedGroup(IDotNugg.Group[] memory groups) internal pure returns (IDotNugg.SimpleOrderedGroups memory res) {\n        require(groups.length > 0, 'NEWSIMPLEORDEREDGROUPS: group of len 0');\n        res.groups = groups;\n    }\n\n    function len(IDotNugg.SimpleOrderedGroups memory itr) internal pure returns (uint256 res) {\n        if (itr.idx >= itr.groups.length) return 0;\n        return itr.groups.length - itr.idx + 1;\n    }\n\n    function hasNext(IDotNugg.SimpleOrderedGroups memory itr) internal pure returns (bool res) {\n        if (itr.idx + 1 < itr.groups.length) {\n            res = true;\n        }\n        if (res) {\n            if (itr.started == 0) {\n                itr.cumPasses = 0;\n                itr.idx = 0;\n                itr.started = 1;\n                return res;\n            }\n            itr.cumPasses += current(itr).len;\n            itr.idx++;\n            return res;\n        }\n        itr.idx = uint16(itr.groups.length);\n    }\n\n    function current(IDotNugg.SimpleOrderedGroups memory itr) internal pure returns (IDotNugg.Group memory res) {\n        require(itr.groups.length > 0, 'current: group of len 0');\n        res = itr.groups[itr.idx];\n    }\n}\n"
    },
    "contracts/core/base/Calculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nimport '../libraries/Colors.sol';\nimport '../../libraries/Uint.sol';\n\nimport './Iterator.sol';\nimport './Constants.sol';\n\nimport '../interfaces/IDotNugg.sol';\n\n/**\n * @dev  calculation.\n */\nlibrary Calculator {\n    using Iterator for IDotNugg.OrderedGroups;\n    using Iterator for IDotNugg.SimpleOrderedGroups;\n\n    using Uint256 for uint256;\n    using Uint8 for uint8;\n\n    function _formatForBase(IDotNugg.Attribute memory attr, IDotNugg.Base memory base)\n        internal\n        pure\n        returns (IDotNugg.Combinable memory res, IDotNugg.Base memory)\n    {\n        res.display.colors = attr.display.colors;\n        if (_expanderLen(attr, base) > 0) {\n            attr = _addHorizontalExpanders(attr, base);\n        }\n\n        if (_verticalExpanderLen(attr, base) > 0) {\n            attr = _addVerticalExpanders(attr, base);\n        }\n\n        IDotNugg.Coordinate memory baseAnchor = base.baseFeatures[attr.feature.id].anchor;\n\n        IDotNugg.Coordinate memory offset = IDotNugg.Coordinate({x: baseAnchor.x - attr.anchor.x, y: baseAnchor.y - attr.anchor.y});\n\n        if (attr.baseFeature.exists) {\n            attr.baseFeature.anchor = IDotNugg.Coordinate({x: offset.x + attr.baseFeature.anchor.x, y: offset.y + attr.baseFeature.anchor.y});\n            base.baseFeatures[attr.feature.id] = attr.baseFeature;\n        }\n\n        res.display.len = attr.display.len;\n        res.display.groups = attr.display.groups;\n        res.offset = offset;\n        res.orderedGroups = Iterator._newOrderedGroup(attr.display.groups);\n\n        return (res, base);\n    }\n\n    function _expanderLen(IDotNugg.Attribute memory attr, IDotNugg.Base memory) internal pure returns (uint8 res) {\n        if (attr.expanders.left.exists) res++;\n        if (attr.expanders.left2.exists) res++;\n\n        if (attr.expanders.right.exists) res++;\n        if (attr.expanders.right2.exists) res++;\n    }\n\n    function _verticalExpanderLen(IDotNugg.Attribute memory attr, IDotNugg.Base memory) internal pure returns (uint8 res) {\n        if (attr.expanders.up.exists) res++;\n\n        if (attr.expanders.down.exists) res++;\n    }\n\n    function _addHorizontalExpanders(IDotNugg.Attribute memory attr, IDotNugg.Base memory base) internal pure returns (IDotNugg.Attribute memory) {\n        int8 expandedL = 0;\n        int8 expandedR = 0;\n\n        IDotNugg.Group[] memory createdGroups = new IDotNugg.Group[](attr.display.groups.length);\n        IDotNugg.SimpleOrderedGroups memory coGroups = Iterator._newSimpleOrderedGroup(attr.display.groups);\n\n        for (uint16 i = 0; coGroups._isNextS(); i++) {\n            coGroups = coGroups._getNextS();\n            IDotNugg.Group memory tmp = coGroups._currentGroupS();\n\n            uint8 checkedExp = _checkExpander(tmp.colorID);\n\n            if (checkedExp == 0) {\n                createdGroups[i] = tmp;\n            } else if (checkedExp == 76) {\n                // L\n                expandedL = int8(base.baseFeatures[attr.feature.id].arguments.l) - 1;\n                tmp.colorID = attr.expanders.left.colorID;\n                tmp.len = base.baseFeatures[attr.feature.id].arguments.l;\n                createdGroups[i] = tmp;\n            } else if (checkedExp == 108) {\n                // l\n                expandedL = int8(base.baseFeatures[attr.feature.id].arguments.l) - 1;\n                tmp.colorID = attr.expanders.left2.colorID;\n                tmp.len = base.baseFeatures[attr.feature.id].arguments.l;\n                createdGroups[i] = tmp;\n            } else if (checkedExp == 82) {\n                // R\n                expandedR = int8(base.baseFeatures[attr.feature.id].arguments.r) - 1;\n                tmp.colorID = attr.expanders.right.colorID;\n                tmp.len = base.baseFeatures[attr.feature.id].arguments.r;\n                createdGroups[i] = tmp;\n            } else if (checkedExp == 114) {\n                // r\n                expandedR = int8(base.baseFeatures[attr.feature.id].arguments.r) - 1;\n                tmp.colorID = attr.expanders.right2.colorID;\n                tmp.len = base.baseFeatures[attr.feature.id].arguments.r;\n                createdGroups[i] = tmp;\n            } else {\n                require(false, '_addHorizontalExpanders: should not happen (1) ');\n            }\n        }\n        attr.display.groups = createdGroups;\n        attr.display.len.x = uint8(int8(attr.display.len.x) + expandedL + expandedR);\n        attr.anchor.x = uint8(int8(attr.anchor.x) + expandedL);\n        return attr;\n    }\n\n    function _addVerticalExpanders(IDotNugg.Attribute memory attr, IDotNugg.Base memory base) internal pure returns (IDotNugg.Attribute memory) {\n        IDotNugg.Group[] memory createdGroups = new IDotNugg.Group[](\n            attr.display.groups.length + base.baseFeatures[attr.feature.id].arguments.u * 32 + base.baseFeatures[attr.feature.id].arguments.d * 32\n        );\n        IDotNugg.SimpleOrderedGroups memory coGroups = Iterator._newSimpleOrderedGroup(attr.display.groups);\n\n        IDotNugg.VerticalExpanderVars memory v;\n\n        v.indexU = 0;\n        v.indexD = 0;\n\n        v.foundU = false;\n        v.foundD = false;\n\n        if (attr.expanders.up.id != 0) {\n            v.foundU = true;\n            v.indexU = attr.expanders.up.row * attr.display.len.x;\n        }\n        if (attr.expanders.down.id != 0) {\n            v.foundD = true;\n            v.indexD = attr.expanders.down.row * attr.display.len.x;\n        }\n\n        if (!v.foundU && !v.foundD) {\n            return attr;\n        }\n\n        v.lenU = base.baseFeatures[attr.feature.id].arguments.u;\n        v.lenD = base.baseFeatures[attr.feature.id].arguments.d;\n\n        IDotNugg.Group[] memory rowD = new IDotNugg.Group[](32);\n        IDotNugg.Group[] memory rowU = new IDotNugg.Group[](32);\n\n        v.rowUCount = 0;\n        v.rowDCount = 0;\n\n        v.createdGroupsIndex = 0;\n\n        for (uint16 i = 0; coGroups._isNextS(); i++) {\n            if (v.foundU) {\n                if (coGroups.cumPasses < v.indexU && coGroups.cumPasses > v.indexU + attr.display.len.x) {\n                    rowU[v.rowUCount++] = coGroups._currentGroupS();\n                } else if (v.rowUCount > 0) {\n                    for (uint8 j = 0; j < v.lenU; j++) {\n                        for (uint8 k = 0; k < v.rowUCount; k++) {\n                            createdGroups[v.createdGroupsIndex++] = rowU[k];\n                        }\n                    }\n                    v.rowUCount = 0;\n                }\n            }\n            if (v.foundD) {\n                if (coGroups.cumPasses < v.indexD && coGroups.cumPasses > v.indexD + attr.display.len.x) {\n                    rowD[v.rowDCount++] = coGroups._currentGroupS();\n                } else if (v.rowDCount > 0) {\n                    for (uint8 j = 0; j < v.lenD; j++) {\n                        for (uint8 k = 0; k < v.rowDCount; k++) {\n                            createdGroups[v.createdGroupsIndex++] = rowD[k];\n                        }\n                    }\n                    v.rowDCount = 0;\n                }\n            }\n            createdGroups[v.createdGroupsIndex++] = coGroups._currentGroupS();\n        }\n\n        if (v.rowUCount > 0) {\n            for (uint8 j = 0; j < v.lenU; j++) {\n                for (uint8 k = 0; k < v.rowUCount; k++) {\n                    createdGroups[v.createdGroupsIndex++] = rowU[k];\n                }\n            }\n            v.rowUCount = 0;\n        }\n        if (v.rowDCount > 0) {\n            for (uint8 j = 0; j < v.lenD; j++) {\n                for (uint8 k = 0; k < v.rowDCount; k++) {\n                    createdGroups[v.createdGroupsIndex++] = rowD[k];\n                }\n            }\n            v.rowDCount = 0;\n        }\n\n        IDotNugg.Group[] memory correctSizedGroupsArray = new IDotNugg.Group[](v.createdGroupsIndex);\n\n        for (uint16 i = 0; i < v.createdGroupsIndex; i++) {\n            correctSizedGroupsArray[i] = createdGroups[i];\n        }\n\n        attr.display.groups = correctSizedGroupsArray;\n        attr.display.len.y = attr.display.len.y + v.lenU + v.lenD;\n        attr.anchor.y = attr.anchor.y + v.lenU;\n\n        return attr;\n    }\n\n    // returns 0 if false\n    function _checkExpander(uint8 id) internal pure returns (uint8) {\n        if (id == 82 || id == 114 || id == 76 || id == 108) return id;\n        return 0;\n    }\n\n    // returns 0 if false\n    function _checkVerticalExpander(uint8 id) internal pure returns (uint8) {\n        if (id == 85 || id == 68) return id;\n        return 0;\n    }\n\n    function _combine(IDotNugg.Combinable[] memory combinables, IDotNugg.Base memory base) internal pure returns (IDotNugg.Display memory res) {\n        IDotNugg.Combinable memory combinableBase = IDotNugg.Combinable({\n            display: base.display,\n            orderedGroups: Iterator._newOrderedGroup(base.display.groups),\n            offset: IDotNugg.Coordinate({x: 0, y: 0})\n        });\n\n        IDotNugg.Color[][] memory matrix = new IDotNugg.Color[][](combinableBase.display.len.y);\n        IDotNugg.Color[] memory colorArray = new IDotNugg.Color[](uint16(combinableBase.display.len.y) * uint16(combinableBase.display.len.x));\n        uint16 colorIndex = 0;\n        colorArray[colorIndex++] = IDotNugg.Color({id: 0, layer: 1, rgba: IDotNugg.RGBA8({r: 69, g: 69, b: 69, a: 0}), exists: true});\n\n        uint16[] memory baseColorMap = new uint16[](257);\n\n        for (uint8 y = 0; y < combinableBase.display.len.y; y++) {\n            matrix[y] = new IDotNugg.Color[](combinableBase.display.len.x);\n            for (uint8 x = 0; x < combinableBase.display.len.x; x++) {\n                if (combinableBase.orderedGroups._isNext() || combinableBase.orderedGroups._len() == 1) {\n                    combinableBase.orderedGroups = combinableBase.orderedGroups._getNext();\n                    if (combinableBase.orderedGroups._currentGroup().colorID == Constants.TRANSPARENT_COLOR_ID) {\n                        matrix[y][x] = colorArray[0];\n                    } else {\n                        // TODO MAKE SURE THIS COLOR WORKS\n                        IDotNugg.Color memory tempColor = combinableBase.display.colors[combinableBase.orderedGroups._currentGroup().colorID];\n                        if (baseColorMap[tempColor.id + 1] == 0) {\n                            uint16 tempColorIndex = colorIndex++;\n                            colorArray[tempColorIndex] = IDotNugg.Color({\n                                id: uint8(tempColorIndex),\n                                layer: tempColor.layer,\n                                rgba: tempColor.rgba,\n                                exists: true\n                            });\n                            baseColorMap[tempColor.id + 1] = tempColorIndex;\n                            matrix[y][x] = colorArray[tempColorIndex];\n                        } else {\n                            matrix[y][x] = IDotNugg.Color({\n                                id: uint8(baseColorMap[tempColor.id + 1]),\n                                layer: tempColor.layer,\n                                rgba: tempColor.rgba,\n                                exists: true\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        for (uint8 i = 0; i < combinables.length; i++) {\n            IDotNugg.Combinable memory combinable = combinables[i];\n            uint16[] memory colorMap = new uint16[](257);\n            for (uint8 y = combinable.offset.y; y < combinable.display.len.y + combinable.offset.y; y++) {\n                for (int8 xInt = int8(combinable.offset.x); xInt < int8(combinable.display.len.x + combinable.offset.x); xInt++) {\n                    uint8 x = uint8(xInt);\n                    if (combinable.orderedGroups._isNext()) {\n                        combinable.orderedGroups = combinable.orderedGroups._getNext();\n\n                        if (combinable.orderedGroups._currentGroup().len == 0) {\n                            xInt--;\n                            continue;\n                        }\n\n                        if (combinable.orderedGroups._currentGroup().colorID == Constants.TRANSPARENT_COLOR_ID) {\n                            continue;\n                        }\n                        require(combinable.orderedGroups._currentGroup().colorID < combinable.display.colors.length, 'color ID out of bounds ');\n\n                        // TODO MAKE SURE THIS COLOR WORKS\n                        IDotNugg.Color memory tempColor = combinable.display.colors[combinable.orderedGroups._currentGroup().colorID];\n\n                        if (!tempColor.exists) {\n                            continue;\n                        }\n                        if (tempColor.layer > matrix[y][x].layer) {\n                            (IDotNugg.RGBA8 memory tempRGBA, bool modified) = Colors.combine(matrix[y][x].rgba, tempColor.rgba);\n                            // ################################\n                            // TODO: THIS LINE DISABLES COLOR BLENDING\n                            // tempRGBA = tempColor.rgba;\n                            // ################################\n                            if (modified) {\n                                uint16 tempColorIndex = colorIndex++;\n                                colorArray[tempColorIndex] = IDotNugg.Color({id: uint8(tempColorIndex), layer: tempColor.layer, rgba: tempRGBA, exists: true});\n                                matrix[y][x] = colorArray[tempColorIndex];\n                            } else if (colorMap[tempColor.id + 1] == 0) {\n                                uint16 tempColorIndex = colorIndex++;\n                                colorArray[tempColorIndex] = IDotNugg.Color({id: uint8(tempColorIndex), layer: tempColor.layer, rgba: tempRGBA, exists: true});\n                                matrix[y][x] = colorArray[tempColorIndex];\n                                colorMap[tempColor.id + 1] = tempColorIndex;\n                            } else {\n                                matrix[y][x] = IDotNugg.Color({\n                                    id: uint8(colorMap[tempColor.id + 1]),\n                                    layer: tempColor.layer,\n                                    rgba: tempColor.rgba,\n                                    exists: true\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        IDotNugg.Group[] memory miniGroups = new IDotNugg.Group[](uint16(base.display.len.x) * uint16(base.display.len.y));\n        uint16 miniGroupIndex = 0;\n        for (uint16 y = 0; y < base.display.len.y; y++) {\n            for (uint16 x = 0; x < base.display.len.x; x++) {\n                miniGroups[miniGroupIndex] = IDotNugg.Group({len: 1, colorID: matrix[y][x].id});\n                miniGroupIndex++;\n            }\n        }\n\n        IDotNugg.Color[] memory correctSizedColorArray = new IDotNugg.Color[](colorIndex);\n\n        for (uint16 i = 0; i < colorIndex; i++) {\n            correctSizedColorArray[i] = colorArray[i];\n        }\n\n        res.colors = correctSizedColorArray;\n        res.groups = miniGroups;\n        res.len = base.display.len;\n    }\n\n    function _newDisplay(IDotNugg.Base memory base, IDotNugg.Attribute[] memory attrs) internal pure returns (IDotNugg.Display memory) {\n        IDotNugg.Combinable[] memory combinables = new IDotNugg.Combinable[](attrs.length);\n\n        for (uint16 i = 0; i < attrs.length; i++) {\n            (IDotNugg.Combinable memory temp, IDotNugg.Base memory tempBase) = _formatForBase(attrs[i], base);\n\n            combinables[i] = temp;\n            base = tempBase;\n        }\n\n        return _combine(combinables, base);\n    }\n\n    function _compressGroups(IDotNugg.Display memory display) internal pure returns (IDotNugg.Display memory) {\n        IDotNugg.Group[] memory res = new IDotNugg.Group[](display.groups.length);\n        IDotNugg.OrderedGroups memory iter = Iterator._newOrderedGroup(display.groups);\n        uint8 activeCount = 1;\n        uint8 activeByte = display.groups[0].colorID;\n        uint16 resIndex = 0;\n        for (; iter._isNext(); ) {\n            iter = iter._getNext();\n            if (activeByte == iter._currentGroup().colorID) {\n                if (activeCount < type(uint8).max) {\n                    activeCount++;\n                    continue;\n                }\n            }\n            res[resIndex++] = IDotNugg.Group({len: activeCount, colorID: activeByte});\n            activeCount = 1;\n            activeByte = iter._currentGroup().colorID;\n        }\n        res[resIndex++] = IDotNugg.Group({len: activeCount, colorID: activeByte});\n\n        IDotNugg.Group[] memory correctSizedGroupArray = new IDotNugg.Group[](resIndex);\n\n        for (uint16 i = 0; i < resIndex; i++) {\n            correctSizedGroupArray[i] = res[i];\n        }\n\n        display.groups = correctSizedGroupArray;\n\n        return display;\n    }\n}\n"
    },
    "contracts/core/libraries/Colors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport './Bytes.sol';\nimport '../interfaces/IDotNugg.sol';\n\nlibrary Colors {\n    using Bytes for bytes;\n\n    function combine(IDotNugg.RGBA8 memory base, IDotNugg.RGBA8 memory mix) internal pure returns (IDotNugg.RGBA8 memory res, bool) {\n        if (mix.a == 255) {\n            return (mix, false);\n        }\n\n        IDotNugg.RGBA16 memory baseRGB = IDotNugg.RGBA16({r: uint16(base.r), g: uint16(base.g), b: uint16(base.b), a: uint16(base.a)});\n        IDotNugg.RGBA16 memory mixRGB = IDotNugg.RGBA16({r: uint16(mix.r), g: uint16(mix.g), b: uint16(mix.b), a: uint16(mix.a)});\n\n        // uint8 alpha = uint8(255 - (((255 - baseRGB.a) * (255 - mixRGB.a)) / 255));\n        uint8 red = uint8((baseRGB.r * (255 - mixRGB.a) + mixRGB.r * mixRGB.a) / 255);\n        uint8 green = uint8((baseRGB.g * (255 - mixRGB.a) + mixRGB.g * mixRGB.a) / 255);\n        uint8 blue = uint8((baseRGB.b * (255 - mixRGB.a) + mixRGB.b * mixRGB.a) / 255);\n\n        return (IDotNugg.RGBA8({r: red, g: green, b: blue, a: 255}), true);\n    }\n\n    function toAscii(IDotNugg.RGBA8 memory base) internal pure returns (string memory res) {\n        bytes memory input = abi.encodePacked(base.r, base.g, base.b, base.a);\n        return input.toAscii();\n    }\n\n    function combine(bytes memory base, bytes memory mix) internal pure returns (IDotNugg.RGBA8 memory res, bool) {\n        IDotNugg.RGBA8 memory baseRGB = IDotNugg.RGBA8({\n            r: base.toUint8(0),\n            g: base.toUint8(1),\n            b: base.toUint8(2),\n            a: base.length > 3 ? base.toUint8(3) : uint8(225)\n        });\n        IDotNugg.RGBA8 memory mixRGB = IDotNugg.RGBA8({\n            r: mix.toUint8(0),\n            g: mix.toUint8(1),\n            b: mix.toUint8(2),\n            a: mix.length > 3 ? mix.toUint8(3) : uint8(225)\n        });\n\n        return combine(baseRGB, mixRGB);\n    }\n}\n"
    },
    "contracts/core/base/Iterator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../interfaces/IDotNugg.sol';\nimport '../../libraries/Uint.sol';\n\nimport '../libraries/Colors.sol';\nimport '../interfaces/IDotNugg.sol';\n\n/**\n * @dev DotNugg calculation.\n */\nlibrary Iterator {\n    function _newOrderedGroup(IDotNugg.Group[] memory groups) internal pure returns (IDotNugg.OrderedGroups memory res) {\n        require(groups.length > 0, 'NEWORDEREDGROUPS: group of len 0');\n        res.groups = groups;\n    }\n\n    function _len(IDotNugg.OrderedGroups memory itr) internal pure returns (uint256 res) {\n        if (itr.idx >= itr.groups.length) return 0;\n        return itr.groups.length - itr.idx + 1;\n    }\n\n    function _isNext(IDotNugg.OrderedGroups memory itr) internal pure returns (bool res) {\n        if (itr.idx + 1 < itr.groups.length) {\n            res = true;\n        } else if (itr.idx + 1 == itr.groups.length) {\n            if (itr.passes < _currentGroup(itr).len) {\n                return true;\n            }\n        }\n    }\n\n    function _getNext(IDotNugg.OrderedGroups memory itr) internal pure returns (IDotNugg.OrderedGroups memory) {\n        if (_isNext(itr)) {\n            if (itr.started == 0) {\n                itr.idx = 0;\n                itr.passes = 1;\n                itr.started = 1;\n                return itr;\n            }\n\n            IDotNugg.Group memory group = _currentGroup(itr);\n\n            if (itr.passes >= group.len) {\n                itr.idx++;\n                itr.passes = 1;\n            } else {\n                itr.passes++;\n            }\n            return itr;\n        }\n        itr.idx = uint16(itr.groups.length);\n        return itr;\n    }\n\n    function _currentGroup(IDotNugg.OrderedGroups memory itr) internal pure returns (IDotNugg.Group memory res) {\n        require(itr.groups.length > 0, '_currentGroup: group of len 0');\n        // if (itr.idx < itr.groups.length) {\n        res = itr.groups[itr.idx];\n        //     ok = true;\n        // }\n    }\n\n    function _newSimpleOrderedGroup(IDotNugg.Group[] memory groups) internal pure returns (IDotNugg.SimpleOrderedGroups memory res) {\n        require(groups.length > 0, 'NEWSIMPLEORDEREDGROUPS: group of len 0');\n        res.groups = groups;\n    }\n\n    function _lenS(IDotNugg.SimpleOrderedGroups memory itr) internal pure returns (uint256 res) {\n        if (itr.idx >= itr.groups.length) return 0;\n        return itr.groups.length - itr.idx + 1;\n    }\n\n    function _isNextS(IDotNugg.SimpleOrderedGroups memory itr) internal pure returns (bool res) {\n        if (itr.idx + 1 < itr.groups.length) {\n            res = true;\n        }\n    }\n\n    function _getNextS(IDotNugg.SimpleOrderedGroups memory itr) internal pure returns (IDotNugg.SimpleOrderedGroups memory) {\n        if (_isNextS(itr)) {\n            if (itr.started == 0) {\n                itr.cumPasses = 0;\n                itr.idx = 0;\n                itr.started = 1;\n                return itr;\n            }\n            IDotNugg.Group memory group = _currentGroupS(itr);\n            itr.idx++;\n            itr.cumPasses += group.len;\n            return itr;\n        }\n        itr.idx = uint16(itr.groups.length);\n        return itr;\n    }\n\n    function _currentGroupS(IDotNugg.SimpleOrderedGroups memory itr) internal pure returns (IDotNugg.Group memory res) {\n        require(itr.groups.length > 0, '_currentGroup: group of len 0');\n        // if (itr.idx < itr.groups.length) {\n        res = itr.groups[itr.idx];\n        //     ok = true;\n        // }\n    }\n}\n"
    },
    "contracts/core/tests/Calculator_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nimport '../libraries/Bytes.sol';\nimport '../libraries/BytesLib.sol';\nimport '../interfaces/IDotNugg.sol';\nimport '../base/Calculator.sol';\n\n\n\n/**\n * @dev  operations.\n */\ncontract Calculator_Test {\n    function formatForBase(IDotNugg.Attribute memory attr, IDotNugg.Base memory base)\n        external\n        pure\n        returns (IDotNugg.Combinable memory res, IDotNugg.Base memory)\n    {\n        return Calculator._formatForBase(attr, base);\n    }\n\n    function expanderLen(IDotNugg.Attribute memory attr, IDotNugg.Base memory base) external pure returns (uint8 res) {\n        return Calculator._expanderLen(attr, base);\n    }\n\n    function verticalExpanderLen(IDotNugg.Attribute memory attr, IDotNugg.Base memory base) external pure returns (uint8 res) {\n        return Calculator._verticalExpanderLen(attr, base);\n    }\n\n    function addHorizontalExpanders(IDotNugg.Attribute memory attr, IDotNugg.Base memory base) external pure returns (IDotNugg.Attribute memory) {\n        return Calculator._addHorizontalExpanders(attr, base);\n    }\n\n    function addVerticalExpanders(IDotNugg.Attribute memory attr, IDotNugg.Base memory base) external pure returns (IDotNugg.Attribute memory) {\n        return Calculator._addVerticalExpanders(attr, base);\n    }\n\n    // returns 0 if false\n    function checkExpander(uint8 id) external pure returns (uint8) {\n        return Calculator._checkExpander(id);\n    }\n\n    // returns 0 if false\n    function checkVerticalExpander(uint8 id) external pure returns (uint8) {\n        return Calculator._checkVerticalExpander(id);\n    }\n\n    function combine(IDotNugg.Combinable[] memory combinables, IDotNugg.Base memory base) external pure returns (IDotNugg.Display memory res) {\n        return Calculator._combine(combinables, base);\n    }\n\n    function newDisplay(IDotNugg.Base memory base, IDotNugg.Attribute[] memory attrs) external pure returns (IDotNugg.Display memory) {\n        return Calculator._newDisplay(base, attrs);\n    }\n\n    function compressGroups(IDotNugg.Display memory display) external pure returns (IDotNugg.Display memory) {\n        return Calculator._compressGroups(display);\n    }\n}\n"
    },
    "contracts/core/DotNuggCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './base/Calculator.sol';\nimport './interfaces/IDotNuggCalculator.sol';\n\nabstract contract DotNuggCalculator is IDotNuggCalculator {\n    function newDisplay(IDotNugg.Base memory base, IDotNugg.Attribute[] memory attrs) external pure override returns (IDotNugg.Display memory) {\n        return Calculator._newDisplay(base, attrs);\n    }\n}\n"
    },
    "contracts/core/DotNugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './DotNuggDecoder.sol';\nimport './DotNuggCalculator.sol';\n\nimport './interfaces/IDotNugg.sol';\n\n/**\n * @title DotNugg V1 - onchain encoder/decoder for dotnugg files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract DotNugg is IDotNugg, DotNuggDecoder, DotNuggCalculator {\n\n}\n"
    },
    "contracts/core/libraries/HexStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport './Bytes.sol';\n\nlibrary HexStrings {\n    bytes32 internal constant ALPHABET = hex'0123456789abcdef';\n    using Bytes for bytes;\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/mock/WETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '../interfaces/IWETH9.sol';\n\n// adapted from WBNB on BSC  https://bscscan.com/address/0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c#code\n\ncontract WETH9 {\n    string public name = 'Wrapped ETH';\n    string public symbol = 'WETH';\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    uint256 private constant _MAX_INT = 2**256 - 1;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    fallback() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        address payable sender = payable(msg.sender);\n        sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != _MAX_INT) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/tests/Epochable_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport '../base/Epochable.sol';\n\npragma solidity 0.8.4;\n\ncontract Epochable_Test is Epochable {\n    constructor(uint16 _interval) Epochable(_interval) {}\n}\n"
    },
    "contracts/tests/EpochMath_Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '../libraries/EpochMath.sol';\n\ncontract EpochMath_Test {\n    function getEpoch(\n        EpochMath.State memory state,\n        uint256 id,\n        uint256 blocknum\n    ) external pure returns (EpochMath.Epoch memory res) {\n        res = EpochMath.getEpoch(state, id, blocknum);\n    }\n\n    function getStatus(\n        EpochMath.State memory state,\n        uint256 id,\n        uint256 blocknum\n    ) external pure returns (EpochMath.Status res) {\n        res = EpochMath.getStatus(state, id, blocknum);\n    }\n\n    function getStartBlockFromId(EpochMath.State memory state, uint256 id) external pure returns (uint256 res) {\n        res = EpochMath.getStartBlockFromId(state, id);\n    }\n\n    function getEndBlockFromId(EpochMath.State memory state, uint256 id) external pure returns (uint256 res) {\n        res = EpochMath.getEndBlockFromId(state, id);\n    }\n\n    function getIdFromBlocknum(EpochMath.State memory state, uint256 blocknum) external pure returns (uint256 res) {\n        res = EpochMath.getIdFromBlocknum(state, blocknum);\n    }\n}\n"
    },
    "contracts/tests/StakeMath_Test.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/StakeMath.sol';\n\n\ncontract StakeMath_Test {\n    function getBalance(StakeMath.State memory state, StakeMath.Position memory pos) external pure returns (uint256 res) {\n        res = StakeMath.getBalance(state, pos);\n    }\n\n    function getOwnershipX128(StakeMath.State memory state, StakeMath.Position memory pos) external pure returns (uint256 res) {\n        res = StakeMath.getOwnershipX128(state, pos);\n    }\n\n    function applyShareIncrease(\n        StakeMath.State memory state,\n        StakeMath.Position memory pos,\n        uint256 tAmount\n    ) external pure returns (StakeMath.State memory, StakeMath.Position memory) {\n        StakeMath.applyShareIncrease(state, pos, tAmount);\n\n        return (state, pos);\n    }\n\n    function applyShareDecrease(\n        StakeMath.State memory state,\n        StakeMath.Position memory pos,\n        uint256 tAmount\n    ) external pure returns (StakeMath.State memory, StakeMath.Position memory) {\n        StakeMath.applyShareDecrease(state, pos, tAmount);\n        return (state, pos);\n    }\n\n    function applyRewardIncrease(StakeMath.State memory state, uint256 amount) external pure returns (StakeMath.State memory) {\n        StakeMath.applyRewardIncrease(state, amount);\n        return (state);\n    }\n}\n"
    },
    "contracts/tests/StakeMath_Echidna.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/StakeMath.sol';\nimport '../libraries/QuadMath.sol';\nimport './QuadMath_Echidna.sol';\n\ncontract StakeMath_Echidna {\n    using StakeMath for StakeMath.State;\n    using QuadMath for uint256;\n\n    // function checkToRewardFromEps(\n    //     uint256 a,\n    //     uint256 b,\n    //     uint8 c,\n    //     uint256 d,\n    //     uint256 e\n    // ) external pure {\n    //     uint256 shares = a;\n    //     uint256 epsX128 = b;\n    //     uint8 sharesPercent = c;\n    //     uint256 earnings = d;\n    //     uint256 amount = e;\n\n    //     StakeMath.State memory state = StakeMath.State({shares: shares, epsX128: epsX128});\n    //     StakeMath.Position memory pos = StakeMath.Position({shares: shares.percent(c % 100), earnings: earnings});\n\n    //     uint256 z = state.convertSharesToEarnings(pos, amount);\n    //     if (x == 0 || y == 0) {\n    //         assert(z == 0);\n    //         return;\n    //     }\n    //     uint256 d = QuadMath._BINARY128;\n    //     // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n    //     uint256 x2 = QuadMath.mulDiv(z, d, y);\n    //     uint256 y2 = QuadMath.mulDiv(z, d, x);\n    //     assert(x2 >= x);\n    //     assert(y2 >= y);\n    //     assert(x2 - x < d);\n    //     assert(y2 - y < d);\n    // }\n\n    // function checkToEpsFromSupply(uint256 x, uint256 d) external pure {\n    //     require(d > 0);\n    //     uint256 z = StakeMath.toEpsX128FromShares(x, d);\n    //     if (x == 0) {\n    //         assert(z == 0);\n    //         return;\n    //     }\n    //     uint256 y = QuadMath._BINARY128;\n    //     // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n    //     uint256 x2 = QuadMath.mulDiv(z, d, y);\n    //     uint256 y2 = QuadMath.mulDiv(z, d, x);\n    //     assert(x2 <= x);\n    //     assert(y2 <= y);\n    //     assert(x - x2 < d);\n    //     assert(y - y2 < d);\n    // }\n}\n"
    },
    "contracts/tests/QuadMath_Echidna.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/QuadMath.sol';\n\ncontract QuadMath_Echidna {\n    function checkMulDivRounding(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n\n        uint256 ceiled = QuadMath.mulDivRoundingUp(x, y, d);\n        uint256 floored = QuadMath.mulDiv(x, y, d);\n\n        if (mulmod(x, y, d) > 0) {\n            assert(ceiled - floored == 1);\n        } else {\n            assert(ceiled == floored);\n        }\n    }\n\n    function checkMulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDiv(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 <= x);\n        assert(y2 <= y);\n\n        assert(x - x2 < d);\n        assert(y - y2 < d);\n    }\n\n    function checkMulDivRoundingUp(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDivRoundingUp(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 >= x);\n        assert(y2 >= y);\n\n        assert(x2 - x < d);\n        assert(y2 - y < d);\n    }\n}\n"
    },
    "contracts/tests/Stakeable_Echidna.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/QuadMath.sol';\n\ncontract Stakeable_Echidna {\n    function checkMulDivRounding(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n\n        uint256 ceiled = QuadMath.mulDivRoundingUp(x, y, d);\n        uint256 floored = QuadMath.mulDiv(x, y, d);\n\n        if (mulmod(x, y, d) > 0) {\n            assert(ceiled - floored == 1);\n        } else {\n            assert(ceiled == floored);\n        }\n    }\n\n    function checkMulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDiv(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 <= x);\n        assert(y2 <= y);\n\n        assert(x - x2 < d);\n        assert(y - y2 < d);\n    }\n\n    function checkMulDivRoundingUp(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) public pure {\n        require(d > 0);\n        uint256 z = QuadMath.mulDivRoundingUp(x, y, d);\n        if (x == 0 || y == 0) {\n            assert(z == 0);\n            return;\n        }\n\n        // recompute x and y via mulDiv of the result of floor(x*y/d), should always be less than original inputs by < d\n        uint256 x2 = QuadMath.mulDiv(z, d, y);\n        uint256 y2 = QuadMath.mulDiv(z, d, x);\n        assert(x2 >= x);\n        assert(y2 >= y);\n\n        assert(x2 - x < d);\n        assert(y2 - y < d);\n    }\n}\n"
    },
    "contracts/tests/QuadMath_Test.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/QuadMath.sol';\n\n\ncontract QuadMath_Test {\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) external pure returns (uint256) {\n        return QuadMath.mulDiv(x, y, z);\n    }\n\n    function mulDivRoundingUp(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) external pure returns (uint256) {\n        return QuadMath.mulDivRoundingUp(x, y, z);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 75
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}