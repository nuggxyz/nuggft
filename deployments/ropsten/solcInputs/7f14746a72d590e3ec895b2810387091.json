{
  "language": "Solidity",
  "sources": {
    "src/_mock/MockDotNuggV1Processer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../interfaces/IdotnuggV1.sol';\nimport '../_test/utils/Print.sol';\n\n/**\n * @title dotnugg V1 - onchain encoder/decoder for dotnugg files\n * @author Nugg Labs - @danny7even & @dub6ix\n * @notice yoU CAN'T HaVe ImAgES oN THe BlOCkcHAIn\n * @dev hold my margarita\n */\ncontract MockdotnuggV1Processor is IdotnuggV1Processor {\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) public view override returns (uint256[] memory resp, IdotnuggV1Data.Data memory dat) {\n        (uint256[][] memory files, IdotnuggV1Data.Data memory data) = IdotnuggV1Implementer(implementer).prepareFiles(tokenId);\n\n        resp = processCore(files, data, width);\n        dat = data;\n    }\n\n    function processCore(\n        uint256[][] memory files,\n        IdotnuggV1Data.Data memory,\n        uint8 width\n    ) public view returns (uint256[] memory file) {\n        Print.log(width, 'width');\n\n        for (uint256 i = 0; i < files.length; i++) {\n            Print.log(files[i], 'files[i]');\n        }\n        return files[0];\n    }\n\n    function resolveBytes(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (bytes memory res) {\n        res = abi.encode(file);\n    }\n\n    function resolveData(\n        uint256[] memory,\n        IdotnuggV1Data.Data memory data,\n        uint8\n    ) public pure override returns (IdotnuggV1Data.Data memory res) {\n        res = data;\n    }\n\n    function resolveString(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (string memory res) {\n        res = string(abi.encode(file));\n    }\n\n    function resolveRaw(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory,\n        uint8\n    ) public pure override returns (uint256[] memory res) {\n        res = file;\n    }\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (uint256[] memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            res = IdotnuggV1Processor(resolver).resolveRaw(res, data, zoom);\n        } else {\n            res = file;\n        }\n    }\n\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (bytes memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IdotnuggV1Processor(resolver).resolveBytes(file, data, zoom);\n    }\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (string memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IdotnuggV1Processor(resolver).resolveString(file, data, zoom);\n    }\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (IdotnuggV1Data.Data memory res) {\n        (uint256[] memory file, IdotnuggV1Data.Data memory data) = process(implementer, tokenId, width);\n\n        res = IdotnuggV1Processor(resolver).resolveData(file, data, zoom);\n    }\n}\n"
    },
    "src/interfaces/IdotnuggV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IdotnuggV1Data {\n    struct Data {\n        uint256 version;\n        uint256 renderedAt;\n        string name;\n        string desc;\n        address owner;\n        uint256 tokenId;\n        uint256 proof;\n        uint8[] ids;\n        uint8[] extras;\n        uint8[] xovers;\n        uint8[] yovers;\n    }\n}\n\ninterface IdotnuggV1Resolver {\n    function resolveBytes(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function resolveRaw(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function resolveData(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (IdotnuggV1Data.Data memory res);\n\n    function resolveString(\n        uint256[] memory file,\n        IdotnuggV1Data.Data memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n}\n\ninterface IdotnuggV1Processor is IdotnuggV1Resolver {\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function dotnuggToData(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (IdotnuggV1Data.Data memory res);\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (string memory res);\n\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) external view returns (uint256[] memory file, IdotnuggV1Data.Data memory dat);\n\n    function processCore(\n        uint256[][] memory files,\n        IdotnuggV1Data.Data memory data,\n        uint8 width\n    ) external view returns (uint256[] memory file);\n}\n\ninterface IdotnuggV1Implementer {\n    function setResolver(uint256 tokenId, address to) external;\n\n    function resolverOf(uint256 tokenId) external view returns (address resolver);\n\n    function prepareFiles(uint256 tokenId) external view returns (uint256[][] memory file, IdotnuggV1Data.Data memory data);\n}\n"
    },
    "src/_test/utils/Print.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n// import './console.sol';\n\nlibrary Print {\n    function log(uint256 val, string memory name) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2\n    ) internal view {\n\n\n\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1\n    ) internal view {\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3\n    ) internal view {\n\n\n\n\n\n    }\n\n    function log(\n        uint256 val0,\n        string memory name0,\n        uint256 val1,\n        string memory name1,\n        uint256 val2,\n        string memory name2,\n        uint256 val3,\n        string memory name3,\n        uint256 val4,\n        string memory name4\n    ) internal view {\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n    function log(uint256[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n\n    function log(uint8[] memory arr, string memory name) internal view {\n\n\n        for (uint256 i = 0; i < arr.length; i++) {\n\n        }\n    }\n}\n\nlibrary Uint256 {\n    bytes16 private constant ALPHABET = '0123456789abcdef';\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toAscii(uint256 value) internal pure returns (bytes memory buffer) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return buffer;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        return string(toAscii(value));\n    }\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// library Event {\n//     function log(uint256 val, string memory name) internal view {}\n\n//     function log(\n//         uint256 val0,\n//         string memory name0,\n//         uint256 val1,\n//         string memory name1,\n//         uint256 val2,\n//         string memory name2\n//     ) internal view {}\n\n//     function log(uint256[] memory arr, string memory name) internal view {}\n// }\n"
    },
    "src/_mock/MockNuggFTV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../interfaces/INuggFTV1Migrator.sol';\nimport '../_test/utils/Print.sol';\n\ncontract MockNuggFTV1Migrator is INuggFTV1Migrator {\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable override {\n        Print.log(tokenId, 'tokenId', proof, 'proof', uint160(owner), 'owner', msg.value, 'msg.value', uint160(msg.sender), 'msg.sender');\n        emit MigrateV1Accepted(msg.sender, tokenId, proof, owner, uint96(msg.value));\n    }\n}\n"
    },
    "src/interfaces/INuggFTV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggFTV1Migrator {\n    event MigrateV1Accepted(address v1, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable;\n}\n"
    },
    "src/stake/StakeCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggFTV1Migrator} from '../interfaces/INuggFTV1Migrator.sol';\n\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {TokenCore} from '../token/TokenCore.sol';\nimport {TokenView} from '../token/TokenView.sol';\nimport {ProofView} from '../proof/ProofView.sol';\n\nimport {StakePure} from './StakePure.sol';\nimport {StakeView} from './StakeView.sol';\nimport {Stake} from './StakeStorage.sol';\nimport {Trust} from '../trust/TrustStorage.sol';\n\n// SYSTEM\n/// @title A title that should describe the contract/interface\n/// @author dub6ix\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\nlibrary StakeCore {\n    using StakePure for uint256;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event StakeEth(uint96 stake, uint96 protocol);\n    event UnStakeEth(uint96 stake, address to);\n    event ProtocolEthExtracted(uint96 eth);\n    event MigratorV1Updated(address migrator);\n    event MigrateV1Sent(address v2, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 TRUSTED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function trustedExtractProtocolEth(Trust.Storage storage trust) internal {\n        require(trust._isTrusted, 'T:0');\n\n        uint256 cache = Stake.sload();\n\n        uint96 eth = cache.getProtocolEth();\n\n        SafeTransferLib.safeTransferETH(msg.sender, eth);\n\n        Stake.sstore(cache.setProtocolEth(0));\n\n        emit ProtocolEthExtracted(eth);\n    }\n\n    function trustedSetMigrator(Trust.Storage storage trust, address migrator) internal {\n        require(trust._isTrusted, 'T:1');\n\n        Stake.spointer().trustedMigrator = migrator;\n\n        emit MigratorV1Updated(migrator);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 ADD\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function addStakedShareAndEth(uint96 eth) internal {\n        uint256 cache = Stake.sload();\n\n        (uint64 activeShares, uint96 activeEth, uint96 activeProtocolEth) = cache.getStakedSharesAndEth();\n\n        require(eth >= cache.getMinSharePrice(), 'ST:0');\n\n        uint96 protocol = (eth * StakePure.PROTOCOL_FEE_BPS) / 10000;\n\n        eth -= protocol;\n\n        Stake.sstore(cache.setStakedShares(activeShares + 1).setStakedEth(activeEth + eth).setProtocolEth(activeProtocolEth + protocol));\n\n        emit StakeEth(eth, protocol);\n    }\n\n    function addStakedEth(uint96 amount) internal {\n        uint256 cache = Stake.sload();\n\n        uint96 protocol = (amount * StakePure.PROTOCOL_FEE_BPS) / 10000;\n\n        amount -= protocol;\n\n        Stake.sstore(cache.setStakedEth(cache.getStakedEth() + amount).setProtocolEth(cache.getProtocolEth() + protocol));\n\n        emit StakeEth(amount, protocol);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                BURN/MIGRATE\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function migrateStakedShare(uint160 tokenId) internal {\n        address migrator = Stake.spointer().trustedMigrator;\n\n        require(migrator != address(0));\n\n        uint256 proof = ProofView.checkedProofOf(tokenId);\n\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        INuggFTV1Migrator(migrator).nuggftMigrateFromV1{value: ethOwed}(tokenId, proof, msg.sender);\n\n        emit MigrateV1Sent(migrator, tokenId, proof, msg.sender, ethOwed);\n    }\n\n    function burnStakedShare(uint160 tokenId) internal {\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        SafeTransferLib.safeTransferETH(msg.sender, ethOwed);\n    }\n\n    function subStakedShare(uint160 tokenId) private returns (uint96 ethOwed) {\n        require(TokenView.ownerOf(tokenId) == msg.sender, 'SC:9');\n\n        uint256 cache = Stake.sload();\n\n        TokenCore.onBurn(tokenId);\n\n        (uint64 activeShares, uint96 activeEth, ) = cache.getStakedSharesAndEth();\n\n        ethOwed = cache.getEthPerShare();\n\n        require(activeShares >= 1, 'SC:10');\n        require(activeEth >= ethOwed, 'SC:11');\n\n        Stake.sstore(cache.setStakedShares(activeShares - 1).setStakedEth(activeEth - ethOwed));\n\n        emit UnStakeEth(ethOwed, msg.sender);\n    }\n}\n"
    },
    "src/libraries/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721Receiver} from '../interfaces/IERC721.sol';\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\nlibrary SafeTransferLib {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            ETH OPERATIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, 'ETH_TRANSFER_FAILED');\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            NFT OPERATIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function isERC721Receiver(address to, uint256 tokenId) internal returns (bool) {\n        if (SafeTransferLib.isDeployedContract(to)) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, address(this), tokenId, '') returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function isDeployedContract(address account) internal view returns (bool res) {\n        res = account.code.length != 0;\n    }\n}\n"
    },
    "src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from './SafeCastLib.sol';\n\nlibrary ShiftLib {\n    using SafeCastLib for uint256;\n\n    /// @notice creates a bit mask\n    /// @dev res = (2 ^ bits) - 1\n    /// @param bits d\n    /// @return res d\n    /// @dev no need to check if \"bits\" is < 256 as anything greater than 255 will be treated the same\n    function mask(uint8 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(shl(bits, 1), 1)\n        }\n    }\n\n    function fullsubmask(uint8 bits, uint8 pos) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << pos);\n    }\n\n    function set(\n        uint256 preStore,\n        uint8 bits,\n        uint8 pos,\n        uint256 value\n    ) internal pure returns (uint256 postStore) {\n        postStore = preStore & fullsubmask(bits, pos);\n\n        assembly {\n            value := shl(pos, value)\n        }\n\n        postStore |= value;\n    }\n\n    function get(\n        uint256 store,\n        uint8 bits,\n        uint8 pos\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := shr(pos, store)\n        }\n        value &= mask(bits);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                ARRAYS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function getArray(uint256 store, uint8 pos) internal pure returns (uint8[] memory arr) {\n        store = get(store, 64, pos);\n\n        arr = new uint8[](8);\n        for (uint256 i = 0; i < 8; i++) {\n            arr[i] = uint8(store & 0xff);\n            store >>= 8;\n        }\n    }\n\n    function setArray(\n        uint256 store,\n        uint8 pos,\n        uint8[] memory arr\n    ) internal pure returns (uint256 res) {\n        for (uint256 i = 8; i > 0; i--) {\n            res |= uint256(arr[i - 1]) << ((8 * (i - 1)));\n        }\n\n        res = set(store, 64, pos, res);\n    }\n}\n"
    },
    "src/token/TokenCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {Token} from './TokenStorage.sol';\nimport {Global} from '../global/GlobalStorage.sol';\n\nimport {TokenView} from './TokenView.sol';\n\nimport {StakeCore} from '../stake/StakeCore.sol';\nimport {ProofCore} from '../proof/ProofCore.sol';\n\nimport {Trust} from '../trust/TrustStorage.sol';\n\n// system test\nlibrary TokenCore {\n    using SafeCastLib for uint256;\n\n    uint32 constant TRUSTED_MINT_TOKENS = 500;\n    uint32 constant UNTRUSTED_MINT_TOKENS = 2500;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event TrustedMint(address indexed to, uint160 tokenId);\n    event UntrustedMint(address indexed by, uint160 tokenId);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                APPROVAL\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function checkedSetApprovalForAll(address operator, bool approved) internal {\n        require(msg.sender != operator && operator == address(this), 'T:0');\n\n        Token.ptr().operatorApprovals[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function checkedApprove(address account, uint160 tokenId) internal {\n        address owner = TokenView.ownerOf(tokenId);\n\n        // ERC721: approval to current owner\n        require(account != owner, 'T:3');\n\n        // ERC721: approve caller is not owner nor approved for all\n        require(msg.sender == owner || TokenView.isApprovedForAll(owner, msg.sender), 'T:1');\n\n        Token.ptr().approvals[tokenId] = account;\n\n        emit Approval(owner, account, tokenId);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRANSFER\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function untrustedMint(uint160 tokenId) internal {\n        require(tokenId < UNTRUSTED_MINT_TOKENS + TRUSTED_MINT_TOKENS && tokenId > TRUSTED_MINT_TOKENS, 'T:1');\n\n        require(!TokenView.exists(tokenId), 'T:2');\n\n        StakeCore.addStakedShareAndEth(msg.value.safe96());\n\n        ProofCore.setProof(tokenId);\n\n        checkedMintTo(msg.sender, tokenId);\n\n        emit UntrustedMint(msg.sender, tokenId);\n    }\n\n    function trustedMint(\n        Trust.Storage storage trust,\n        address to,\n        uint160 tokenId\n    ) internal {\n        require(trust._isTrusted, 'T:0');\n\n        require(tokenId < TRUSTED_MINT_TOKENS && tokenId != 0, 'T:1');\n\n        require(!TokenView.exists(tokenId), 'T:2');\n\n        StakeCore.addStakedShareAndEth(msg.value.safe96());\n\n        ProofCore.setProof(tokenId);\n\n        checkedMintTo(to, tokenId);\n\n        emit TrustedMint(to, tokenId);\n    }\n\n    // token does not exist and is < 1000\n\n    function checkedTransferFromSelf(address to, uint160 tokenId) internal {\n        require(SafeTransferLib.isERC721Receiver(to, tokenId), 'T:2');\n\n        Token.ptr().balances[address(this)] -= 1;\n        Token.ptr().balances[to] += 1;\n        Token.ptr().owners[tokenId] = to;\n\n        emit Transfer(address(this), to, tokenId);\n    }\n\n    function approvedTransferToSelf(uint160 tokenId) internal {\n        // ERC721: transfer caller is not owner nor approved\n        require(msg.sender == TokenView.ownerOf(tokenId) && TokenView.getApproved(tokenId) == address(this), 'T:4');\n\n        Token.ptr().balances[msg.sender] -= 1;\n        Token.ptr().balances[address(this)] += 1;\n        Token.ptr().owners[tokenId] = address(this);\n\n        // Clear approvals from the previous owner\n        delete Token.ptr().approvals[tokenId];\n\n        emit Approval(address(this), address(0), tokenId);\n\n        emit Transfer(msg.sender, address(this), tokenId);\n    }\n\n    function checkedMintTo(address to, uint160 tokenId) internal {\n        // ERC721: transfer caller is not owner nor approved\n        require(SafeTransferLib.isERC721Receiver(to, tokenId), 'T:5');\n\n        Token.ptr().balances[to] += 1;\n        Token.ptr().owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function onBurn(uint160 tokenId) internal {\n        require(TokenView.getApproved(tokenId) == address(this), 'T:6');\n\n        require(TokenView.ownerOf(tokenId) == msg.sender, 'T:7');\n\n        delete Token.ptr().owners[tokenId];\n        delete Token.ptr().approvals[tokenId];\n\n        delete Global.ptr().swap.map[tokenId];\n        delete Global.ptr().loan.map[tokenId];\n        delete Global.ptr().proof.map[tokenId];\n        delete Global.ptr().file.resolvers[tokenId];\n\n        emit Approval(msg.sender, address(0), tokenId);\n\n        Token.ptr().balances[msg.sender] -= 1;\n\n        emit Transfer(msg.sender, address(0), tokenId);\n    }\n}\n"
    },
    "src/token/TokenView.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Token} from './TokenStorage.sol';\n\n// OK\nlibrary TokenView {\n    function exists(uint160 tokenId) internal view returns (bool) {\n        return Token.ptr().owners[tokenId] != address(0);\n    }\n\n    function isApprovedForAll(address owner, address operator) internal view returns (bool) {\n        return Token.ptr().operatorApprovals[owner][operator];\n    }\n\n    function getApproved(uint160 tokenId) internal view returns (address) {\n        require(exists(tokenId), 'T:9');\n        return Token.ptr().approvals[tokenId];\n    }\n\n    function ownerOf(uint160 tokenId) internal view returns (address owner) {\n        owner = Token.ptr().owners[tokenId];\n        require(owner != address(0), 'T:A');\n    }\n\n    function balanceOf(address owner) internal view returns (uint256) {\n        require(owner != address(0), 'T:B');\n        return Token.ptr().balances[owner];\n    }\n\n    function isApprovedOrOwner(address spender, uint160 tokenId) internal view returns (bool) {\n        address owner = TokenView.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n}\n"
    },
    "src/proof/ProofView.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {Global} from '../global/GlobalStorage.sol';\n\nimport {EpochCore} from '../epoch/EpochCore.sol';\n\nimport {ProofCore} from './ProofCore.sol';\n\nimport {ProofPure} from './ProofPure.sol';\n\nimport {Proof} from './ProofStorage.sol';\n\n// OK\nlibrary ProofView {\n    function checkedProofOf(uint160 tokenId) internal view returns (uint256 res) {\n        res = Proof.get(tokenId);\n        require(res != 0, 'PROOF:PO:0');\n    }\n\n    function checkedProofOfIncludingPending(uint160 tokenId) internal view returns (uint256 res) {\n        (uint256 seed, uint256 epoch, uint256 proof, ) = ProofCore.pendingProof();\n\n        if (epoch == tokenId && seed != 0) return proof;\n\n        res = Proof.get(tokenId);\n\n        require(res != 0, 'PO:1');\n    }\n\n    function hasProof(uint160 tokenId) internal view returns (bool res) {\n        res = Proof.get(tokenId) != 0;\n    }\n\n    function parsedProofOfIncludingPending(uint160 tokenId)\n        internal\n        view\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory extraIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        )\n    {\n        proof = checkedProofOfIncludingPending(tokenId);\n\n        return ProofPure.fullProof(proof);\n    }\n}\n"
    },
    "src/stake/StakePure.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nlibrary StakePure {\n    /// 96 protocol\n    /// 96 stakedEth\n    /// 64 stakedShares\n\n    uint96 constant PROTOCOL_FEE_BPS = 1000;\n\n    // @test input output unit test\n    function getProtocolEth(uint256 cache) internal pure returns (uint96 res) {\n        // using casting to select only 96\n        res = uint96(cache);\n    }\n\n    function setProtocolEth(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        res = cache & ShiftLib.fullsubmask(96, 0);\n        res |= update;\n    }\n\n    // @test input output unit test\n    function getStakedEth(uint256 cache) internal pure returns (uint96 res) {\n        // using casting to select only 96\n        res = uint96(cache >> 96);\n    }\n\n    function setStakedEth(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        // clear stakedEth\n        res = cache & ShiftLib.fullsubmask(96, 96);\n        res |= uint256(update) << 96;\n    }\n\n    // @test input output unit test\n    function getStakedShares(uint256 cache) internal pure returns (uint64 res) {\n        res = uint64(cache >> 192);\n    }\n\n    function setStakedShares(uint256 cache, uint64 update) internal pure returns (uint256 res) {\n        res = cache & type(uint192).max;\n        res |= (uint256(update) << 192);\n    }\n\n    // @test manual ish - combined input output\n    function getStakedSharesAndEth(uint256 cache)\n        internal\n        pure\n        returns (\n            uint64 shares,\n            uint96 eth,\n            uint96 proto\n        )\n    {\n        shares = getStakedShares(cache);\n        eth = getStakedEth(cache);\n        proto = getProtocolEth(cache);\n    }\n\n    // @test manual\n    function getMinSharePrice(uint256 cache) internal pure returns (uint96 res) {\n        res = getEthPerShare(cache);\n        res += (res * (getStakedShares(cache) + PROTOCOL_FEE_BPS)) / 10000;\n    }\n\n    // @test manual\n    function getEthPerShare(uint256 cache) internal pure returns (uint96 res) {\n        res = getStakedShares(cache) == 0 ? 0 : getStakedEth(cache) / getStakedShares(cache);\n    }\n}\n"
    },
    "src/stake/StakeView.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Global} from '../global/GlobalStorage.sol';\n\nimport {StakePure} from './StakePure.sol';\n\nimport {Stake} from './StakeStorage.sol';\n\n/// @title StakeView\n/// @author dub6ix\n/// @notice functions that combine access to Stake storage and logic for access by outside modules\nlibrary StakeView {\n    using StakePure for uint256;\n\n    function getActiveEthPerShare() internal view returns (uint96 res) {\n        res = Stake.sload().getEthPerShare();\n    }\n\n    function getMinSharePrice() internal view returns (uint96 res) {\n        res = Stake.sload().getMinSharePrice();\n    }\n\n    function getActiveStakedShares() internal view returns (uint64 res) {\n        res = Stake.sload().getStakedShares();\n    }\n\n    function getActiveStakedEth() internal view returns (uint96 res) {\n        res = Stake.sload().getStakedEth();\n    }\n\n    function getActiveProtocolEth() internal view returns (uint96 res) {\n        res = Stake.sload().getProtocolEth();\n    }\n}\n"
    },
    "src/stake/StakeStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Global} from '../global/GlobalStorage.sol';\n\nlibrary Stake {\n    struct Storage {\n        address trustedMigrator;\n        uint256 data;\n    }\n\n    function sstore(uint256 input) internal {\n        Global.ptr().stake.data = input;\n    }\n\n    function spointer() internal view returns (Storage storage s) {\n        return Global.ptr().stake;\n    }\n\n    function sload() internal view returns (uint256 res) {\n        return Global.ptr().stake.data;\n    }\n}\n"
    },
    "src/trust/TrustStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary Trust {\n    struct Storage {\n        bool _isTrusted;\n    }\n}\n"
    },
    "src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "src/libraries/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n// OK\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        require(x <= type(uint160).max);\n        y = uint160(x);\n    }\n\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        require(x <= type(uint96).max);\n        y = uint96(x);\n    }\n\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        require(x <= type(uint64).max);\n        y = uint64(x);\n    }\n\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        require(x <= type(uint32).max);\n        y = uint32(x);\n    }\n\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        require(x <= type(uint16).max);\n        y = uint16(x);\n    }\n\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        require(x <= type(uint8).max);\n        y = uint8(x);\n    }\n}\n"
    },
    "src/token/TokenStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Global} from '../global/GlobalStorage.sol';\n\n// OK\nlibrary Token {\n    struct Storage {\n        mapping(uint256 => address) owners;\n        mapping(address => uint256) balances;\n        mapping(uint256 => address) approvals;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    function ptr() internal view returns (Storage storage s) {\n        return Global.ptr().token;\n    }\n}\n"
    },
    "src/global/GlobalStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {File} from '../file/FileStorage.sol';\nimport {Stake} from '../stake/StakeStorage.sol';\nimport {Swap} from '../swap/SwapStorage.sol';\nimport {Proof} from '../proof/ProofStorage.sol';\nimport {Token} from '../token/TokenStorage.sol';\nimport {Loan} from '../loan/LoanStorage.sol';\n\nlibrary Global {\n    struct Storage {\n        Token.Storage token;\n        Stake.Storage stake;\n        File.Storage file;\n        Proof.Storage proof;\n        Loan.Mapping loan;\n        Swap.Full swap;\n    }\n\n    function ptr() internal pure returns (Storage storage s) {\n        assembly {\n            s.slot := 0x42069\n        }\n    }\n}\n"
    },
    "src/proof/ProofCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {EpochCore} from '../epoch/EpochCore.sol';\n\nimport {Proof} from './ProofStorage.sol';\n\nimport {ProofPure} from './ProofPure.sol';\nimport {ProofView} from './ProofView.sol';\n\nimport {TokenView} from '../token/TokenView.sol';\n\nimport {FileView} from '../file/FileView.sol';\nimport {File} from '../file/FileStorage.sol';\nimport {Trust} from '../trust/TrustStorage.sol';\n\n// OK\nlibrary ProofCore {\n    using SafeCastLib for uint256;\n    using ProofPure for uint256;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event SetProof(uint160 tokenId, uint256 proof, uint8[] items);\n    event PopItem(uint160 tokenId, uint256 proof, uint16 itemId);\n    event PushItem(uint160 tokenId, uint256 proof, uint16 itemId);\n    event RotateItem(uint160 tokenId, uint256 proof, uint8 feature);\n    event SetAnchorOverrides(uint160 tokenId, uint256 proof, uint8[] xs, uint8[] ys);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            EXTERNAL MANAGEMENT\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function rotateFeature(uint160 tokenId, uint8 feature) internal {\n        require(TokenView.ownerOf(tokenId) == msg.sender, 'PC:2');\n\n        uint256 working = ProofView.checkedProofOf(tokenId);\n\n        working = ProofPure.rotateDefaultandExtra(working, feature);\n\n        working = ProofPure.clearAnchorOverridesForFeature(working, feature);\n\n        Proof.set(tokenId, working);\n\n        emit RotateItem(tokenId, working, feature);\n    }\n\n    function setAnchorOverrides(\n        uint160 tokenId,\n        uint8[] memory xs,\n        uint8[] memory ys\n    ) internal {\n        require(TokenView.ownerOf(tokenId) == msg.sender, 'PC:2');\n\n        require(xs.length == 8 && ys.length == 8, 'PC:3');\n\n        uint256 working = ProofView.checkedProofOf(tokenId);\n\n        working = ProofPure.setNewAnchorOverrides(working, xs, ys);\n\n        Proof.set(tokenId, working);\n\n        emit SetAnchorOverrides(tokenId, working, xs, ys);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            SWAP MANAGEMENT\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function addItem(uint160 tokenId, uint16 itemId) internal {\n        require(TokenView.ownerOf(tokenId) == msg.sender, 'PC:0');\n\n        uint256 working = ProofView.checkedProofOf(tokenId);\n\n        require(Proof.ptr().protcolItems[itemId] > 0, 'RC:3');\n\n        Proof.ptr().protcolItems[itemId]--;\n\n        working = ProofPure.pushToExtra(working, itemId);\n\n        Proof.set(tokenId, working);\n\n        emit PushItem(tokenId, working, itemId);\n    }\n\n    function removeItem(uint160 tokenId, uint16 itemId) internal {\n        require(TokenView.ownerOf(tokenId) == msg.sender, 'PC:1');\n\n        uint256 working = ProofView.checkedProofOf(tokenId);\n\n        working = ProofPure.pullFromExtra(working, itemId);\n\n        Proof.set(tokenId, working);\n\n        Proof.ptr().protcolItems[itemId]++;\n\n        emit PopItem(tokenId, working, itemId);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            INITIALIZATION\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function setProof(uint160 tokenId) internal {\n        require(!ProofView.hasProof(tokenId), 'P:0');\n\n        uint256 randomEnoughSeed = uint256(keccak256(abi.encodePacked(hex'420690', tokenId, blockhash(block.number - 1))));\n\n        require(randomEnoughSeed != 0, 'P:1');\n\n        (uint256 res, uint8[] memory picks) = ProofCore.initFromSeed(randomEnoughSeed);\n\n        Proof.set(tokenId, res);\n\n        emit SetProof(tokenId, res, picks);\n    }\n\n    function setProofFromEpoch(uint160 tokenId) internal {\n        require(!ProofView.hasProof(tokenId), 'P:2');\n\n        (uint256 seed, uint256 epoch, uint256 res, uint8[] memory picks) = pendingProof();\n\n        require(seed != 0, 'P:3');\n        require(epoch == tokenId, 'P:4');\n\n        Proof.set(tokenId, res);\n\n        emit SetProof(tokenId, res, picks);\n    }\n\n    // TODO TO BE TESTED\n    function initFromSeed(uint256 seed) internal view returns (uint256 res, uint8[] memory upd) {\n        require(seed != 0, 'P:6');\n\n        uint8[] memory lengths = FileView.totalLengths();\n\n        upd = new uint8[](8);\n\n        uint8[] memory picks = ShiftLib.getArray(seed, 0);\n\n        upd[0] = (picks[0] % lengths[0]) + 1;\n        upd[1] = (picks[1] % lengths[1]) + 1;\n        upd[2] = (picks[2] % lengths[2]) + 1;\n\n        if (picks[3] < 96) upd[3] = (picks[4] % lengths[3]) + 1;\n        else if (picks[3] < 192) upd[4] = (picks[4] % lengths[4]) + 1;\n        else if (picks[3] < 250) upd[5] = (picks[4] % lengths[5]) + 1;\n        else upd[6] = (picks[4] % lengths[6]) + 1;\n\n        res = ShiftLib.setArray(res, 0, upd);\n    }\n\n    function pendingProof()\n        internal\n        view\n        returns (\n            uint256 seed,\n            uint256 epoch,\n            uint256 proof,\n            uint8[] memory defaultIds\n        )\n    {\n        (seed, epoch) = EpochCore.calculateSeed();\n\n        (proof, defaultIds) = ProofCore.initFromSeed(seed);\n    }\n}\n"
    },
    "src/file/FileStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Global} from '../global/GlobalStorage.sol';\n\n// TESTED\nlibrary File {\n    struct Storage {\n        uint256 lengthData;\n        mapping(uint8 => uint168[]) ptrs;\n        // Mapping from token ID to owner address\n        mapping(uint256 => address) resolvers;\n    }\n\n    function spointer() internal view returns (Storage storage s) {\n        return Global.ptr().file;\n    }\n}\n"
    },
    "src/swap/SwapStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Global} from '../global/GlobalStorage.sol';\n\nimport {SwapPure} from './SwapPure.sol';\n\nimport {EpochCore} from '../epoch/EpochCore.sol';\n\n// SYSTEM TEST\nlibrary Swap {\n    using SwapPure for uint256;\n\n    struct Full {\n        mapping(uint160 => Mapping) map;\n    }\n\n    struct Mapping {\n        Storage self;\n        mapping(uint16 => Storage) items;\n    }\n\n    struct Storage {\n        uint256 data;\n        mapping(uint160 => uint256) offers;\n    }\n\n    struct Memory {\n        uint256 swapData;\n        uint256 offerData;\n        uint32 activeEpoch;\n        uint160 sender;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TOKEN SWAP\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function _tokenSwapPtr(uint160 tokenId) private view returns (Storage storage si) {\n        return Global.ptr().swap.map[tokenId].self;\n    }\n\n    function loadTokenSwap(uint160 tokenId, address account) internal view returns (Storage storage s, Memory memory m) {\n        s = _tokenSwapPtr(tokenId);\n        m = _load(s, uint160(account));\n    }\n\n    function deleteTokenOffer(uint160 tokenId, uint160 account) internal {\n        delete _tokenSwapPtr(tokenId).offers[account];\n    }\n\n    function deleteTokenSwap(uint160 tokenId) internal {\n        delete _tokenSwapPtr(tokenId).data;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                ITEM SWAP\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function _itemSwapPtr(uint160 tokenId, uint16 itemId) private view returns (Storage storage si) {\n        return Global.ptr().swap.map[tokenId].items[itemId];\n    }\n\n    function loadItemSwap(\n        uint160 tokenId,\n        uint16 itemId,\n        uint160 account\n    ) internal view returns (Storage storage s, Memory memory m) {\n        s = _itemSwapPtr(tokenId, itemId);\n        m = _load(s, account);\n    }\n\n    function deleteItemOffer(\n        uint160 tokenId,\n        uint16 itemId,\n        uint160 account\n    ) internal {\n        delete _itemSwapPtr(tokenId, itemId).offers[account];\n    }\n\n    function deleteItemSwap(uint160 tokenId, uint16 itemId) internal {\n        delete _itemSwapPtr(tokenId, itemId).data;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                COMMON\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function _load(Storage storage ptr, uint160 account) private view returns (Memory memory m) {\n        uint256 cache = ptr.data;\n        m.swapData = cache;\n        m.activeEpoch = EpochCore.activeEpoch();\n        m.sender = account;\n\n        if (account == cache.account()) {\n            m.offerData = cache;\n        } else {\n            m.offerData = ptr.offers[account];\n        }\n    }\n}\n"
    },
    "src/proof/ProofStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport {Global} from '../global/GlobalStorage.sol';\n\npragma solidity 0.8.9;\n\n// OK\nlibrary Proof {\n    struct Storage {\n        mapping(uint256 => uint256) map;\n        mapping(uint256 => uint256) protcolItems;\n    }\n\n    function ptr() internal view returns (Storage storage s) {\n        s = Global.ptr().proof;\n    }\n\n    function get(uint160 tokenId) internal view returns (uint256) {\n        return ptr().map[tokenId];\n    }\n\n    function set(uint160 tokenId, uint256 data) internal {\n        ptr().map[tokenId] = data;\n    }\n}\n"
    },
    "src/loan/LoanStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Global} from '../global/GlobalStorage.sol';\n\nlibrary Loan {\n    struct Mapping {\n        mapping(uint256 => uint256) map;\n    }\n\n    function sstore(uint160 tokenId, uint256 data) internal {\n        Global.ptr().loan.map[tokenId] = data;\n    }\n\n    function spurge(uint160 tokenId) internal {\n        delete Global.ptr().loan.map[tokenId];\n    }\n\n    function sload(uint160 tokenId) internal view returns (uint256) {\n        return Global.ptr().loan.map[tokenId];\n    }\n}\n"
    },
    "src/swap/SwapPure.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\n/// @title SwapPure\n/// @author dub6ix.eth\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\nlibrary SwapPure {\n    using SafeCastLib for uint256;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            CALCULATION\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // @test  manual\n    function addIncrement(uint256 value) internal pure returns (uint256) {\n        return (value * 10100) / 10000;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            SHIFT HELPERS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n    // @test input output unit test\n    // type(uint96).max / 10**13 = 0x01C25C268497681 =  7922816251426433\n    // type(uint56).max          = 0x100000000000000 = 72057594037927936\n    function eth(uint256 input) internal pure returns (uint96 res) {\n        return (ShiftLib.get(input, 56, 160) * 0x9184E72A000).safe96();\n    }\n\n    function eth(uint256 input, uint96 update) internal pure returns (uint256 cache, uint96 rem) {\n        rem = update % uint96(0x9184E72A000);\n        cache = ShiftLib.set(input, 56, 160, update / uint96(0x9184E72A000));\n    }\n\n    // @test  input output unit test\n    function epoch(uint256 input, uint32 update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 32, 216, update);\n    }\n\n    function epoch(uint256 input) internal pure returns (uint32 res) {\n        return ShiftLib.get(input, 32, 216).safe32();\n    }\n\n    // @test  input output unit test\n    function account(uint256 input) internal pure returns (uint160 res) {\n        res = ShiftLib.get(input, 160, 0).safe160();\n    }\n\n    function account(uint256 input, uint160 update) internal pure returns (uint256 output) {\n        output = ShiftLib.set(input, 160, 0, update);\n    }\n\n    // @test  input output unit test\n    function isOwner(uint256 input, bool update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 1, 255, update ? 0x1 : 0x0);\n    }\n\n    function isOwner(uint256 input) internal pure returns (bool output) {\n        output = ShiftLib.get(input, 1, 255) == 0x1;\n    }\n\n    // @test  check to see if it does this - will be easy\n    function flag(uint256 input) internal pure returns (uint256 res) {\n        res = ShiftLib.set(input, 1, 254, 0x01);\n    }\n\n    // @test  manual\n    function buildSwapData(\n        uint32 _epoch,\n        uint160 _account,\n        uint96 _eth,\n        bool _isOwner\n    ) internal pure returns (uint256 res, uint96 dust) {\n        res = epoch(res, _epoch);\n        res = account(res, _account);\n        if (_isOwner) res = isOwner(res, true);\n        (res, dust) = eth(res, _eth);\n        res = flag(res);\n    }\n\n    // @test  manual\n    function updateSwapData(\n        uint256 data,\n        uint160 _account,\n        uint96 _eth\n    )\n        internal\n        pure\n        returns (\n            uint256 res,\n            uint256 increment,\n            uint256 dust\n        )\n    {\n        return updateSwapDataWithEpoch(data, epoch(data), _account, _eth);\n    }\n\n    // @test  unit\n    function updateSwapDataWithEpoch(\n        uint256 data,\n        uint32 _epoch,\n        uint160 _account,\n        uint96 _eth\n    )\n        internal\n        pure\n        returns (\n            uint256 res,\n            uint96 increment,\n            uint96 dust\n        )\n    {\n        uint96 baseEth = eth(data);\n\n        require(addIncrement(baseEth) < _eth);\n\n        (res, dust) = buildSwapData(_epoch, _account, _eth, false);\n\n        increment = _eth - baseEth;\n    }\n}\n"
    },
    "src/epoch/EpochCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\n// MANUAL\nlibrary EpochCore {\n    using SafeCastLib for uint256;\n\n    struct Storage {\n        uint32 genesis;\n    }\n\n    uint256 constant INTERVAL = 0xff;\n    uint32 constant OFFSET = 3000;\n\n    function setGenesis() internal {\n        Storage storage s;\n        assembly {\n            s.slot := 0x100042069\n        }\n\n        s.genesis = uint32(block.number);\n    }\n\n    function getGenesis() internal view returns (uint32) {\n        Storage storage s;\n\n        assembly {\n            s.slot := 0x100042069\n        }\n\n        return s.genesis;\n    }\n\n    function toStartBlock(uint32 epoch) internal view returns (uint256 res) {\n        res = ((epoch - OFFSET) * INTERVAL) + getGenesis();\n    }\n\n    function toEpoch(uint256 blocknum) internal view returns (uint32 res) {\n        res = (((blocknum - getGenesis()) / INTERVAL) + OFFSET).safe32();\n    }\n\n    function toEndBlock(uint32 epoch) internal view returns (uint256 res) {\n        res = toStartBlock(epoch + 1) - 1;\n    }\n\n    function activeEpoch() internal view returns (uint32 res) {\n        res = toEpoch(block.number);\n    }\n\n    /// @notice gets unique base based on given epoch and converts encoded bytes to object that can be merged\n    /// Note: by using the block hash no one knows what a nugg will look like before it's epoch.\n    /// We considered making this harder to manipulate, but we decided that if someone were able to\n    /// pull it off and make their own custom nugg, that would be really fucking cool.\n    function calculateSeed() internal view returns (uint256 res, uint32 epoch) {\n        epoch = activeEpoch();\n        uint256 startblock = toStartBlock(epoch);\n        bytes32 bhash = blockhash(startblock - 1);\n        require(bhash != 0, 'EPC:SBL');\n        res = uint256(keccak256(abi.encodePacked(bhash, epoch, address(this))));\n    }\n}\n"
    },
    "src/proof/ProofPure.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {FilePure} from '../file/FilePure.sol';\n\nlibrary ProofPure {\n    using ShiftLib for uint256;\n\n    function fullProof(uint256 input)\n        internal\n        pure\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory extraIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        )\n    {\n        proof = input;\n        defaultIds = ShiftLib.getArray(proof, 0);\n        extraIds = ShiftLib.getArray(proof, 64);\n        overxs = ShiftLib.getArray(proof, 128);\n        overys = ShiftLib.getArray(proof, 192);\n    }\n\n    function pushToExtra(uint256 input, uint16 itemId) internal pure returns (uint256 res) {\n        uint8[] memory arr = ShiftLib.getArray(input, 64);\n\n        (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n        require(arr[feat] == 0, 'PP:0');\n\n        arr[feat] = pos;\n\n        res = ShiftLib.setArray(input, 64, arr);\n    }\n\n    function pullFromExtra(uint256 input, uint16 itemId) internal pure returns (uint256 res) {\n        uint8[] memory arr = ShiftLib.getArray(input, 64);\n\n        (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n        require(arr[feat] == pos, 'PP:1');\n\n        arr[feat] = 0;\n\n        res = ShiftLib.setArray(input, 64, arr);\n    }\n\n    function rotateDefaultandExtra(uint256 input, uint8 feature) internal pure returns (uint256 res) {\n        uint8[] memory def = ShiftLib.getArray(input, 0);\n        uint8[] memory ext = ShiftLib.getArray(input, 64);\n\n        uint8 tmp = ext[feature];\n        ext[feature] = def[feature];\n        def[feature] = tmp;\n\n        res = ShiftLib.setArray(input, 0, def);\n        res = ShiftLib.setArray(res, 64, ext);\n    }\n\n    function setNewAnchorOverrides(\n        uint256 input,\n        uint8[] memory xs,\n        uint8[] memory ys\n    ) internal pure returns (uint256 res) {\n        res = ShiftLib.setArray(input, 128, xs);\n        res = ShiftLib.setArray(res, 192, ys);\n    }\n\n    function clearAnchorOverridesForFeature(uint256 input, uint8 feature) internal pure returns (uint256 res) {\n        uint8[] memory x = ShiftLib.getArray(input, 128);\n        uint8[] memory y = ShiftLib.getArray(input, 192);\n\n        y[feature] = 0;\n        x[feature] = 0;\n\n        res = ShiftLib.setArray(input, 128, x);\n        res = ShiftLib.setArray(res, 192, y);\n    }\n\n    function parseItemId(uint16 itemId) internal pure returns (uint8 feat, uint8 pos) {\n        feat = uint8(itemId >> 8);\n        pos = uint8(itemId & 0xff);\n    }\n}\n"
    },
    "src/file/FileView.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {File} from './FileStorage.sol';\nimport {FilePure} from './FilePure.sol';\n\n// TESTED\nlibrary FileView {\n    function hasResolver(uint160 tokenId) internal view returns (bool) {\n        return File.spointer().resolvers[tokenId] != address(0);\n    }\n\n    function resolverOf(uint160 tokenId) internal view returns (address) {\n        return File.spointer().resolvers[tokenId];\n    }\n\n    function totalLengths() internal view returns (uint8[] memory res) {\n        res = FilePure.getLengths(File.spointer().lengthData);\n    }\n}\n"
    },
    "src/file/FilePure.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nlibrary FilePure {\n    using SafeCastLib for uint256;\n\n    function decoder(bytes memory data, uint256 feature) internal pure returns (uint256[][] memory res) {\n        res = abi.decode(abi.decode((data), (bytes[]))[feature], (uint256[][]));\n    }\n\n    function getLengths(uint256 input) internal pure returns (uint8[] memory res) {\n        res = ShiftLib.getArray(input, 0);\n    }\n\n    function setLengths(uint256 input, uint8[] memory upd) internal pure returns (uint256 res) {\n        res = ShiftLib.setArray(input, 0, upd);\n    }\n\n    function getAddress(uint256 input) internal pure returns (address res) {\n        res = address(uint160(input >> 96));\n    }\n\n    function addrsetAddress(uint256 input, address update) internal pure returns (uint256 res) {\n        res = input & type(uint96).max;\n        res |= (uint256(uint160(update)) << 96);\n    }\n}\n"
    },
    "src/trust/TrustExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ITrustExternal} from '../interfaces/INuggFT.sol';\n\nimport {StakeCore} from '../stake/StakeCore.sol';\nimport {TokenCore} from '../token/TokenCore.sol';\n\nimport {Trust} from './TrustStorage.sol';\n\nimport {FileCore} from '../file/FileCore.sol';\n\nabstract contract TrustExternal is ITrustExternal {\n    address private _trusted;\n\n    Trust.Storage private _trust;\n\n    modifier requiresTrust() {\n        require(_trusted == msg.sender, 'UNTRUSTED');\n        _trust._isTrusted = true;\n        _;\n        _trust._isTrusted = false;\n    }\n\n    constructor() {\n        _trusted = msg.sender;\n\n        emit TrustUpdated(msg.sender);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n    function trustedMint(uint160 tokenId, address to) external payable override requiresTrust {\n        TokenCore.trustedMint(_trust, to, tokenId);\n    }\n\n    function extractProtocolEth() external override requiresTrust {\n        StakeCore.trustedExtractProtocolEth(_trust);\n    }\n\n    function setMigrator(address addr) external requiresTrust {\n        StakeCore.trustedSetMigrator(_trust, addr);\n    }\n\n    function storeFiles(uint256[][] calldata data, uint8 feature) external override requiresTrust {\n        FileCore.trustedStoreFiles(_trust, feature, data);\n    }\n\n    function setIsTrusted(address user) external virtual override requiresTrust {\n        _trusted = user;\n\n        emit TrustUpdated(user);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 VIEW\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function trusted() public view override returns (address) {\n        return _trusted;\n    }\n}\n"
    },
    "src/interfaces/INuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721, IERC721Metadata, IERC165} from './IERC721.sol';\n\nimport {IdotnuggV1Implementer} from '../interfaces/IdotnuggV1.sol';\n\ninterface ITrustExternal {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event TrustUpdated(address indexed user);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n    function trustedMint(uint160 tokenId, address to) external payable;\n\n    function extractProtocolEth() external;\n\n    function storeFiles(uint256[][] calldata data, uint8 feature) external;\n\n    function setIsTrusted(address user) external;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function trusted() external view returns (address);\n}\n\ninterface IStakeExternal {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event StakeEth(uint96 stake, uint96 protocol);\n    event UnStakeEth(uint96 stake, address to);\n    event ProtocolEthExtracted(uint96 eth);\n    event MigratorV1Updated(address migrator);\n    event MigrateV1Sent(address v2, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function migrateStake(uint160 tokenId) external;\n\n    function withdrawStake(uint160 tokenId) external;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function minSharePrice() external view returns (uint96 res);\n\n    function totalProtocolEth() external view returns (uint96);\n\n    function totalSupply() external view returns (uint256);\n\n    function totalStakedShares() external view returns (uint64);\n\n    function totalStakedEth() external view returns (uint96);\n\n    function activeEthPerShare() external view returns (uint96);\n}\n\ninterface IProofExternal {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event SetProof(uint160 tokenId, uint256 proof, uint8[] items);\n    event PopItem(uint160 tokenId, uint256 proof, uint16 itemId);\n    event PushItem(uint160 tokenId, uint256 proof, uint16 itemId);\n    event RotateItem(uint160 tokenId, uint256 proof, uint8 feature);\n    event SetAnchorOverrides(uint160 tokenId, uint256 proof, uint8[] xs, uint8[] ys);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function rotateFeature(uint160 tokenId, uint8 feature) external;\n\n    function setOverrides(\n        uint160 tokenId,\n        uint8[] memory xs,\n        uint8[] memory ys\n    ) external;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function proofOf(uint160 tokenId) external view returns (uint256);\n\n    function parsedProofOf(uint160 tokenId)\n        external\n        view\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory extraIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        );\n}\n\ninterface IFileExternal is IERC721Metadata, IdotnuggV1Implementer {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function totalLengths() external view returns (uint8[] memory res);\n}\n\ninterface ILoanExternal {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event TakeLoan(uint160 tokenId, uint96 principal);\n    event Payoff(uint160 tokenId, address account, uint96 payoffAmount);\n    event Rebalance(uint160 tokenId, uint96 fee, uint96 earned);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function rebalance(uint160 tokenId) external payable;\n\n    function loan(uint160 tokenId) external;\n\n    function payoff(uint160 tokenId) external payable;\n}\n\ninterface ITokenExternal is IERC721 {\n    function mint(uint160 tokenId) external payable;\n\n    event TrustedMint(address indexed to, uint160 tokenId);\n    event UntrustedMint(address indexed by, uint160 tokenId);\n}\n\ninterface ISwapExternal {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event DelegateMint(uint256 epoch, address account, uint96 eth);\n    event DelegateCommit(uint160 tokenId, address account, uint96 eth);\n    event DelegateOffer(uint160 tokenId, address account, uint96 eth);\n    event SwapClaim(uint160 tokenId, address account, uint32 epoch);\n    event SwapStart(uint160 tokenId, address account, uint96 eth);\n\n    event DelegateCommitItem(uint160 sellingTokenId, uint16 itemId, uint160 buyingTokenId, uint96 eth);\n    event DelegateOfferItem(uint160 sellingTokenId, uint16 itemId, uint160 buyingTokenId, uint96 eth);\n    event SwapClaimItem(uint160 sellingTokenId, uint16 itemId, uint160 buyingTokenId, uint32 epoch);\n    event SwapItemStart(uint160 sellingTokenId, uint16 itemId, uint96 eth);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function delegate(uint160 tokenId) external payable;\n\n    function delegateItem(\n        uint160 sellerTokenId,\n        uint16 itemid,\n        uint160 buyerTokenId\n    ) external payable;\n\n    function claim(uint160 tokenId) external;\n\n    function claimItem(\n        uint160 sellerTokenId,\n        uint16 itemid,\n        uint160 buyerTokenId\n    ) external;\n\n    function swap(uint160 tokenId, uint96 floor) external;\n\n    function swapItem(\n        uint160 tokenId,\n        uint16 itemid,\n        uint96 floor\n    ) external;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // function getOfferByAccount(uint160 tokenId, address account) external view returns (uint96 eth);\n\n    // function getActiveSwap(uint160 tokenId)\n    //     external\n    //     view\n    //     returns (\n    //         address leader,\n    //         uint96 eth,\n    //         uint32 _epoch,\n    //         bool isOwner\n    //     );\n}\n\ninterface IEpochExternal {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function epoch() external view returns (uint32 res);\n}\n\ninterface INuggFT is\n    ISwapExternal,\n    ITokenExternal,\n    IStakeExternal,\n    ILoanExternal,\n    IProofExternal,\n    IFileExternal,\n    IEpochExternal,\n    ITrustExternal\n{\n    event Genesis();\n}\n"
    },
    "src/file/FileCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IdotnuggV1Data} from '../interfaces/IdotnuggV1.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SSTORE2} from '../libraries/SSTORE2.sol';\n\nimport {File} from './FileStorage.sol';\nimport {FilePure} from './FilePure.sol';\nimport {FileView} from './FileView.sol';\nimport {ProofPure} from '../proof/ProofPure.sol';\nimport {ProofView} from '../proof/ProofView.sol';\n\nimport {TokenView} from '../token/TokenView.sol';\n\nimport {Trust} from '../trust/TrustStorage.sol';\n\nlibrary FileCore {\n    using FilePure for uint256;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                PROCESS FILES\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function prepareForProcess(uint160 tokenId) internal view returns (uint256[][] memory files, IdotnuggV1Data.Data memory data) {\n        (uint256 proof, uint8[] memory ids, uint8[] memory extras, uint8[] memory xovers, uint8[] memory yovers) = ProofView\n            .parsedProofOfIncludingPending(tokenId);\n\n        files = FileCore.getBatchFiles(ids);\n\n        data = IdotnuggV1Data.Data({\n            version: 1,\n            renderedAt: block.timestamp,\n            name: 'NuggFT V1',\n            desc: 'Nugg Fungible Token V1 by nugg.xyz',\n            owner: TokenView.exists(tokenId) ? TokenView.ownerOf(tokenId) : address(0),\n            tokenId: tokenId,\n            proof: proof,\n            ids: ids,\n            extras: extras,\n            xovers: xovers,\n            yovers: yovers\n        });\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                RESOLVER SET\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function setResolver(uint160 tokenId, address to) internal {\n        require(TokenView.isApprovedOrOwner(msg.sender, tokenId), 'T:0');\n\n        File.spointer().resolvers[tokenId] = to;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function trustedStoreFiles(\n        Trust.Storage storage trust,\n        uint8 feature,\n        uint256[][] calldata data\n    ) internal {\n        require(trust._isTrusted, 'T:0');\n\n        uint8 len = data.length.safe8();\n\n        require(len > 0, 'VC:0');\n\n        uint168 working = uint168(len) << 160;\n\n        address ptr = SSTORE2.write(abi.encode(data));\n\n        File.spointer().ptrs[feature].push(uint168(uint160(ptr)) | working);\n\n        uint256 cache = File.spointer().lengthData;\n\n        uint8[] memory lengths = FilePure.getLengths(cache);\n\n        lengths[feature] += len;\n\n        File.spointer().lengthData = FilePure.setLengths(cache, lengths);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 GET FILES\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function getBatchFiles(uint8[] memory ids) internal view returns (uint256[][] memory data) {\n        data = new uint256[][](ids.length);\n\n        for (uint8 i = 0; i < ids.length; i++) {\n            if (ids[i] == 0) data[i] = new uint256[](0);\n            else data[i] = get(i, ids[i]);\n        }\n    }\n\n    function get(uint8 feature, uint8 pos) internal view returns (uint256[] memory data) {\n        require(pos != 0, 'VC:2');\n\n        pos--;\n\n        uint8 totalLength = FilePure.getLengths(File.spointer().lengthData)[feature];\n\n        require(pos < totalLength, 'VC:1');\n\n        uint168[] memory ptrs = File.spointer().ptrs[feature];\n\n        address store;\n        uint8 storePos;\n\n        uint8 workingPos;\n\n        for (uint256 i = 0; i < ptrs.length; i++) {\n            uint8 here = uint8(ptrs[i] >> 160);\n            if (workingPos + here > pos) {\n                store = address(uint160(ptrs[i]));\n                storePos = pos - workingPos;\n                break;\n            } else {\n                workingPos += here;\n            }\n        }\n\n        require(store != address(0), 'VC:2');\n\n        data = abi.decode(SSTORE2.read(address(uint160(store))), (uint256[][]))[storePos];\n    }\n}\n"
    },
    "src/libraries/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Modified from 0xSequence (https://github.com/0xsequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1;\n\n    function write(bytes memory data) internal returns (address pointer) {\n        bytes memory runtimeCode = abi.encodePacked(hex'00', data);\n\n        bytes memory creationCode = abi.encodePacked(hex'63', uint32(runtimeCode.length), hex'80_60_0E_60_00_39_60_00_F3', runtimeCode);\n\n        assembly {\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), 'DEPLOYMENT_FAILED');\n    }\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, 'OUT_OF_BOUNDS');\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(add(size, add(start, 0x20)), 0x1f), not(0x1f))))\n            mstore(data, size)\n            extcodecopy(pointer, add(data, 0x20), start, size)\n        }\n    }\n}\n"
    },
    "src/file/FileExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IFileExternal} from '../interfaces/INuggFT.sol';\n\nimport {IdotnuggV1Processor} from '../interfaces/IdotnuggV1.sol';\nimport {IdotnuggV1Resolver} from '../interfaces/IdotnuggV1.sol';\nimport {IdotnuggV1Data} from '../interfaces/IdotnuggV1.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {FileCore} from './FileCore.sol';\nimport {FileView} from './FileView.sol';\nimport {File} from './FileStorage.sol';\n\nabstract contract FileExternal is IFileExternal {\n    using SafeCastLib for uint256;\n\n    address public dotnuggV1Processor;\n\n    uint8 public defaultWidth = 45;\n\n    uint8 public defaultZoom = 10;\n\n    constructor(address _dotnuggV1Processor) {\n        require(_dotnuggV1Processor != address(0));\n        dotnuggV1Processor = _dotnuggV1Processor;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            RESOLVER MANAGEMENT\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function setResolver(uint256 tokenId, address to) public virtual override {\n        FileCore.setResolver(tokenId.safe160(), to);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            MAIN FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory res) {\n        uint160 safeTokenId = tokenId.safe160();\n\n        address resolver = FileView.hasResolver(safeTokenId) ? FileView.resolverOf(safeTokenId) : dotnuggV1Processor;\n\n        res = IdotnuggV1Processor(dotnuggV1Processor).dotnuggToString(address(this), tokenId, resolver, defaultWidth, defaultZoom);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                HELPERS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function prepareFiles(uint256 tokenId) public view override returns (uint256[][] memory input, IdotnuggV1Data.Data memory data) {\n        (input, data) = FileCore.prepareForProcess(tokenId.safe160());\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                VIEW\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function resolverOf(uint256 tokenId) public view virtual override returns (address) {\n        return FileView.resolverOf(tokenId.safe160());\n    }\n\n    function totalLengths() public view override returns (uint8[] memory res) {\n        res = FileView.totalLengths();\n    }\n}\n"
    },
    "src/NuggFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721Metadata} from './interfaces/IERC721.sol';\n\nimport {INuggFT as a} from './interfaces/INuggFT.sol';\n\nimport {TokenExternal as ERC721} from './token/TokenExternal.sol';\nimport {SwapExternal as Swapable} from './swap/SwapExternal.sol';\nimport {ProofExternal as Provable} from './proof/ProofExternal.sol';\nimport {FileExternal as DotNugg} from './file/FileExternal.sol';\nimport {StakeExternal as Staked} from './stake/StakeExternal.sol';\nimport {LoanExternal as Loanable} from './loan/LoanExternal.sol';\nimport {EpochExternal as Epoched} from './epoch/EpochExternal.sol';\nimport {TrustExternal as Migratable} from './trust/TrustExternal.sol';\n\ncontract NuggFT is a, Swapable, Provable, Loanable, Migratable, Staked, Epoched, DotNugg, ERC721 {\n    constructor(address _defaultResolver) DotNugg(_defaultResolver) {\n        emit Genesis();\n    }\n\n    function tokenURI(uint256 tokenId) public view override(DotNugg, IERC721Metadata) returns (string memory) {\n        return DotNugg.tokenURI(tokenId);\n    }\n\n    function name() public pure override returns (string memory) {\n        return 'Nugg Fungible Token V1';\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return 'NUGGFT';\n    }\n}\n"
    },
    "src/token/TokenExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {IERC721Receiver, IERC721, IERC165, IERC721Metadata} from '../interfaces/IERC721.sol';\nimport {ITokenExternal} from '../interfaces/INuggFT.sol';\n\nimport {Token} from './TokenStorage.sol';\n\nimport {TokenView} from './TokenView.sol';\n\nimport {TokenCore} from './TokenCore.sol';\n\n//OK\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard\n */\nabstract contract TokenExternal is ITokenExternal {\n    using SafeCastLib for uint256;\n\n    function mint(uint160 tokenId) public payable override {\n        TokenCore.untrustedMint(tokenId);\n    }\n\n    function approve(address to, uint256 tokenId) public override {\n        TokenCore.checkedApprove(to, tokenId.safe160());\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override {\n        TokenCore.checkedSetApprovalForAll(operator, approved);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        return TokenView.balanceOf(owner);\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return TokenView.ownerOf(tokenId.safe160());\n    }\n\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        return TokenView.getApproved(tokenId.safe160());\n    }\n\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return TokenView.isApprovedForAll(owner, operator);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                DISABLED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public pure override {\n        revert('wut');\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256\n    ) public pure override {\n        revert('wut');\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public pure override {\n        revert('wut');\n    }\n}\n"
    },
    "src/swap/SwapExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ISwapExternal} from '../interfaces/INuggFT.sol';\n\nimport {EpochCore} from '../epoch/EpochCore.sol';\n\nimport {Swap} from './SwapStorage.sol';\nimport {SwapCore} from './SwapCore.sol';\nimport {SwapView} from './SwapView.sol';\n\n// OK\nabstract contract SwapExternal is ISwapExternal {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function delegate(uint160 tokenId) external payable override {\n        SwapCore.delegate(tokenId);\n    }\n\n    function delegateItem(\n        uint160 sellingTokenId,\n        uint16 itemid,\n        uint160 buyingTokenId\n    ) external payable override {\n        SwapCore.delegateItem(sellingTokenId, itemid, buyingTokenId);\n    }\n\n    function claim(uint160 tokenId) external override {\n        SwapCore.claim(tokenId);\n    }\n\n    function claimItem(\n        uint160 sellingTokenId,\n        uint16 itemid,\n        uint160 buyingTokenId\n    ) external override {\n        SwapCore.claimItem(sellingTokenId, itemid, buyingTokenId);\n    }\n\n    function swap(uint160 tokenId, uint96 floor) external override {\n        SwapCore.swap(tokenId, floor);\n    }\n\n    function swapItem(\n        uint160 sellingTokenId,\n        uint16 itemid,\n        uint96 floor\n    ) external override {\n        SwapCore.swapItem(itemid, floor, sellingTokenId);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                VIEW\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // function getActiveSwap(uint160 tokenId)\n    //     external\n    //     view\n    //     override\n    //     returns (\n    //         address leader,\n    //         uint96 amount,\n    //         uint32 _epoch,\n    //         bool isOwner\n    //     )\n    // {\n    //     return SwapView.getActiveSwap(tokenId);\n    // }\n\n    // function getOfferByAccount(uint160 tokenId, address account) external view override returns (uint96 amount) {\n    //     return SwapView.getOfferByAccount(tokenId, account);\n    // }\n}\n"
    },
    "src/proof/ProofExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IProofExternal} from '../interfaces/INuggFT.sol';\n\nimport {Proof} from './ProofStorage.sol';\n\nimport {EpochCore} from '../epoch/EpochCore.sol';\n\nimport {ProofCore} from './ProofCore.sol';\nimport {ProofView} from './ProofView.sol';\n\n// OK\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ProofExternal is IProofExternal {\n    uint256 immutable GEN = 0x69696969696969;\n\n    function rotateFeature(uint160 tokenId, uint8 feature) external override {\n        ProofCore.rotateFeature(tokenId, feature);\n    }\n\n    function setOverrides(\n        uint160 tokenId,\n        uint8[] memory xs,\n        uint8[] memory ys\n    ) external override {\n        ProofCore.setAnchorOverrides(tokenId, xs, ys);\n    }\n\n    function proofOf(uint160 tokenId) public view virtual override returns (uint256) {\n        return ProofView.checkedProofOfIncludingPending(tokenId);\n    }\n\n    function parsedProofOf(uint160 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory extraIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        )\n    {\n        return ProofView.parsedProofOfIncludingPending(tokenId);\n    }\n}\n"
    },
    "src/stake/StakeExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {IStakeExternal} from '../interfaces/INuggFT.sol';\n\nimport {StakeView} from './StakeView.sol';\nimport {StakeCore} from './StakeCore.sol';\n\nabstract contract StakeExternal is IStakeExternal {\n    using SafeCastLib for uint256;\n\n    function migrateStake(uint160 tokenId) external override {\n        StakeCore.migrateStakedShare(tokenId);\n    }\n\n    function withdrawStake(uint160 tokenId) external override {\n        StakeCore.burnStakedShare(tokenId);\n    }\n\n    function minSharePrice() external view override returns (uint96 res) {\n        res = StakeView.getMinSharePrice();\n    }\n\n    function totalStakedShares() external view override returns (uint64 res) {\n        res = StakeView.getActiveStakedShares();\n    }\n\n    function totalStakedEth() external view override returns (uint96 res) {\n        res = StakeView.getActiveStakedEth();\n    }\n\n    function activeEthPerShare() external view override returns (uint96 res) {\n        res = StakeView.getActiveEthPerShare();\n    }\n\n    function totalProtocolEth() external view override returns (uint96 res) {\n        res = StakeView.getActiveProtocolEth();\n    }\n\n    function totalSupply() external view override returns (uint256 res) {\n        res = StakeView.getActiveStakedShares();\n    }\n}\n"
    },
    "src/loan/LoanExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ILoanExternal} from '../interfaces/INuggFT.sol';\n\nimport {LoanCore} from './LoanCore.sol';\n\nabstract contract LoanExternal is ILoanExternal {\n    function loan(uint160 tokenId) external override {\n        LoanCore.loan(tokenId);\n    }\n\n    function payoff(uint160 tokenId) external payable override {\n        LoanCore.payoff(tokenId);\n    }\n\n    function rebalance(uint160 tokenId) external payable override {\n        LoanCore.rebalance(tokenId);\n    }\n}\n"
    },
    "src/epoch/EpochExternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IEpochExternal} from '../interfaces/INuggFT.sol';\n\nimport {EpochCore} from '../epoch/EpochCore.sol';\n\nabstract contract EpochExternal is IEpochExternal {\n    constructor() {\n        EpochCore.setGenesis();\n    }\n\n    //\n    function epoch() external view override returns (uint32) {\n        return EpochCore.activeEpoch();\n    }\n}\n"
    },
    "src/swap/SwapCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {Swap} from './SwapStorage.sol';\nimport {SwapPure} from '../swap/SwapPure.sol';\n\nimport {StakeView} from '../stake/StakeView.sol';\nimport {StakeCore} from '../stake/StakeCore.sol';\n\nimport {ProofCore} from '../proof/ProofCore.sol';\n\nimport {TokenCore} from '../token/TokenCore.sol';\nimport {TokenView} from '../token/TokenView.sol';\n\nlibrary SwapCore {\n    using SafeCastLib for uint256;\n    using SwapPure for uint256;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    event DelegateMint(uint256 epoch, address account, uint96 eth);\n    event DelegateCommit(uint160 tokenId, address account, uint96 eth);\n    event DelegateOffer(uint160 tokenId, address account, uint96 eth);\n    event SwapClaim(uint160 tokenId, address account, uint32 epoch);\n    event SwapStart(uint160 tokenId, address account, uint96 eth);\n\n    event DelegateCommitItem(uint160 sellingTokenId, uint16 itemId, uint160 buyingTokenId, uint96 eth);\n    event DelegateOfferItem(uint160 sellingTokenId, uint16 itemId, uint160 buyingTokenId, uint96 eth);\n    event SwapClaimItem(uint160 sellingTokenId, uint16 itemId, uint160 buyingTokenId, uint32 epoch);\n    event SwapItemStart(uint160 sellingTokenId, uint16 itemId, uint96 eth);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            TOKEN SWAP FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @notice Explain to an end user what this does\n    /// @dev E\n    /// @param tokenId a\n    /// @custom:test hardhat\n    ///\n    function delegate(uint160 tokenId) internal {\n        (Swap.Storage storage s, Swap.Memory memory m) = Swap.loadTokenSwap(tokenId, msg.sender);\n\n        // make sure user is not the owner of swap\n        // we do not know how much to give them when they call \"claim\" otherwise\n\n        if (m.activeEpoch == tokenId && m.swapData == 0) {\n            // we do not need this, could take tokenId out as an argument - but do not want to give users\n            // the ability to accidently place an offer for nugg A and end up minting nugg B.\n            mint(s, m);\n\n            emit DelegateMint(tokenId, msg.sender, msg.value.safe96());\n\n            return;\n        }\n\n        require(!m.offerData.isOwner(), 'SL:HSO:0');\n\n        require(m.swapData != 0, 'NS:0:0');\n\n        if (m.offerData == 0 && m.swapData.isOwner()) {\n            require(msg.value >= StakeView.getActiveEthPerShare(), 'SL:S:0');\n\n            commit(s, m);\n\n            emit DelegateCommit(tokenId, msg.sender, msg.value.safe96());\n        } else {\n            offer(s, m);\n\n            emit DelegateOffer(tokenId, msg.sender, msg.value.safe96());\n        }\n    }\n\n    function mint(Swap.Storage storage s, Swap.Memory memory m) internal {\n        require(m.swapData == 0 && m.offerData == 0, 'NS:M:D');\n\n        (uint256 dat, ) = SwapPure.buildSwapData(m.activeEpoch, uint160(msg.sender), msg.value.safe96(), false);\n\n        s.data = dat;\n\n        StakeCore.addStakedShareAndEth(msg.value.safe96());\n\n        ProofCore.setProof(m.activeEpoch);\n    }\n\n    function claim(uint160 tokenId) internal {\n        (, Swap.Memory memory m) = Swap.loadTokenSwap(tokenId, msg.sender);\n\n        Swap.deleteTokenOffer(tokenId, uint160(msg.sender));\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            Swap.deleteTokenSwap(tokenId);\n\n            // if this is a minting nugg\n            if (tokenId == m.swapData.epoch()) {\n                TokenCore.checkedMintTo(msg.sender, tokenId);\n            } else {\n                TokenCore.checkedTransferFromSelf(msg.sender, tokenId);\n            }\n        } else {\n            SafeTransferLib.safeTransferETH(msg.sender, m.offerData.eth());\n        }\n\n        emit SwapClaim(tokenId, msg.sender, m.swapData.epoch());\n    }\n\n    function unsafeClaimERC721To(uint160 tokenId, address to) internal {}\n\n    function swap(uint160 tokenId, uint96 floor) internal {\n        require(floor >= StakeView.getActiveEthPerShare(), 'SL:S:0');\n\n        TokenCore.approvedTransferToSelf(tokenId);\n\n        (Swap.Storage storage s, Swap.Memory memory m) = Swap.loadTokenSwap(tokenId, msg.sender);\n\n        // make sure swap does not exist - this logically should never happen\n        assert(m.swapData == 0);\n\n        (uint256 dat, ) = SwapPure.buildSwapData(0, uint160(msg.sender), msg.value.safe96(), true);\n\n        s.data = dat;\n\n        emit SwapStart(tokenId, msg.sender, floor);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            ITEM SWAP FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function delegateItem(\n        uint160 sellingTokenId,\n        uint16 itemId,\n        uint160 sendingTokenId\n    ) internal {\n        require(TokenView.ownerOf(sendingTokenId) == msg.sender, 'AUC:TT:3');\n\n        (Swap.Storage storage s, Swap.Memory memory m) = Swap.loadItemSwap(sellingTokenId, itemId, sendingTokenId);\n\n        // make sure user is not the owner of swap\n        // we do not know how much to give them when they call \"claim\" otherwise\n        require(!m.offerData.isOwner(), 'SL:HSO:0');\n\n        if (m.offerData == 0 && m.swapData.isOwner()) {\n            commit(s, m);\n\n            emit DelegateCommitItem(sellingTokenId, itemId, sendingTokenId, msg.value.safe96());\n        } else {\n            offer(s, m);\n\n            emit DelegateOfferItem(sellingTokenId, itemId, sendingTokenId, msg.value.safe96());\n        }\n    }\n\n    function claimItem(\n        uint160 sellingTokenId,\n        uint16 itemId,\n        uint160 buyingTokenId\n    ) internal {\n        require(TokenView.ownerOf(buyingTokenId) == msg.sender, 'AUC:TT:3');\n\n        (, Swap.Memory memory m) = Swap.loadItemSwap(sellingTokenId, itemId, buyingTokenId);\n\n        Swap.deleteItemOffer(sellingTokenId, itemId, buyingTokenId);\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            Swap.deleteItemSwap(sellingTokenId, itemId);\n\n            ProofCore.addItem(buyingTokenId, itemId);\n        } else {\n            SafeTransferLib.safeTransferETH(msg.sender, m.offerData.eth());\n        }\n\n        emit SwapClaimItem(sellingTokenId, itemId, buyingTokenId, m.swapData.epoch());\n    }\n\n    function swapItem(\n        uint16 itemId,\n        uint96 floor,\n        uint160 sellingTokenId\n    ) internal {\n        require(TokenView.ownerOf(sellingTokenId) == msg.sender, 'AUC:TT:3');\n\n        // will revert if they do not have the item\n        ProofCore.removeItem(sellingTokenId, itemId);\n\n        (Swap.Storage storage s, Swap.Memory memory m) = Swap.loadItemSwap(sellingTokenId, itemId, sellingTokenId);\n\n        // cannot sell two of the same item at same time\n        require(m.swapData == 0, 'SC:SI:0');\n\n        (uint256 dat, ) = SwapPure.buildSwapData(0, sellingTokenId, floor, true);\n\n        s.data = dat;\n\n        emit SwapItemStart(sellingTokenId, itemId, dat.eth());\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            COMMON FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function checkClaimerIsWinnerOrLoser(Swap.Memory memory m) internal pure returns (bool winner) {\n        require(m.offerData != 0, 'SL:CC:1');\n\n        bool isOver = m.activeEpoch > m.swapData.epoch();\n        bool isLeader = m.offerData.account() == m.swapData.account();\n        bool isOwner = m.swapData.isOwner();\n\n        return isOwner || (isLeader && isOver);\n    }\n\n    function commit(Swap.Storage storage s, Swap.Memory memory m) internal {\n        assert(m.offerData == 0 && m.swapData != 0);\n\n        assert(m.swapData.isOwner());\n\n        (uint256 newSwapData, uint256 increment, uint256 dust) = SwapPure.updateSwapDataWithEpoch(\n            m.swapData,\n            m.activeEpoch + 1,\n            m.sender,\n            msg.value.safe96()\n        );\n\n        s.data = newSwapData;\n\n        s.offers[m.swapData.account()] = m.swapData;\n\n        StakeCore.addStakedEth((increment + dust).safe96());\n    }\n\n    function offer(Swap.Storage storage s, Swap.Memory memory m) internal {\n        // make sure swap is still active\n        require(m.activeEpoch <= m.swapData.epoch(), 'SL:OBP:3');\n\n        if (m.swapData.account() != m.sender) s.offers[m.swapData.account()] = m.swapData;\n\n        (uint256 newSwapData, uint256 increment, uint256 dust) = SwapPure.updateSwapData(\n            m.swapData,\n            m.sender,\n            m.offerData.eth() + msg.value.safe96()\n        );\n\n        s.data = newSwapData;\n\n        StakeCore.addStakedEth((increment + dust).safe96());\n    }\n}\n"
    },
    "src/swap/SwapView.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Global} from '../global/GlobalStorage.sol';\n\nimport {Swap} from './SwapStorage.sol';\nimport {SwapPure} from './SwapPure.sol';\n\n// IDC\nlibrary SwapView {\n    using SwapPure for uint256;\n\n    function getActiveSwap(uint160 tokenId)\n        internal\n        view\n        returns (\n            address leader,\n            uint96 amount,\n            uint32 _epoch,\n            bool isOwner\n        )\n    {\n        // (, Swap.Memory memory m) = Swap.loadTokenSwap(tokenId, address(0));\n        // require(m.swapData != 0, 'NS:GS:0');\n        // leader = address(m.swapData.account());\n        // amount = m.swapData.eth();\n        // _epoch = m.swapData.epoch();\n        // isOwner = m.swapData.isOwner();\n    }\n\n    function getOfferByAccount(uint160 tokenId, address account) internal view returns (uint96 amount) {\n        // (, Swap.Memory memory m) = Swap.loadTokenSwap(tokenId, account);\n        // require(m.offerData != 0, 'NS:GS:0');\n        // amount = m.offerData.eth();\n    }\n}\n"
    },
    "src/loan/LoanCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {Global} from '../global/GlobalStorage.sol';\nimport {Loan} from '../loan/LoanStorage.sol';\n\nimport {TokenCore} from '../token/TokenCore.sol';\nimport {StakeCore} from '../stake/StakeCore.sol';\n\nimport {SwapPure} from '../swap/SwapPure.sol';\n\nimport {TokenView} from '../token/TokenView.sol';\nimport {StakeView} from '../stake/StakeView.sol';\nimport {EpochCore} from '../epoch/EpochCore.sol';\n\nlibrary LoanCore {\n    using SafeCastLib for uint256;\n    using SwapPure for uint256;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    uint32 constant LIQUIDATION_PERIOD = 1000;\n    uint96 constant REBALANCE_FEE_BPS = 100;\n    uint32 constant REBALANCE_PERIOD_INCREASE = 1000;\n\n    event TakeLoan(uint160 tokenId, uint96 principal);\n    event Payoff(uint160 tokenId, address account, uint96 payoffAmount);\n    event Rebalance(uint160 tokenId, uint96 fee, uint96 earned);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            LOAN MANAGEMENT\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // @hh system tests\n    function loan(uint160 tokenId) internal {\n        // we know the loan data is blank because it is owned by the user\n        require(TokenView.ownerOf(tokenId) == msg.sender, 'LOAN:L:0');\n\n        TokenCore.approvedTransferToSelf(tokenId);\n\n        uint96 principal = StakeView.getActiveEthPerShare();\n\n        uint32 epoch = EpochCore.activeEpoch();\n\n        (uint256 loanData, ) = SwapPure.buildSwapData(epoch, uint160(msg.sender), principal, false);\n\n        Loan.sstore(tokenId, loanData); // starting swap data\n\n        SafeTransferLib.safeTransferETH(msg.sender, principal);\n\n        emit TakeLoan(tokenId, principal);\n    }\n\n    // @hh system tests\n    function rebalance(uint160 tokenId) internal {\n        require(address(this) == TokenView.ownerOf(tokenId), 'LOAN:P:0');\n\n        uint256 cache = Loan.sload(tokenId);\n\n        require(cache != 0 && cache.account() == uint160(msg.sender), 'LOAN:P:2');\n\n        uint96 curr = cache.eth(); // in their pocket atm\n\n        uint96 fee = ((curr * REBALANCE_FEE_BPS) / 10000); // fee to be paid 69\n\n        require(fee <= msg.value, 'LOAN:RE:0'); // 70\n\n        uint96 preEps = StakeView.getActiveEthPerShare();\n\n        StakeCore.addStakedEth(fee);\n\n        uint96 newPrincipal = StakeView.getActiveEthPerShare();\n\n        (uint256 loanData, uint96 dust) = SwapPure.buildSwapData(\n            cache.epoch() + REBALANCE_PERIOD_INCREASE,\n            uint160(msg.sender),\n            newPrincipal,\n            false\n        );\n\n        Loan.sstore(tokenId, loanData); // starting swap data\n\n        uint96 overpayment = msg.value.safe96() - fee; // 1 wei\n\n        uint96 update = curr + fee;\n\n        // value earned while lone was taken out\n        uint96 earnings = update >= preEps ? 0 : preEps - update;\n\n        uint96 owed = earnings + overpayment + dust;\n\n        SafeTransferLib.safeTransferETH(msg.sender, owed);\n\n        emit Rebalance(tokenId, fee, earnings);\n    }\n\n    // @hh system tests\n    function payoff(uint160 tokenId) internal {\n        require(address(this) == TokenView.ownerOf(tokenId), 'LOAN:P:0');\n\n        uint256 cache = Loan.sload(tokenId);\n\n        Loan.spurge(tokenId); // starting swap data\n\n        uint32 epoch = EpochCore.activeEpoch();\n\n        if (cache.epoch() + LIQUIDATION_PERIOD >= epoch) {\n            require(cache.account() == uint160(msg.sender), 'LOAN:P:1');\n        }\n\n        require(cache != 0, 'LOAN:P:2');\n\n        uint96 curr = cache.eth(); // in their pocket atm\n\n        uint96 fee = (curr * REBALANCE_FEE_BPS) / 10000; // fee to be paid\n\n        uint96 payoffAmount = fee + curr;\n\n        require(payoffAmount <= msg.value, 'LOAN:RE:0');\n\n        uint96 value = msg.value.safe96();\n\n        uint96 overpayment = value - fee;\n\n        uint96 update = curr + fee;\n\n        uint96 activeEps = StakeView.getActiveEthPerShare();\n\n        // value earned while lone was taken out\n        uint96 earnings = update >= activeEps ? 0 : activeEps - update;\n\n        uint96 owed = earnings + overpayment;\n\n        StakeCore.addStakedEth(fee);\n\n        SafeTransferLib.safeTransferETH(msg.sender, owed);\n\n        TokenCore.checkedTransferFromSelf(msg.sender, tokenId);\n\n        emit Rebalance(tokenId, fee, earnings);\n\n        emit Payoff(tokenId, msg.sender, payoffAmount);\n    }\n}\n"
    },
    "src/_test/stake/StakeView/getActiveStakedShares.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {StakeView} from '../../../stake/StakeView.sol';\n\ncontract StakeViewTest__getActiveStakedShares is t {\n    function test__StakeView__getActiveStakedShares__a() public {\n        assertEq(StakeView.getActiveStakedShares(), 0);\n    }\n}\n"
    },
    "src/_test/utils/DSTestPlus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTest} from '../../../lib/ds-test/src/test.sol';\n\nimport {Hevm, ForgeVm} from './Vm.sol';\n\n\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    //    Vm vm = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    bytes32 checkpointLabel;\n    uint256 private checkpointGasLeft;\n\n    function startMeasuringGas(bytes32 label) internal virtual {\n        checkpointLabel = label;\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        bytes32 label = checkpointLabel;\n\n        emit log_named_uint(string(abi.encodePacked(label, ' Gas')), checkpointGasLeft - checkpointGasLeft2 - 22134);\n    }\n\n    function fail(bytes32 err) internal virtual {\n        emit log_named_string('Error', string(abi.encodePacked(err)));\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertUint128Eq(uint128 a, uint128 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint64Eq(uint64 a, uint64 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint96Eq(uint96 a, uint96 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint32Eq(uint32 a, uint32 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log('Error: a == b not satisfied [bytes]');\n            emit log_named_bytes('  Expected', b);\n            emit log_named_bytes('    Actual', a);\n            fail();\n        }\n    }\n}\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, 'NO_TARGET_CONTRACTS');\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "src/_test/utils/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface Hevm {\n    function warp(uint256) external;\n\n    function roll(uint256) external;\n\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    function load(address, bytes32) external returns (bytes32);\n\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    function addr(uint256) external returns (address);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n}\n\ninterface ForgeVm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n\n    // Loads a storage slot from an address (who, slot)\n    function load(address, bytes32) external returns (bytes32);\n\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    // Signs data, (privateKey, digest) => (r, v, s)\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    // Calls another contract with a specified `msg.sender`, (newSender, contract, input) => (success, returnData)\n    function prank(\n        address,\n        address,\n        bytes calldata\n    ) external payable returns (bool, bytes memory);\n\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n}\n"
    },
    "src/_test/swap/SwapCore/delegate.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {SwapCore} from '../../../swap/SwapCore.sol';\n\nimport {Swap} from '../../../swap/SwapStorage.sol';\n\ncontract SwapCoreTest__delegate is t {\n    function setUp() public {}\n\n    function test__SwapCore__delegate__a() public {\n        fvm.roll(1);\n        fvm.roll(2);\n\n        SwapCore.delegate(1);\n\n        (, Swap.Memory memory m) = Swap.loadTokenSwap(4, msg.sender);\n\n        assertTrue(m.swapData != 0);\n    }\n}\n"
    },
    "src/_test/libraries/ShiftLib/ShiftLib.mask.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../../utils/DSTestPlus.sol';\n\nimport '../../../libraries/ShiftLib.sol';\n\ncontract ShiftLib_mask is DSTestPlus {\n    function setUp() public {}\n\n    // function prove_z(uint8 input) public {\n    //     // ShiftLib.mask(244);\n\n    //     assertTrue(ShiftLib.mask(input) == type(uint256).max >> (256 - input));\n    // }\n\n    // function test_z() public {\n    //     uint256 a = type(uint256).max;\n    //     assembly {\n    //         a := shr(sub(256, 128), a)\n    //     }\n    // }\n\n    // function test_a() public {\n    //     uint256 a = ShiftLib.mask(128);\n    // }\n\n    // function test_a2() public {\n    //     assembly {\n    //         let res := sub(shl(128, 1), 1)\n    //     }\n    // }\n\n    // function prove_a(uint8 input) public {\n    //     // ShiftLib.mask(244);\n\n    //     assertTrue(ShiftLib.mask(input) == 2**input - 1);\n    // }\n\n    // function test_b() public {\n    //     // ShiftLib.mask2(244);\n\n    //     assembly {\n    //         if not(iszero(shr(8, 0x04))) {\n\n    //         }\n\n    //         let a := sub(shl(355, 1), 1)\n    //     }\n    // }\n\n    // function test_const0() public {\n    //     uint256 a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    //     assembly {\n    //         a := not(shl(a, 128))\n    //     }\n    //     // assertEq(a, type(uint256).max);\n    // }\n\n    // function test_const1() public {\n    //     assembly {\n    //         let a := not(shl(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 128))\n    //     }\n    //     // assertEq(a, type(uint256).max);\n    // }\n\n    // function test_const2() public {\n    //     uint256 a = type(uint256).max;\n    //     assembly {\n    //         a := not(shl(a, 128))\n    //     }\n    //     // assertEq(a, type(uint256).max);\n    // }\n\n    // function test_const3() public {\n    //     // uint256 a = type(uint256).max;\n    //     uint256 a;\n    //     assembly {\n    //         a := shl(256, 1)\n    //         a := not(shl(a, 128))\n    //     }\n    //     // assertEq(a, type(uint256).max);\n    // }\n\n    // function test_const4() public {\n    //     // uint256 a = type(uint256).max;\n    //     // uint256 a;\n    //     // assembly {\n    //     //     a := shl(256, 1)\n    //     //     a := not(shl(a, 128))\n    //     // }\n    //     ~(type(uint256).max << 128);\n    //     // assertEq(a, type(uint256).max);\n    // }\n\n    // function test_b2(uint256 input) public {\n    //     // ShiftLib.mask2(244);\n    //     uint256 a;\n    //     assembly {\n    //         // if and(iszero(shr(8, 0x04)), 0x01) {\n\n    //         // }\n\n    //         a := sub(shl(input, 1), 1)\n    //     }\n\n    //     // emit log_named_uint('test', a);\n    //     if (input > 255) {\n    //         assertEq(a, type(uint256).max);\n    //     } else {\n    //         assertEq(a, 2**input - 1);\n    //     }\n    // }\n\n    // function prove_d(uint256 input) public {\n    //     bool a;\n    //     assembly {\n    //         a := iszero(shr(128, input)) // 0x42 < 256\n    //     }\n    //     assertTrue(a == input < 2**128);\n    //     // assertTrue(((input >> 128) == 0) == (input < 2**128));\n    // }\n\n    // function test_fullsubmask_withand() public {\n    //     unchecked {\n    //         8 & ShiftLib.fullsubmask(8, 8);\n    //     }\n    // }\n\n    // // function test_fullsubmaskand() public {\n    // //     ShiftLib.fullsubmaskand(8, 8, 8);\n    // // }\n\n    // // function test_c3() public {\n    // //     assembly {\n    // //         let a := iszero(shr(128, 0x42)) // 0x42 < 256\n    // //     }\n    // //     // bool t = input >> 128 == 0;\n    // // }\n\n    // // function test_c4() public {\n    // //     bool g = 0x42 < 256;\n    // //     // require(pos < 256, 'SHIFT:POS:0');\n\n    // //     // assertTrue(pos< )\n    // // }\n}\n"
    },
    "src/_test/libraries/ShiftLib/ShiftLib.getArray.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../../utils/DSTestPlus.sol';\n\nimport '../../../libraries/ShiftLib.sol';\n\ncontract ShiftLib_getArray is DSTestPlus {\n    function setUp() public {}\n\n    // function test_a() public {\n    //     uint256 input = 0x010101;\n\n    //     uint256[] memory got = ShiftLib.getArray(input, 8, 0, 3);\n\n    //     assertEq(got.length, 3);\n    //     assertEq(got[0], 1);\n    //     assertEq(got[1], 1);\n    //     assertEq(got[2], 1);\n    // }\n\n    // // function test_b() public {\n    // //     uint256 input = 0x010201;\n\n    // //     uint256[] memory got = ShiftLib.getArray(input, 8, 0, 3);\n\n    // //     assertEq(got.length, 3);\n    // //     assertEq(got[0], 1);\n    // //     assertEq(got[1], 2);\n    // //     assertEq(got[2], 1);\n    // // }\n\n    // function test_b() public {\n    //     uint256[] memory got = ShiftLib.getArray(0x01010102342120131223216312836818726, 8, 0, 32);\n\n    //     assertEq(got.length, 32);\n\n    //     for (uint256 i = 0; i < 32; i++) {\n    //         assertEq(got[i], (0x01010102342120131223216312836818726 >> (i * 8)) & 0xff);\n    //     }\n    // }\n\n    // function test_b(uint256 input) public {\n    //     uint256[] memory got = ShiftLib.getArray(input, 8, 0, 32);\n\n    //     assertEq(got.length, 32);\n\n    //     for (uint256 i = 0; i < 32; i++) {\n    //         assertEq(got[i], (input >> (i * 8)) & 0xff);\n    //     }\n    // }\n}\n"
    },
    "src/_test/libraries/SafeCastLib/safe192.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {SafeCastLib} from '../../../libraries/SafeCastLib.sol';\n\ncontract SafeCastLibTest__safe96 is t {\n    function test__SafeCastLib__safe96__g1() public {\n        assertEq(SafeCastLib.safe96(type(uint96).max), type(uint96).max);\n    }\n}\n"
    },
    "src/_test/stake/StakeView/getActiveStakedEth.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {StakeView} from '../../../stake/StakeView.sol';\n\ncontract StakeViewTest__getActiveStakedEth is t {\n    function test__StakeView__getActiveStakedEth__a() public {\n        assertEq(StakeView.getActiveStakedEth(), 0);\n    }\n}\n"
    },
    "src/_test/stake/StakeView/getActiveEthPerShare.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {StakeView} from '../../../stake/StakeView.sol';\n\ncontract StakeViewTest__getActiveEthPerShare is t {\n    function test__StakeView__getActiveEthPerShare__a() public {\n        assertEq(StakeView.getActiveEthPerShare(), 0);\n    }\n}\n"
    },
    "src/_test/stake/StakeCore/addStakedSharesAndEth.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {StakeCore} from '../../../stake/StakeCore.sol';\n\ncontract StakeCoreTest__addStakedSharesAndEth is t {\n    function test__StakeCore__addStakedShareAndEth__a() public {\n        StakeCore.addStakedShareAndEth(0);\n    }\n}\n"
    },
    "src/_test/stake/StakeCore/addStakedShares.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {StakeCore} from '../../../stake/StakeCore.sol';\n\ncontract StakeCoreTest__addStakedShares is t {\n    function test__StakeCore__addStakedShares__a() public {\n        // StakeCore.addStakedShares(0);\n    }\n}\n"
    },
    "src/_test/stake/StakeCore/addStakedEth.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {StakeCore} from '../../../stake/StakeCore.sol';\n\n// import {console} from '../../utils/console.sol';\n\ncontract StakeCoreTest__addStakedEth is t {\n    function test__StakeCore__addStakedEth__a() public {\n        // StakeCore.addStakedEth(0);\n\n    }\n}\n"
    },
    "src/_test/epoch/EpochView/calculateSeed.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {EpochCore} from '../../../epoch/EpochCore.sol';\n\ncontract EpochCoreTest__calculateSeed is t {\n    function test__EpochCore__calculateSeed__a() public {\n        hevm.roll(100);\n\n        (uint256 seed, uint256 epoch) = EpochCore.calculateSeed();\n\n        assertEq(seed, 9912418261204039789768554002824411088073917673079298756120843478505709301651);\n        assertEq(epoch, 4);\n    }\n}\n"
    },
    "src/_test/epoch/EpochView/activeEpoch.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from '../../utils/DSTestPlus.sol';\n\nimport {EpochCore} from '../../../epoch/EpochCore.sol';\n\ncontract EpochCoreTest__activeEpoch is t {\n    function test__EpochCore__activeEpoch__a() public {\n        hevm.roll(100);\n\n        assertEq(EpochCore.activeEpoch(), 4);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}