{
  "language": "Solidity",
  "sources": {
    "src/_test/dev/Minter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../../interfaces/nuggftv1/INuggftV1.sol';\n\ncontract NuggftV1MinterHelper {\n    function delegateem(address nuggftv1, uint160 id) external payable {\n        INuggftV1(nuggftv1).delegate{value: msg.value}(address(this), id);\n    }\n\n    function claimem(address nuggftv1, uint160 id) external {\n        INuggftV1(nuggftv1).claim(address(this), id);\n\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}\n\ncontract NuggftV1Minter {\n    address immutable minterHelper;\n    address immutable deployer;\n\n    constructor() {\n        minterHelper = address(new NuggftV1MinterHelper());\n        deployer = msg.sender;\n    }\n\n    function mintem(\n        address nuggftv1,\n        uint160 start,\n        uint160 amount\n    ) external payable {\n        for (uint160 i = start; i < start + amount; i++) {\n            INuggftV1(nuggftv1).mint{value: INuggftV1(nuggftv1).minSharePrice()}(uint160(i));\n            uint96 floor = INuggftV1(nuggftv1).ethPerShare() * 3;\n            INuggftV1(nuggftv1).approve(nuggftv1, uint160(i));\n            INuggftV1(nuggftv1).swap(uint160(i), floor);\n            NuggftV1MinterHelper(minterHelper).delegateem{value: floor}(nuggftv1, i);\n        }\n    }\n\n    function claimem(\n        address nuggftv1,\n        uint160 start,\n        uint160 amount\n    ) external {\n        for (uint160 i = start; i < start + amount; i++) {\n            NuggftV1MinterHelper(minterHelper).claimem(nuggftv1, i);\n        }\n    }\n\n    function byebye() external {\n        require(msg.sender == deployer);\n        selfdestruct(payable(msg.sender));\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Token} from './INuggftV1Token.sol';\nimport {INuggftV1Stake} from './INuggftV1Stake.sol';\nimport {INuggftV1Proof} from './INuggftV1Proof.sol';\nimport {INuggftV1Dotnugg} from './INuggftV1Dotnugg.sol';\nimport {INuggftV1Swap} from './INuggftV1Swap.sol';\nimport {INuggftV1Loan} from './INuggftV1Loan.sol';\nimport {INuggftV1Epoch} from './INuggftV1Epoch.sol';\n\nimport {IERC721Metadata} from '../IERC721.sol';\n\ninterface INuggftV1 is\n    IERC721Metadata,\n    INuggftV1Token,\n    INuggftV1Stake,\n    INuggftV1Proof,\n    INuggftV1Dotnugg,\n    INuggftV1Swap,\n    INuggftV1Loan,\n    INuggftV1Epoch\n{}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721} from '../IERC721.sol';\n\ninterface INuggftV1Token is IERC721 {\n    function mint(uint160 tokenId) external payable;\n\n    function trustedMint(uint160 tokenId, address to) external payable;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Stake {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    event ProtocolEthExtracted(uint96 eth);\n    event MigratorV1Updated(address migrator);\n    event MigrateV1Sent(address v2, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n    event Burn(uint160 tokenId, address owner, uint96 ethOwed);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function migrate(uint160 tokenId) external;\n\n    /// @notice burns a nugg from existance, dealing the eth worth of that share to the user\n    /// @dev should only be called directly\n    /// @param tokenId the id of the nugg being burned\n    function burn(uint160 tokenId) external;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice returns the minimum eth that must be added to create a new share\n    /// @dev premium here is used to push against dillution of supply through ensuring the price always increases\n    /// @dev used by the front end\n    /// @return res -> premium + protcolFee + ethPerShare\n    function minSharePrice() external view returns (uint96 res);\n\n    /// @notice returns the amount of eth extractable by protocol\n    /// @dev this will be\n    /// @return res -> (PROTOCOL_FEE_BPS * [all eth staked] / 10000) - [all previously extracted eth]\n    function protocolEth() external view returns (uint96);\n\n    /// @notice returns the total number of staked shares held by the contract\n    /// @dev this is equivilent to the amount of nuggs in existance\n    function stakedShares() external view returns (uint64);\n\n    function totalSupply() external view returns (uint256);\n\n    /// @notice returns the total amount of staked eth held by the contract\n    /// @dev can be used as the market-cap or tvl of all nuggft v1\n    /// @dev not equivilent to the balance of eth the contract holds, which also hs protocolEth and\n    /// unclaimed eth from unsuccessful swaps\n    function stakedEth() external view returns (uint96);\n\n    /// @notice returns the total \"ethPerShare\" held by the contract\n    /// @dev this value not always equivilent to the \"floor\" price which can consist of perceived value.\n    /// can be looked at as an \"intrinsic floor\"\n    /// @dev this is the value that users will receive when their either burn or loan out nuggs\n    /// @return res -> [current staked eth] / [current staked shares]\n    function ethPerShare() external view returns (uint96);\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice sends the current protocolEth to the user and resets the value to zero\n    /// @dev caller must be a trusted user\n    function extractProtocolEth() external;\n\n    /// @notice sets the migrator contract\n    /// @dev caller must be a trusted user\n    /// @param migrator the address to set as the migrator contract\n    function setMigrator(address migrator) external;\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Proof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Proof {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                             STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function rotate(\n        uint160 tokenId,\n        uint8 index0,\n        uint8 index1\n    ) external;\n\n    function anchor(\n        uint160 tokenId,\n        uint16 itemId,\n        uint256 x,\n        uint256 y\n    ) external;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               VIEW FUNCTIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function proofOf(uint160 tokenId) external view returns (uint256);\n\n    function proofToDotnuggMetadata(uint160 tokenId)\n        external\n        view\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        );\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Dotnugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Implementer} from '../dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1ImplementerMetadata} from '../dotnuggv1/IDotnuggV1ImplementerMetadata.sol';\n\ninterface INuggftV1Dotnugg is IDotnuggV1Implementer, IDotnuggV1ImplementerMetadata {}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Swap {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function delegate(address sender, uint160 tokenId) external payable;\n\n    function delegateItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external payable;\n\n    function claim(address sender, uint160 tokenId) external;\n\n    function claimItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemid\n    ) external;\n\n    function swap(uint160 tokenId, uint96 floor) external;\n\n    function swapItem(\n        uint160 sellerTokenId,\n        uint16 itemid,\n        uint96 floor\n    ) external;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @notice calculates the minimum eth that must be sent with a delegate call\n    /// @dev returns 0 if no delegate can be made for this oken\n    /// @param tokenId -> the token to be delegated to\n    /// @param sender -> the address of the user who will be delegating\n    /// @return canDelegate -> instead of reverting this function will return false\n    /// @return nextSwapAmount -> the minimum value that must be sent with a delegate call\n    /// @return senderCurrentOffer ->\n    function valueForDelegate(address sender, uint160 tokenId)\n        external\n        view\n        returns (\n            bool canDelegate,\n            uint96 nextSwapAmount,\n            uint96 senderCurrentOffer\n        );\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Loan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Loan {\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                EVENTS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // event TakeLoan(uint160 tokenId, uint96 principal);\n    // event Payoff(uint160 tokenId, address account, uint96 payoffAmount);\n    // event Rebalance(uint160 tokenId, uint96 fee, uint96 earned);\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            STATE CHANGING\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function rebalance(uint160 tokenId) external payable;\n\n    function loan(uint160 tokenId) external;\n\n    function payoff(uint160 tokenId) external payable;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            VIEW FUNCTIONS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @notice for a nugg's active loan: calculates the current min eth a user must send to payoff or rebalance\n    /// @dev contract ->\n    /// @dev frontend -> used to set the amount of eth for user\n    /// @param tokenId the token who's current loan to check\n    /// @return toPayoff ->  the current amount loaned out, plus the final rebalance fee\n    /// @return toRebalance ->  the fee a user must pay to rebalance (and extend) the loan on their nugg\n    /// @return earned -> the amount of eth the minSharePrice has increased since loan was last rebalanced\n    /// @return epochDue -> the final epoch a user is safe from liquidation (inclusive)\n    /// @return loaner -> the user responsable for the loan\n    function loanInfo(uint160 tokenId)\n        external\n        view\n        returns (\n            uint96 toPayoff,\n            uint96 toRebalance,\n            uint96 earned,\n            uint32 epochDue,\n            address loaner\n        );\n\n    /// @notice \"toPayoff\" value from \"loanInfo\"\n    /// @dev should be used to tell user how much eth to send for payoff\n    function valueForPayoff(uint160 tokenId) external view returns (uint96 res);\n\n    /// @notice \"toRebalance\" value from \"loanInfo\"\n    /// @dev should be used to tell user how much eth to send for rebalance\n    function valueForRebalance(uint160 tokenId) external view returns (uint96 res);\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Epoch {\n    /// @notice Explain to an end user what this does\n    /// @dev Explain to a developer any extra details\n    event Genesis(uint256 blocknum, uint32 interval, uint32 offset);\n\n    function epoch() external view returns (uint32 res);\n}\n"
    },
    "src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory data\n    ) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Implementer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Metadata} from './IDotnuggV1Metadata.sol';\n\ninterface IDotnuggV1Implementer {\n    function dotnuggV1Callback(uint256 tokenId) external view returns (IDotnuggV1Metadata.Memory memory data);\n\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external;\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1ImplementerMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1ImplementerMetadata {\n    event DotnuggV1ResolverUpdated(uint256 tokenId, address to);\n\n    function setDotnuggV1Resolver(uint256 tokenId, address to) external;\n\n    function dotnuggV1ResolverOf(uint256 tokenId) external view returns (address resolver);\n\n    function dotnuggV1Processor() external returns (address);\n\n    function dotnuggV1DefaultWidth() external returns (uint8);\n\n    function dotnuggV1DefaultZoom() external returns (uint8);\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1Metadata {\n    struct Memory {\n        uint256 version;\n        uint256 renderedAt;\n        string name;\n        string desc;\n        address owner;\n        uint256 tokenId;\n        uint8[] ids;\n        uint8[] xovers;\n        uint8[] yovers;\n        string[] labels;\n        bytes data;\n    }\n}\n"
    },
    "src/NuggftV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721, IERC165, IERC721Metadata} from './interfaces/IERC721.sol';\n\nimport {NuggftV1Loan} from './core/NuggftV1Loan.sol';\nimport {NuggftV1Dotnugg} from './core/NuggftV1Dotnugg.sol';\nimport {Trust} from './core/Trust.sol';\n\nimport {INuggftV1Migrator} from './interfaces/nuggftv1/INuggftV1Migrator.sol';\nimport {IDotnuggV1Metadata} from './interfaces/dotnuggv1/IDotnuggV1Metadata.sol';\nimport {IDotnuggV1Implementer} from './interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1ImplementerMetadata} from './interfaces/dotnuggv1/IDotnuggV1ImplementerMetadata.sol';\nimport {IDotnuggV1} from './interfaces/dotnuggv1/IDotnuggV1.sol';\n\nimport {INuggftV1Token} from './interfaces/nuggftv1/INuggftV1Token.sol';\nimport {INuggftV1Stake} from './interfaces/nuggftv1/INuggftV1Stake.sol';\n\nimport {INuggftV1} from './interfaces/nuggftv1/INuggftV1.sol';\n\nimport {SafeTransferLib} from './libraries/SafeTransferLib.sol';\nimport {SafeCastLib} from './libraries/SafeCastLib.sol';\n\nimport {NuggftV1StakeType} from './types/NuggftV1StakeType.sol';\n\n/// @title NuggFT V1\n/// @author nugg.xyz - danny7even & dub6ix\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\n/// @dev the words \"share\" and \"nugg\" are used interchangably throughout\n\n/// deviations from ERC721 standard:\n/// 1. no verificaiton the receiver is a ERC721Reciever - on top of this being a gross waste of gas,\n/// the way the swapping logic works makes this only worth calling when a user places an offer - and\n/// we did not want to call \"onERC721Recieved\" when no token was being sent.\n/// 2.\ncontract NuggftV1 is IERC721Metadata, NuggftV1Loan {\n    using SafeCastLib for uint256;\n\n    using NuggftV1StakeType for uint256;\n\n    constructor(address _defaultResolver) NuggftV1Dotnugg(_defaultResolver) Trust(msg.sender) {}\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IDotnuggV1Implementer).interfaceId ||\n            interfaceId == type(IDotnuggV1ImplementerMetadata).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function name() public pure override returns (string memory) {\n        return 'Nugg Fungible Token V1';\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return 'NUGGFT';\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory res) {\n        uint160 safeTokenId = tokenId.safe160();\n\n        address resolver = hasResolver(safeTokenId) ? dotnuggV1ResolverOf(safeTokenId) : dotnuggV1Processor;\n\n        (, res) = IDotnuggV1(dotnuggV1Processor).dotnuggToUri(\n            address(this),\n            tokenId,\n            resolver,\n            dotnuggV1DefaultWidth,\n            dotnuggV1DefaultZoom\n        );\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                CORE\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc IDotnuggV1Implementer\n    function dotnuggV1Callback(uint256 tokenId) public view override returns (IDotnuggV1Metadata.Memory memory data) {\n        (uint256 proof, uint8[] memory ids, uint8[] memory xovers, uint8[] memory yovers) = proofToDotnuggMetadata(tokenId.safe160());\n\n        string[] memory labels = new string[](8);\n\n        labels[0] = 'BASE';\n        labels[1] = 'EYES';\n        labels[2] = 'MOUTH';\n        labels[3] = 'HAIR';\n        labels[4] = 'HAT';\n        labels[5] = 'BACK';\n        labels[6] = 'NECK';\n        labels[7] = 'HOLD';\n\n        data = IDotnuggV1Metadata.Memory({\n            version: 1,\n            renderedAt: block.timestamp,\n            name: 'NuggFT V1',\n            desc: 'Nugg Fungible Token V1',\n            owner: owners[tokenId], // fix\n            tokenId: tokenId,\n            data: abi.encode(proof),\n            ids: ids,\n            xovers: xovers,\n            yovers: yovers,\n            labels: labels\n        });\n    }\n\n    /// @inheritdoc INuggftV1Token\n    function trustedMint(uint160 tokenId, address to) external payable override requiresTrust {\n        require(tokenId < TRUSTED_MINT_TOKENS && tokenId != 0, 'G:1');\n\n        // require(!exists(tokenId), 'G:2');\n\n        addStakedShareFromMsgValue();\n\n        setProof(tokenId);\n\n        _mintTo(to, tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Token\n    function mint(uint160 tokenId) public payable override {\n        require(tokenId < UNTRUSTED_MINT_TOKENS + TRUSTED_MINT_TOKENS && tokenId > TRUSTED_MINT_TOKENS, 'G:1');\n\n        // require(!exists(tokenId), 'G:2');\n\n        addStakedShareFromMsgValue();\n\n        setProof(tokenId);\n\n        _mintTo(msg.sender, tokenId);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                BURN/MIGRATE\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Stake\n    function burn(uint160 tokenId) external {\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        SafeTransferLib.safeTransferETH(msg.sender, ethOwed);\n\n        emit Burn(tokenId, msg.sender, ethOwed);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function migrate(uint160 tokenId) external {\n        require(migrator != address(0), 'T:4');\n\n        // stores the proof before deleting the nugg\n        uint256 proof = proofOf(tokenId);\n\n        uint96 ethOwed = subStakedShare(tokenId);\n\n        INuggftV1Migrator(migrator).nuggftMigrateFromV1{value: ethOwed}(tokenId, proof, msg.sender);\n\n        emit MigrateV1Sent(migrator, tokenId, proof, msg.sender, ethOwed);\n    }\n\n    /// @notice removes a staked share from the contract,\n    /// @dev this is the only way to remove a share\n    /// @dev caculcates but does not handle dealing the eth - which is handled by the two helpers above\n    /// @dev ensures the user is the owner of the nugg\n    /// @param tokenId the id of the nugg being unstaked\n    /// @return ethOwed -> the amount of eth owed to the unstaking user - equivilent to \"ethPerShare\"\n    function subStakedShare(uint160 tokenId) internal returns (uint96 ethOwed) {\n        // reverts if token does not exist\n        address owner = _ownerOf(tokenId);\n\n        require(_getApproved(tokenId) == address(this) && owner == msg.sender, 'T:3');\n\n        uint256 cache = stake;\n\n        // hanles all logic not related to staking the nugg\n        delete owners[tokenId];\n        delete approvals[tokenId];\n\n        delete swaps[tokenId];\n        delete loans[tokenId];\n        delete proofs[tokenId];\n        delete resolvers[tokenId];\n\n        emitTransferEvent(owner, address(0), tokenId);\n\n        ethOwed = calculateEthPerShare(cache);\n\n        /// TODO - test migration\n        assert(cache.shares() >= 1);\n        assert(cache.staked() >= ethOwed);\n\n        cache = cache.subShares(1);\n        cache = cache.subStaked(ethOwed);\n\n        stake = cache;\n    }\n}\n"
    },
    "src/core/NuggftV1Loan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Loan} from '../interfaces/nuggftv1/INuggftV1Loan.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1AgentType} from '../types/NuggftV1AgentType.sol';\n\nimport {NuggftV1Swap} from './NuggftV1Swap.sol';\n\nabstract contract NuggftV1Loan is INuggftV1Loan, NuggftV1Swap {\n    using SafeCastLib for uint256;\n\n    using NuggftV1AgentType for uint256;\n\n    mapping(uint160 => uint256) loans;\n\n    uint32 constant LIQUIDATION_PERIOD = 1000;\n\n    uint96 constant REBALANCE_FEE_BPS = 100;\n\n    /// @inheritdoc INuggftV1Loan\n    function loan(uint160 tokenId) external override {\n        address sender = _ownerOf(tokenId);\n\n        require(_isOperatorFor(msg.sender, sender), 'L:0');\n\n        (uint256 loanData, ) = NuggftV1AgentType.newAgentType(epoch(), sender, ethPerShare(), false);\n\n        loans[tokenId] = loanData; // starting swap data\n\n        // emit TakeLoan(tokenId, loanData.eth());\n\n        approvedTransferToSelf(tokenId);\n\n        SafeTransferLib.safeTransferETH(sender, loanData.eth());\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function payoff(uint160 tokenId) external payable override {\n        (uint96 toPayoff, uint96 toRebalance, uint96 owed, uint96 epochDue, address loaner) = loanInfo(tokenId);\n\n        assert(address(this) == _ownerOf(tokenId)); // should always be true - should revert in loanInfo\n\n        delete loans[tokenId];\n\n        address benif = msg.sender;\n\n        if (epochDue >= epoch()) {\n            // if liquidaton deadline has not passed - check perrmission\n            require(_isOperatorFor(msg.sender, loaner), 'L:1');\n            benif = loaner;\n        }\n\n        uint96 value = msg.value.safe96();\n\n        require(toPayoff <= value, 'L:2');\n\n        uint96 overpayment = value - toPayoff;\n\n        // uint96 owed = earned + overpayment;\n\n        // emit Rebalance(tokenId, toRebalance, earned);\n\n        // emit Payoff(tokenId, benif, toPayoff);\n\n        addStakedEth(toRebalance + overpayment);\n\n        SafeTransferLib.safeTransferETH(benif, owed);\n\n        checkedTransferFromSelf(benif, tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function rebalance(uint160 tokenId) external payable override {\n        (, uint96 toRebalance, uint96 earned, , address loaner) = loanInfo(tokenId);\n\n        assert(address(this) == _ownerOf(tokenId)); // should always be true - should revert in loanInfo\n\n        require(toRebalance <= msg.value, 'L:3');\n\n        // uint96 overpayment = msg.value.safe96() - toRebalance;\n\n        // uint96 owed = earned;\n\n        // must be done before new principal is calculated\n        addStakedEth(msg.value.safe96());\n\n        (uint256 res, uint96 dust) = NuggftV1AgentType.newAgentType(epoch(), loaner, ethPerShare(), false);\n\n        loans[tokenId] = res;\n\n        // emit Rebalance(tokenId, toRebalance, earned);\n\n        SafeTransferLib.safeTransferETH(loaner, earned + dust);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function valueForPayoff(uint160 tokenId) external view returns (uint96 res) {\n        (res, , , , ) = loanInfo(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function valueForRebalance(uint160 tokenId) external view returns (uint96 res) {\n        (, res, , , ) = loanInfo(tokenId);\n    }\n\n    /// @inheritdoc INuggftV1Loan\n    function loanInfo(uint160 tokenId)\n        public\n        view\n        override\n        returns (\n            uint96 toPayoff,\n            uint96 toRebalance,\n            uint96 earned,\n            uint32 epochDue,\n            address loaner\n        )\n    {\n        uint256 cache = loans[tokenId];\n\n        loaner = cache.account();\n\n        require(loaner != address(0), 'L:4');\n\n        // the amount of eth currently loanded by user\n        uint96 curr = cache.eth();\n\n        uint96 activeEps = ethPerShare();\n\n        toRebalance = ((curr * REBALANCE_FEE_BPS) / 10000);\n\n        toPayoff = curr + toRebalance;\n\n        // value earned while lone was taken out\n        earned = toPayoff >= activeEps ? 0 : activeEps - toPayoff;\n\n        epochDue = cache.epoch() + LIQUIDATION_PERIOD;\n    }\n}\n"
    },
    "src/core/NuggftV1Dotnugg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Storage} from '../interfaces/dotnuggv1/IDotnuggV1Storage.sol';\n\nimport {IDotnuggV1Metadata} from '../interfaces/dotnuggv1/IDotnuggV1Metadata.sol';\nimport {IDotnuggV1Resolver} from '../interfaces/dotnuggv1/IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Implementer} from '../interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\nimport {IDotnuggV1ImplementerMetadata} from '../interfaces/dotnuggv1/IDotnuggV1ImplementerMetadata.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nimport {INuggftV1Dotnugg} from '../interfaces/nuggftv1/INuggftV1Dotnugg.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {NuggftV1Token} from './NuggftV1Token.sol';\n\nimport {Trust} from './Trust.sol';\n\nabstract contract NuggftV1Dotnugg is INuggftV1Dotnugg, NuggftV1Token, Trust {\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    address public override dotnuggV1Processor;\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    uint8 public override dotnuggV1DefaultWidth = 45;\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    uint8 public override dotnuggV1DefaultZoom = 10;\n\n    mapping(uint256 => address) resolvers;\n\n    uint256 internal featureLengths;\n\n    constructor(address _dotnuggV1Processor) {\n        require(_dotnuggV1Processor != address(0), 'F:4');\n        dotnuggV1Processor = _dotnuggV1Processor;\n    }\n\n    /// @inheritdoc IDotnuggV1Implementer\n    function dotnuggV1StoreFiles(uint256[][] calldata data, uint8 feature) external override requiresTrust {\n        uint8 len = IDotnuggV1Storage(dotnuggV1Processor).store(feature, data);\n\n        uint256 cache = featureLengths;\n\n        uint256 newLen = _lengthOf(cache, feature) + len;\n\n        featureLengths = ShiftLib.set(cache, 8, feature * 8, newLen);\n    }\n\n    function lengthOf(uint8 feature) external view returns (uint8) {\n        return _lengthOf(featureLengths, feature);\n    }\n\n    function _lengthOf(uint256 cache, uint8 feature) internal pure returns (uint8) {\n        return uint8(ShiftLib.get(cache, 8, feature * 8));\n    }\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    function setDotnuggV1Resolver(uint256 tokenId, address to) public virtual override {\n        require(_isOperatorForOwner(msg.sender, tokenId.safe160()), 'F:5');\n\n        resolvers[tokenId] = to;\n\n        emit DotnuggV1ResolverUpdated(tokenId, to);\n    }\n\n    /// @inheritdoc IDotnuggV1ImplementerMetadata\n    function dotnuggV1ResolverOf(uint256 tokenId) public view virtual override returns (address) {\n        return resolvers[tokenId.safe160()];\n    }\n\n    function hasResolver(uint160 tokenId) internal view returns (bool) {\n        return resolvers[tokenId] != address(0);\n    }\n}\n"
    },
    "src/core/Trust.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ITrust} from '../interfaces/ITrust.sol';\n\n/// @notice Ultra minimal authorization logic for smart contracts.\n/// @author Inspired by Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/auth.sol)\nabstract contract Trust is ITrust {\n    event UserTrustUpdated(address indexed user, bool trusted);\n\n    mapping(address => bool) public override isTrusted;\n\n    constructor(address initialUser) {\n        isTrusted[initialUser] = true;\n\n        emit UserTrustUpdated(initialUser, true);\n    }\n\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\n        isTrusted[user] = trusted;\n\n        emit UserTrustUpdated(user, trusted);\n    }\n\n    modifier requiresTrust() {\n        _requiresTrust();\n        _;\n    }\n\n    function _requiresTrust() internal view {\n        require(isTrusted[msg.sender], 'UNTRUSTED');\n    }\n}\n"
    },
    "src/interfaces/nuggftv1/INuggftV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface INuggftV1Migrator {\n    event MigrateV1Accepted(address v1, uint160 tokenId, uint256 proof, address owner, uint96 eth);\n\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable;\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Metadata} from './IDotnuggV1Metadata.sol';\nimport {IDotnuggV1Resolver} from './IDotnuggV1Resolver.sol';\nimport {IDotnuggV1Storage} from './IDotnuggV1Storage.sol';\n\ninterface IDotnuggV1 is IDotnuggV1Resolver, IDotnuggV1Storage {\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) external view returns (uint256[] memory file, IDotnuggV1Metadata.Memory memory dat);\n\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, bytes memory res);\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, uint256[] memory res);\n\n    function dotnuggToMetadata(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, IDotnuggV1Metadata.Memory memory res);\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, string memory res);\n\n    function dotnuggToUri(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) external view returns (address resolvedBy, string memory res);\n}\n"
    },
    "src/libraries/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\nlibrary SafeTransferLib {\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               ETH OPERATIONS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, 'Z:0');\n    }\n}\n"
    },
    "src/libraries/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/// Adapted from Rari-Capital/solmate\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        require(x <= type(uint160).max);\n        y = uint160(x);\n    }\n\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        require(x <= type(uint96).max);\n        y = uint96(x);\n    }\n\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        require(x <= type(uint64).max);\n        y = uint64(x);\n    }\n\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        require(x <= type(uint32).max);\n        y = uint32(x);\n    }\n\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        require(x <= type(uint16).max);\n        y = uint16(x);\n    }\n\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        require(x <= type(uint8).max);\n        y = uint8(x);\n    }\n\n    // function safe6to256(uint256 x) internal pure returns (uint256 y) {\n    //     require(x <= 63);\n    //     y = x;\n    // }\n}\n"
    },
    "src/types/NuggftV1StakeType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\nlibrary NuggftV1StakeType {\n    /// 96 protocol\n    /// 96 stakedEth\n    /// 64 stakedShares\n\n    function proto(uint256 cache) internal pure returns (uint96 res) {\n        res = uint96(cache);\n    }\n\n    function proto(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        res = cache & ShiftLib.fullsubmask(96, 0);\n        res |= update;\n    }\n\n    function addProto(uint256 cache, uint96 add) internal pure returns (uint256 res) {\n        add += proto(cache);\n        res = proto(cache, add);\n    }\n\n    function subProto(uint256 cache, uint96 sub) internal pure returns (uint256 res) {\n        sub = proto(cache) - sub;\n        res = proto(cache, sub);\n    }\n\n    // @test input output unit test\n    function staked(uint256 cache) internal pure returns (uint96 res) {\n        // using casting to select only 96\n        res = uint96(cache >> 96);\n    }\n\n    function staked(uint256 cache, uint96 update) internal pure returns (uint256 res) {\n        // clear stakedEth\n        res = cache & ShiftLib.fullsubmask(96, 96);\n        res |= uint256(update) << 96;\n    }\n\n    function addStaked(uint256 cache, uint96 add) internal pure returns (uint256 res) {\n        add += staked(cache);\n        res = staked(cache, add);\n    }\n\n    function subStaked(uint256 cache, uint96 sub) internal pure returns (uint256 res) {\n        sub = staked(cache) - sub;\n        res = staked(cache, sub);\n    }\n\n    // @test input output unit test\n    function shares(uint256 cache) internal pure returns (uint64 res) {\n        res = uint64(cache >> 192);\n    }\n\n    function addShares(uint256 cache, uint64 add) internal pure returns (uint256 res) {\n        add += shares(cache);\n        res = shares(cache, add);\n    }\n\n    function subShares(uint256 cache, uint64 sub) internal pure returns (uint256 res) {\n        sub = shares(cache) - sub;\n        res = shares(cache, sub);\n    }\n\n    function shares(uint256 cache, uint64 update) internal pure returns (uint256 res) {\n        res = cache & type(uint192).max;\n        res |= (uint256(update) << 192);\n    }\n}\n"
    },
    "src/types/NuggftV1AgentType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\nlibrary NuggftV1AgentType {\n    using SafeCastLib for uint256;\n\n    // 10**13\n    uint96 constant COMPRESSION_PERCISION = 0x9184E72A000;\n\n    // struct Memory {\n    //     uint96 eth;\n    //     uint32 epoch;\n    //     address account;\n    //     bool isOwner;\n    //     bool flag;\n    // }\n\n    // function unpack(uint256 packed) internal pure returns (Memory memory m) {\n    //     if (packed != 0) {\n    //         m.flag = true;\n    //         m.epoch = epoch(packed);\n    //         m.account = account(packed);\n    //         m.eth = eth(packed);\n    //         m.isOwner = isOwner(packed);\n    //     }\n    // }\n\n    // function pack(Memory memory m) internal pure returns (uint256 outuput, uint96 dust) {\n    //     (outuput, dust) = newAgentType(m.epoch, m.account, m.eth, m.isOwner);\n    // }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                               CALCULATION\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // @test  manual\n    function addIncrement(uint96 value) internal pure returns (uint96) {\n        return compressEthRoundUp(((value * 10200) / 10000));\n    }\n\n    // @test  manual\n    function compressEthRoundDown(uint96 value) internal pure returns (uint96) {\n        return (value / COMPRESSION_PERCISION) * COMPRESSION_PERCISION;\n    }\n\n    // @test  manual\n    function compressEthRoundUp(uint96 value) internal pure returns (uint96) {\n        if (value % COMPRESSION_PERCISION > 0) {\n            return ((value / COMPRESSION_PERCISION) + 1) * COMPRESSION_PERCISION;\n        } else {\n            return compressEthRoundDown(value);\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                              SHIFT HELPERS\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    // @test input output unit test\n    // type(uint96).max / 10**13 = 0x01C25C268497681 =  7922816251426433\n    // type(uint56).max          = 0x100000000000000 = 72057594037927936\n    function eth(uint256 input) internal pure returns (uint96 res) {\n        return (ShiftLib.get(input, 56, 160) * COMPRESSION_PERCISION).safe96();\n    }\n\n    function eth(uint256 input, uint96 update) internal pure returns (uint256 cache, uint96 rem) {\n        rem = update % COMPRESSION_PERCISION;\n        cache = ShiftLib.set(input, 56, 160, update / COMPRESSION_PERCISION);\n    }\n\n    // @test  input output unit test\n    function epoch(uint256 input, uint32 update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 32, 216, update);\n    }\n\n    function epoch(uint256 input) internal pure returns (uint32 res) {\n        return ShiftLib.get(input, 32, 216).safe32();\n    }\n\n    // @test  input output unit test\n    function account(uint256 input) internal pure returns (address res) {\n        res = address(ShiftLib.get(input, 160, 0).safe160());\n    }\n\n    function account(uint256 input, address update) internal pure returns (uint256 output) {\n        output = ShiftLib.set(input, 160, 0, uint160(update));\n    }\n\n    // @test  input output unit test\n    function isOwner(uint256 input, bool update) internal pure returns (uint256 res) {\n        return ShiftLib.set(input, 1, 255, update ? 0x1 : 0x0);\n    }\n\n    function isOwner(uint256 input) internal pure returns (bool output) {\n        output = ShiftLib.get(input, 1, 255) == 0x1;\n    }\n\n    // @test  check to see if it does this - will be easy\n    function flag(uint256 input) internal pure returns (uint256 res) {\n        res = ShiftLib.set(input, 1, 254, 0x01);\n    }\n\n    // @test  manual\n    function newAgentType(\n        uint32 _epoch,\n        address _account,\n        uint96 _eth,\n        bool _isOwner\n    ) internal pure returns (uint256 res, uint96 dust) {\n        res = epoch(res, _epoch);\n        res = account(res, _account);\n        if (_isOwner) res = isOwner(res, true);\n        (res, dust) = eth(res, _eth);\n        res = flag(res);\n    }\n}\n"
    },
    "src/core/NuggftV1Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Swap} from '../interfaces/nuggftv1/INuggftV1Swap.sol';\n\nimport {NuggftV1Stake} from './NuggftV1Stake.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1AgentType} from '../types/NuggftV1AgentType.sol';\n\n/// @notice mechanism for trading of nuggs between users (and items between nuggs)\n/// @dev Explain to a developer any extra details\nabstract contract NuggftV1Swap is INuggftV1Swap, NuggftV1Stake {\n    using SafeCastLib for uint256;\n\n    using NuggftV1AgentType for uint256;\n\n    struct Mapping {\n        Storage self;\n        mapping(uint16 => Storage) items;\n    }\n\n    struct Storage {\n        uint256 data;\n        mapping(address => uint256) offers;\n    }\n\n    struct Memory {\n        uint256 swapData;\n        uint256 offerData;\n        uint32 activeEpoch;\n        address sender;\n    }\n\n    mapping(uint16 => uint256) protocolItems;\n    mapping(uint160 => Mapping) swaps;\n\n    uint96 public constant MIN_OFFER = 10**13 * 50;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  delegate\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function delegate(address sender, uint160 tokenId) external payable override {\n        require(_isOperatorFor(msg.sender, sender), 'S:0');\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        // make sure user is not the owner of swap\n        // we do not know how much to give them when they call \"claim\" otherwise\n\n        if (m.activeEpoch == tokenId && m.swapData == 0) {\n            // to ensure we at least have enough to increment the offer amount by 2%\n            require(msg.value >= MIN_OFFER, 'S:1');\n\n            // we do not need this, could take tokenId out as an argument - but do not want to give users\n            // the ability to accidently place an offer for nugg A and end up minting nugg B.\n            assert(m.offerData == 0);\n\n            (s.data, ) = NuggftV1AgentType.newAgentType(m.activeEpoch, m.sender, msg.value.safe96(), false);\n\n            addStakedShareFromMsgValue();\n\n            setProofFromEpoch(tokenId);\n\n            emitTransferEvent(address(0), address(this), tokenId);\n        } else {\n            require(m.swapData != 0, 'S:4');\n\n            if (m.offerData != 0) {\n                // forces user to claim previous swap before acting on this one\n                // prevents owner from COMMITTING on their own swap - not offering\n                require(m.offerData.epoch() >= m.activeEpoch, 'S:R');\n\n                require(!m.offerData.isOwner(), 'NOPE'); // always be caught by the require above\n            }\n\n            // if the leader \"owns\" the swap, then it was initated by them - \"commit\" must be executed\n            m.swapData.isOwner() ? commit(s, m) : offer(s, m);\n        }\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function delegateItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external payable override {\n        require(_isOperatorForOwner(msg.sender, buyerTokenId), 'S:6');\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(buyerTokenId));\n\n        require(m.swapData != 0, 'S:S');\n\n        if (m.offerData != 0) {\n            // forces user to claim previous swap before acting on this one\n            // prevents owner from COMMITTING on their own swap - not offering\n            require(m.offerData.epoch() >= m.activeEpoch, 'S:7');\n\n            require(!m.offerData.isOwner(), 'NOPE'); // always be caught by the require above\n        }\n\n        m.offerData == 0 && m.swapData.isOwner() ? commit(s, m) : offer(s, m);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  claim\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function claim(address sender, uint160 tokenId) external override {\n        require(_isOperatorFor(msg.sender, sender), 'S:8');\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        delete s.offers[sender];\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            delete s.data;\n\n            checkedTransferFromSelf(sender, tokenId);\n        } else {\n            SafeTransferLib.safeTransferETH(sender, m.offerData.eth());\n        }\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function claimItem(\n        uint160 buyerTokenId,\n        uint160 sellerTokenId,\n        uint16 itemId\n    ) external override {\n        require(_isOperatorForOwner(msg.sender, buyerTokenId), 'S:9');\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(buyerTokenId));\n\n        delete s.offers[address(buyerTokenId)];\n\n        if (checkClaimerIsWinnerOrLoser(m)) {\n            delete s.data;\n\n            require(protocolItems[itemId] > 0, 'P:3');\n\n            addItem(buyerTokenId, itemId);\n\n            protocolItems[itemId]--;\n        } else {\n            SafeTransferLib.safeTransferETH(_ownerOf(buyerTokenId), m.offerData.eth());\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                  swap\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Swap\n    function swap(uint160 tokenId, uint96 floor) external override {\n        address sender = _ownerOf(tokenId);\n\n        require(_isOperatorFor(msg.sender, sender), 'S:A');\n\n        require(floor >= ethPerShare(), 'S:B');\n\n        approvedTransferToSelf(tokenId);\n\n        (Storage storage s, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        // make sure swap does not exist - this logically should never happen\n        require(m.swapData == 0, 'NOPE2');\n\n        // no need to check dust as no value is being transfered\n        (s.data, ) = NuggftV1AgentType.newAgentType(0, sender, floor, true);\n    }\n\n    /// @inheritdoc INuggftV1Swap\n    function swapItem(\n        uint160 sellerTokenId,\n        uint16 itemId,\n        uint96 floor\n    ) external override {\n        require(_isOperatorForOwner(msg.sender, sellerTokenId), 'S:C');\n\n        // will revert if they do not have the item\n        removeItem(sellerTokenId, itemId);\n\n        protocolItems[itemId]++;\n\n        (Storage storage s, Memory memory m) = loadItemSwap(sellerTokenId, itemId, address(sellerTokenId));\n\n        // cannot sell two of the same item at same time\n        require(m.swapData == 0, 'S:D');\n\n        (s.data, ) = NuggftV1AgentType.newAgentType(0, address(sellerTokenId), floor, true);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                    view\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // / @inheritdoc INuggftV1Swap\n    function valueForDelegate(address sender, uint160 tokenId)\n        external\n        view\n        override\n        returns (\n            bool canDelegate,\n            uint96 nextSwapAmount,\n            uint96 senderCurrentOffer\n        )\n    {\n        canDelegate = true;\n\n        (, Memory memory m) = loadTokenSwap(tokenId, sender);\n\n        if (m.swapData == 0) {\n            if (m.activeEpoch == tokenId) {\n                // swap is minting\n                nextSwapAmount = NuggftV1AgentType.compressEthRoundUp(minSharePrice());\n            } else {\n                // swap does not exist\n                return (false, 0, 0);\n            }\n        } else {\n            if (m.offerData.isOwner()) canDelegate = false;\n\n            senderCurrentOffer = m.offerData.eth();\n\n            nextSwapAmount = m.swapData.eth();\n\n            if (nextSwapAmount < ethPerShare()) {\n                nextSwapAmount = ethPerShare();\n            }\n        }\n\n        if (nextSwapAmount == 0) {\n            nextSwapAmount = MIN_OFFER;\n        } else {\n            nextSwapAmount = NuggftV1AgentType.addIncrement(nextSwapAmount);\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                internal\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function commit(Storage storage s, Memory memory m) internal returns (uint96 newAmount) {\n        require(msg.value >= ethPerShare(), 'S:5');\n\n        require(m.offerData == 0 && m.swapData != 0, 'NOPE3');\n\n        require(m.swapData.isOwner(), 'NOPE4');\n\n        // forces a user not to commit on their own swap\n        // commented out as the logic is handled by S:R\n        // require(!m.offerData.isOwner()(), 'S:3');\n\n        (uint256 newSwapData, uint96 increment, uint96 dust) = updateSwapDataWithEpoch(m.swapData, m.activeEpoch + 1, m.sender, 0);\n\n        s.data = newSwapData;\n\n        s.offers[m.swapData.account()] = m.swapData.isOwner(false).epoch(m.activeEpoch + 1);\n\n        addStakedEth(increment + dust);\n\n        return newSwapData.eth();\n    }\n\n    function offer(Storage storage s, Memory memory m) internal returns (uint96 newAmount) {\n        // make sure swap is still active\n        require(m.activeEpoch <= m.swapData.epoch(), 'S:F');\n\n        if (m.swapData.account() != m.sender) s.offers[m.swapData.account()] = m.swapData;\n\n        (uint256 newSwapData, uint96 increment, uint96 dust) = updateSwapDataWithEpoch(\n            m.swapData,\n            m.swapData.epoch(),\n            m.sender,\n            m.offerData.eth()\n        );\n\n        s.data = newSwapData;\n\n        addStakedEth(increment + dust);\n\n        return newSwapData.eth();\n    }\n\n    function checkClaimerIsWinnerOrLoser(Memory memory m) internal pure returns (bool winner) {\n        require(m.offerData != 0, 'S:E');\n\n        bool isOver = m.activeEpoch > m.swapData.epoch();\n        bool isLeader = m.offerData.account() == m.swapData.account();\n        bool isOwner = m.swapData.isOwner() && m.offerData.isOwner();\n\n        return isLeader && (isOwner || isOver);\n    }\n\n    // @test  unit\n    function updateSwapDataWithEpoch(\n        uint256 prevSwapData,\n        uint32 _epoch,\n        address account,\n        uint96 currUserOffer\n    )\n        internal\n        view\n        returns (\n            uint256 res,\n            uint96 increment,\n            uint96 dust\n        )\n    {\n        uint96 baseEth = prevSwapData.eth();\n\n        currUserOffer += msg.value.safe96();\n\n        require(NuggftV1AgentType.addIncrement(baseEth) <= currUserOffer, 'S:G');\n\n        (res, dust) = NuggftV1AgentType.newAgentType(_epoch, account, currUserOffer, false);\n\n        increment = currUserOffer - baseEth;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TOKEN SWAP\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function loadTokenSwap(uint160 tokenId, address account) internal view returns (Storage storage s, Memory memory m) {\n        s = swaps[tokenId].self;\n        m = _load(s, account);\n    }\n\n    function loadItemSwap(\n        uint160 tokenId,\n        uint16 itemId,\n        address account\n    ) internal view returns (Storage storage s, Memory memory m) {\n        s = swaps[tokenId].items[itemId];\n        m = _load(s, account);\n    }\n\n    function _load(Storage storage ptr, address account) private view returns (Memory memory m) {\n        uint256 cache = ptr.data;\n        m.swapData = cache;\n        m.activeEpoch = epoch();\n        m.sender = account;\n\n        if (account == cache.account()) {\n            m.offerData = cache;\n        } else {\n            m.offerData = ptr.offers[account];\n        }\n    }\n}\n"
    },
    "src/libraries/ShiftLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {SafeCastLib} from './SafeCastLib.sol';\n\nlibrary ShiftLib {\n    using SafeCastLib for uint256;\n\n    /// @notice creates a bit mask\n    /// @dev res = (2 ^ bits) - 1\n    /// @param bits bit size of mask\n    /// @return res the mask\n    function mask(uint8 bits) internal pure returns (uint256 res) {\n        assembly {\n            res := sub(shl(bits, 1), 1)\n        }\n    }\n\n    function fullsubmask(uint8 bits, uint8 pos) internal pure returns (uint256 res) {\n        res = ~(mask(bits) << pos);\n    }\n\n    function set(\n        uint256 preStore,\n        uint8 bits,\n        uint8 pos,\n        uint256 value\n    ) internal pure returns (uint256 postStore) {\n        postStore = preStore & fullsubmask(bits, pos);\n\n        assembly {\n            value := shl(pos, value)\n        }\n\n        postStore |= value;\n    }\n\n    function get(\n        uint256 store,\n        uint8 bits,\n        uint8 pos\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := shr(pos, store)\n        }\n        value &= mask(bits);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                ARRAYS\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // function getArray(uint256 store, uint8 pos) internal pure returns (uint8[] memory arr) {\n    //     store = get(store, 64, pos);\n\n    //     arr = new uint8[](8);\n    //     for (uint256 i = 0; i < 8; i++) {\n    //         arr[i] = uint8(store & 0xff);\n    //         store >>= 8;\n    //     }\n    // }\n\n    // function setArray(\n    //     uint256 store,\n    //     uint8 pos,\n    //     uint8[] memory arr\n    // ) internal pure returns (uint256 res) {\n    //     for (uint256 i = 8; i > 0; i--) {\n    //         res |= uint256(arr[i - 1]) << ((8 * (i - 1)));\n    //     }\n\n    //     res = set(store, 64, pos, res);\n    // }\n}\n"
    },
    "src/core/NuggftV1Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {NuggftV1Proof} from './NuggftV1Proof.sol';\n\nimport {INuggftV1Migrator} from '../interfaces/nuggftv1/INuggftV1Migrator.sol';\nimport {INuggftV1Stake} from '../interfaces/nuggftv1/INuggftV1Stake.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\nimport {SafeTransferLib} from '../libraries/SafeTransferLib.sol';\n\nimport {NuggftV1StakeType} from '../types/NuggftV1StakeType.sol';\n\nabstract contract NuggftV1Stake is INuggftV1Stake, NuggftV1Proof {\n    using SafeCastLib for uint256;\n    using NuggftV1StakeType for uint256;\n\n    address public migrator;\n\n    uint256 internal stake;\n\n    uint96 constant PROTOCOL_FEE_BPS = 1000;\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc INuggftV1Stake\n    function extractProtocolEth() external requiresTrust {\n        uint256 cache = stake;\n\n        emit ProtocolEthExtracted(cache.proto());\n\n        SafeTransferLib.safeTransferETH(msg.sender, cache.proto());\n\n        stake = cache.proto(0);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function setMigrator(address _migrator) external requiresTrust {\n        migrator = _migrator;\n\n        emit MigratorV1Updated(_migrator);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                VIEW\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    /// @inheritdoc INuggftV1Stake\n    function ethPerShare() public view override returns (uint96 res) {\n        res = calculateEthPerShare(stake);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function minSharePrice() public view override returns (uint96 res) {\n        (res, , , ) = minSharePriceBreakdown(stake);\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function stakedShares() public view override returns (uint64 res) {\n        res = stake.shares();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function stakedEth() public view override returns (uint96 res) {\n        res = stake.staked();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function protocolEth() public view override returns (uint96 res) {\n        res = stake.proto();\n    }\n\n    /// @inheritdoc INuggftV1Stake\n    function totalSupply() public view override returns (uint256 res) {\n        res = stakedShares();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            ADD STAKE & SHARES\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @notice handles the adding of shares - ensures enough eth is being added\n    /// @dev this is the only way to add shares - the logic here ensures that \"ethPerShare\" can never decrease\n    function addStakedShareFromMsgValue() internal {\n        uint96 value = msg.value.safe96();\n\n        uint256 cache = stake;\n\n        (uint96 totalPrice, , uint96 protocolFee, ) = minSharePriceBreakdown(cache);\n\n        // logically unnessesary - to help front end\n        require(value >= totalPrice, 'T:1'); // \"not enough eth to create share\"\n\n        uint96 overpay = value - totalPrice;\n\n        // the rest of the value gets added to stakedEth\n        protocolFee += calculateProtocolFeeOf(overpay);\n\n        cache = cache.addShares(1);\n        cache = cache.addStaked(value - protocolFee);\n        cache = cache.addProto(protocolFee);\n\n        stake = cache;\n\n        // emit StakeEth(value - protocolFee, protocolFee);\n    }\n\n    /// @notice handles isolated staking of eth\n    /// @dev supply of eth goes up while supply of shares stays constant - increasing \"minSharePrice\"\n    /// @param eth the amount of eth being staked - must be some portion of msg.value\n    function addStakedEth(uint96 eth) internal {\n        require(msg.value >= eth, 'T:2'); // \"value of tx too low\"\n\n        uint256 cache = stake;\n\n        uint96 protocolFee = calculateProtocolFeeOf(eth);\n\n        stake = cache.staked(cache.staked() + eth - protocolFee).proto(cache.proto() + protocolFee);\n\n        // emit StakeEth(eth - protocolFee, protocolFee);\n    }\n\n    function calculateProtocolFeeOf(uint96 any) internal pure returns (uint96 res) {\n        res = (any * PROTOCOL_FEE_BPS) / 10000;\n    }\n\n    // @test manual\n    function minSharePriceBreakdown(uint256 cache)\n        internal\n        pure\n        returns (\n            uint96 total,\n            uint96 eps,\n            uint96 protocolFee,\n            uint96 premium\n        )\n    {\n        eps = calculateEthPerShare(cache);\n\n        protocolFee = calculateProtocolFeeOf(eps);\n\n        premium = ((eps * cache.shares()) / 10000);\n\n        total = eps + protocolFee + premium;\n    }\n\n    // @test manual\n    function calculateEthPerShare(uint256 cache) internal pure returns (uint96 res) {\n        res = cache.shares() == 0 ? 0 : cache.staked() / cache.shares();\n    }\n}\n"
    },
    "src/core/NuggftV1Proof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Proof} from '../interfaces/nuggftv1/INuggftV1Proof.sol';\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {NuggftV1Dotnugg} from './NuggftV1Dotnugg.sol';\n\nimport {NuggftV1ProofType} from '../types/NuggftV1ProofType.sol';\n\nabstract contract NuggftV1Proof is INuggftV1Proof, NuggftV1Dotnugg {\n    using SafeCastLib for uint160;\n    using SafeCastLib for uint256;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                state\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    struct Settings {\n        mapping(uint256 => uint256) anchorOverrides;\n        // uint8 displayLen; // default 4\n    }\n\n    mapping(uint160 => uint256) proofs;\n\n    mapping(uint160 => Settings) settings;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                           external functions\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /// @inheritdoc INuggftV1Proof\n    function rotate(\n        uint160 tokenId,\n        uint8 index0,\n        uint8 index1\n    ) external override {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.swapIndexs(working, index0, index1);\n\n        proofs[tokenId] = working;\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function anchor(\n        uint160 tokenId,\n        uint16 itemId,\n        uint256 x,\n        uint256 y\n    ) external override {\n        require(x < 64 && y < 64, 'UNTEESTED:1');\n\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        settings[tokenId].anchorOverrides[itemId] = x | (y << 6);\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function proofOf(uint160 tokenId) public view virtual override returns (uint256) {\n        if (proofs[tokenId] != 0) return proofs[tokenId];\n\n        (uint256 seed, uint256 epoch, uint256 proof) = pendingProof();\n\n        if (epoch == tokenId && seed != 0) return proof;\n        else return 0;\n    }\n\n    /// @inheritdoc INuggftV1Proof\n    function proofToDotnuggMetadata(uint160 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 proof,\n            uint8[] memory defaultIds,\n            uint8[] memory overxs,\n            uint8[] memory overys\n        )\n    {\n        proof = proofOf(tokenId);\n\n        if (proof == 0) {\n            proof = initFromSeed(tryCalculateSeed(tokenId.safe32()));\n            require(proof != 0, 'P:L');\n        }\n\n        defaultIds = new uint8[](8);\n        overxs = new uint8[](8);\n        overys = new uint8[](8);\n\n        defaultIds[0] = uint8(proof & ShiftLib.mask(3));\n\n        for (uint8 i = 0; i < 7; i++) {\n            uint16 item = NuggftV1ProofType.getIndex(proof, i);\n\n            if (item == 0) continue;\n\n            (uint8 feature, uint8 pos) = NuggftV1ProofType.parseItemId(item);\n\n            if (defaultIds[feature] == 0) {\n                uint256 overrides = settings[tokenId].anchorOverrides[item];\n                overys[feature] = uint8(overrides >> 6);\n                overxs[feature] = uint8(overrides & ShiftLib.mask(6));\n\n                defaultIds[feature] = pos;\n            }\n        }\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                             internal functions\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function exists(uint160 tokenId) internal view override returns (bool) {\n        return proofOf(tokenId) != 0;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            SWAP MANAGEMENT\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function addItem(uint160 tokenId, uint16 itemId) internal {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.setIndex(working, NuggftV1ProofType.search(working, 0), itemId);\n\n        proofs[tokenId] = working;\n    }\n\n    function removeItem(uint160 tokenId, uint16 itemId) internal {\n        ensureOperatorForOwner(msg.sender, tokenId);\n\n        uint256 working = proofOf(tokenId);\n\n        working = NuggftV1ProofType.setIndex(working, NuggftV1ProofType.search(working, itemId), 0);\n\n        proofs[tokenId] = working;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                            INITIALIZATION\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function setProof(uint160 tokenId) internal {\n        require(proofs[tokenId] == 0, 'P:5');\n\n        uint256 randomEnoughSeed = uint256(keccak256(abi.encodePacked(hex'420690', tokenId, blockhash(block.number - 1))));\n\n        uint256 res = initFromSeed(randomEnoughSeed);\n\n        proofs[tokenId] = res;\n    }\n\n    function setProofFromEpoch(uint160 tokenId) internal {\n        require(proofs[tokenId] == 0, 'P:6');\n\n        (, uint256 epoch, uint256 res) = pendingProof();\n\n        require(epoch == tokenId, 'P:7');\n\n        proofs[tokenId] = res;\n    }\n\n    // TODO TO BE TESTED\n    function initFromSeed(uint256 seed) internal view returns (uint256 res) {\n        require(seed != 0, 'P:8');\n\n        uint256 lengths = featureLengths;\n\n        res |= ((safeMod(ShiftLib.get(seed, 8, 0), _lengthOf(lengths, 0))) + 1);\n        res |= ((1 << 8) | ((safeMod(ShiftLib.get(seed, 8, 8), _lengthOf(lengths, 1))) + 1)) << 3;\n        res |= ((2 << 8) | ((safeMod(ShiftLib.get(seed, 8, 16), _lengthOf(lengths, 2))) + 1)) << (3 + 11);\n\n        uint256 selA = ShiftLib.get(seed, 8, 24);\n\n        uint256 valA = ShiftLib.get(seed, 8, 32);\n\n        uint256 selB = ShiftLib.get(seed, 8, 24);\n\n        uint256 valB = ShiftLib.get(seed, 8, 40);\n\n        if (selA < 128) valA = (3 << 8) | ((safeMod(valA, _lengthOf(lengths, 3))) + 1);\n        else valA = (4 << 8) | ((safeMod(valA, _lengthOf(lengths, 4))) + 1);\n\n        res |= (valA) << (3 + 22);\n\n        if (selB < 30) valB = (5 << 8) | ((safeMod(valB, _lengthOf(lengths, 5))) + 1);\n        else if (selB < 55) valB = (6 << 8) | ((safeMod(valB, _lengthOf(lengths, 6))) + 1);\n        else if (selB < 75) valB = (7 << 8) | ((safeMod(valB, _lengthOf(lengths, 7))) + 1);\n        else {\n            return res;\n        }\n\n        res |= (valB) << (3 + 33);\n    }\n\n    function safeMod(uint256 value, uint8 modder) internal pure returns (uint256) {\n        require(modder != 0, 'P:9');\n        return value.safe8() % modder;\n    }\n\n    function pendingProof()\n        internal\n        view\n        returns (\n            uint256 seed,\n            uint256 epoch,\n            uint256 proof\n        )\n    {\n        (seed, epoch) = calculateSeed();\n\n        proof = initFromSeed(seed);\n    }\n}\n"
    },
    "src/types/NuggftV1ProofType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ShiftLib} from '../libraries/ShiftLib.sol';\n\n/// @notice abstracts all the logic for converting the proof between a the uint256 which is stored in\n/// in state and the the 4 uint8 arrays that it consists off.\n/// @dev Explain to a developer any extra details\n/// @dev itemIds are externally 16 bits, but here there are referenced as 8 bit ids in one of 8 indexs\n/// where the id is the position the item exists in the file storage, and the index is the feature id\n/// @dev there is not check - but dotnugg v1 only allows for max 63 for size, so anchor overrides should\n/// reflect this.\n/// @dev pushing and pulling is only set up for the extra array, so the user must manage their default array\n/// by passing through the extra array - this is to reduce complexity\n/// @dev see the dotnugg specification for more clarificaiton on the values used here\n///\n///  uint256 bit allocation of proof \"state\" variable:\n/// ┌───────────┬─────────┬────────────────────────────────────┐\n/// │  0 - 63   │ 64 bits │  default item ids - 8 x 8 bits     │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 64 - 127  │ 64 bits │  extra item ids - 8 x 8 bits       │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 128 - 191 │ 64 bits │  x anchor overrides - 8 x 8 bits   │\n/// ├───────────┼─────────┼────────────────────────────────────┤\n/// │ 192 - 255 │ 64 bits │  y anchor overrides - 8 x 8 bits   │\n/// └───────────┴─────────┴────────────────────────────────────┘\n///\nlibrary NuggftV1ProofType {\n    /// @notice converts the proof state into a human readable form\n    /// @dev fully parses the proof from a uint256 to 4 uint8 arrays\n    /// @param state -> the uint256 proof state\n    /// @return proof -> the uint256 proof state\n    /// @return defaultIds -> the modifed uint256 proof state\n    /// @return extraIds -> the modifed uint256 proof state\n    /// @return xOverrides -> the modifed uint256 proof state\n    /// @return yOverrides -> the modifed uint256 proof state\n    // function fullProof(uint256 state)\n    //     internal\n    //     pure\n    //     returns (\n    //         uint256 proof,\n    //         uint8[] memory defaultIds,\n    //         uint8[] memory extraIds,\n    //         uint8[] memory xOverrides,\n    //         uint8[] memory yOverrides\n    //     )\n    // {\n    //     proof = state;\n    //     defaultIds = ShiftLib.getArray(state, 0);\n    //     extraIds = ShiftLib.getArray(state, 64);\n    //     xOverrides = ShiftLib.getArray(state, 128);\n    //     yOverrides = ShiftLib.getArray(state, 192);\n    // }\n\n    /// @notice sets an item to the extra array\n    /// @dev extra array must be empty at the feature positon being added to\n    /// @param state -> the uint256 proof state\n    /// @param itemId -> the itemId being added\n    /// @return res -> the modifed uint256 proof state\n    // function pushToExtra(uint256 state, uint16 itemId) internal pure returns (uint256 res) {\n    //     uint8[] memory arr = ShiftLib.getArray(state, 64);\n\n    //     (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n    //     require(arr[feat] == 0, 'P:D');\n\n    //     arr[feat] = pos;\n\n    //     res = ShiftLib.setArray(state, 64, arr);\n    // }\n\n    /// / @notice removes an item from the extra array\n    // / @dev extra array must NOT be empty at the feature positon being removed\n    // / @dev the extra array must have that specific feature in that postion\n    // / @param state -> the uint256 proof state\n    // / @param itemId -> the itemId being removed\n    // / @return res -> the modifed uint256 proof state\n    // function pullFromExtra(uint256 state, uint16 itemId) internal pure returns (uint256 res) {\n    //     uint8[] memory arr = ShiftLib.getArray(state, 64);\n\n    //     (uint8 feat, uint8 pos) = parseItemId(itemId);\n\n    //     require(feat != 0, 'P:F');\n\n    //     require(arr[feat] == pos, 'P:E');\n\n    //     arr[feat] = 0;\n\n    //     res = ShiftLib.setArray(state, 64, arr);\n    // }\n\n    function search(uint256 state, uint256 itemId) internal pure returns (uint8 index) {\n        state >>= 3;\n\n        do {\n            if (state & 11 == itemId) return index;\n            index++;\n        } while ((state >>= 11) != 0);\n\n        require(index != 22, 'UNTESTED');\n\n        // if (index == 22) revert('UNTESTED');\n    }\n\n    function swapIndexs(\n        uint256 state,\n        uint8 index1,\n        uint8 index2\n    ) internal pure returns (uint256 res) {\n        uint256 tmp = getIndex(state, index1);\n        res = setIndex(state, index1, getIndex(state, index2));\n        res = setIndex(state, index2, tmp);\n    }\n\n    function getIndex(uint256 state, uint8 index) internal pure returns (uint16 res) {\n        res = uint16(ShiftLib.get(state, 11, 3 + 11 * index));\n    }\n\n    function setIndex(\n        uint256 state,\n        uint8 index,\n        uint256 id\n    ) internal pure returns (uint256 res) {\n        res = ShiftLib.set(state, 11, 3 + 11 * index, id);\n    }\n\n    /// @notice updates the x and y override arrays\n    /// @dev all must be set at once\n    /// @param state -> the uint256 proof state\n    /// @param xOverrides -> uint8 array of new x overrides\n    /// @param yOverrides -> uint8 array of new x overrides\n    /// @return res -> the modifed uint256 proof state\n    // function setNewAnchorOverrides(\n    //     uint256 state,\n    //     uint8[] memory xOverrides,\n    //     uint8[] memory yOverrides\n    // ) internal pure returns (uint256 res) {\n    //     res = ShiftLib.setArray(state, 128, xOverrides);\n    //     res = ShiftLib.setArray(res, 192, yOverrides);\n    // }\n\n    /// @notice clears the anchor overrides for a specific feature\n    /// @dev this should be called each time an item is added or removed from a feature\n    /// @param state -> the uint256 proof state\n    /// @param feature -> the feature to switch items for\n    /// @return res -> the modifed uint256 proof state\n    // function clearAnchorOverridesForFeature(uint256 state, uint8 feature) internal pure returns (uint256 res) {\n    //     uint8[] memory x = ShiftLib.getArray(state, 128);\n    //     uint8[] memory y = ShiftLib.getArray(state, 192);\n\n    //     y[feature] = 0;\n    //     x[feature] = 0;\n\n    //     res = ShiftLib.setArray(state, 128, x);\n    //     res = ShiftLib.setArray(res, 192, y);\n    // }\n\n    /// @notice parses the external itemId into a feautre and position\n    /// @dev this follows dotnugg v1 specification\n    /// @param itemId -> the external itemId\n    /// @return feat -> the feautre of the item\n    /// @return pos -> the file storage position of the item\n    function parseItemId(uint16 itemId) internal pure returns (uint8 feat, uint8 pos) {\n        feat = uint8(itemId >> 8);\n        pos = uint8(itemId & 0xff);\n    }\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IDotnuggV1Storage {\n    function stored(address implementer, uint8 feature) external view returns (uint8);\n\n    function store(uint8 feature, uint256[][] calldata data) external returns (uint8 amount);\n\n    function unsafeBulkStore(uint256[][][] calldata data) external;\n}\n"
    },
    "src/interfaces/dotnuggv1/IDotnuggV1Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IDotnuggV1Metadata} from './IDotnuggV1Metadata.sol';\n\ninterface IDotnuggV1Resolver {\n    function resolveBytes(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (bytes memory res);\n\n    function resolveRaw(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (uint256[] memory res);\n\n    function resolveMetadata(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (IDotnuggV1Metadata.Memory memory res);\n\n    function resolveString(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n\n    function resolveUri(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8 zoom\n    ) external view returns (string memory res);\n}\n"
    },
    "src/core/NuggftV1Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IERC721} from '../interfaces/IERC721.sol';\n\nimport {INuggftV1Token} from '../interfaces/nuggftv1/INuggftV1Token.sol';\n\nimport {SafeCastLib} from '../libraries/SafeCastLib.sol';\n\nimport {NuggftV1Epoch} from './NuggftV1Epoch.sol';\n\n///\n/// @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard\n///\nabstract contract NuggftV1Token is INuggftV1Token, NuggftV1Epoch {\n    using SafeCastLib for uint256;\n\n    uint32 constant TRUSTED_MINT_TOKENS = 500;\n    uint32 constant UNTRUSTED_MINT_TOKENS = 10000;\n\n    mapping(uint256 => address) owners;\n    // mapping(address => uint256) balances;\n    mapping(uint256 => address) approvals;\n    mapping(address => mapping(address => bool)) operatorApprovals;\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) public payable override {\n        address owner = _ownerOf(tokenId.safe160());\n\n        require(_isOperatorFor(msg.sender, owner), 'G:1');\n\n        approvals[tokenId] = to;\n\n        emit Approval(owner, to, tokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) public override {\n        // require(msg.sender != operator && operator == address(this), 'G:0');\n\n        operatorApprovals[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        return _ownerOf(tokenId.safe160());\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) external view override returns (address) {\n        return _getApproved(tokenId.safe160());\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view override returns (bool) {\n        return _isOperatorFor(operator, owner);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                DISABLED\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function balanceOf(address) public pure override returns (uint256) {\n        return 0;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public payable override {\n        revert();\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256\n    ) public payable override {\n        revert();\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public payable override {\n        revert();\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                internal\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function _mintTo(address to, uint160 tokenId) internal {\n        owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                view\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function exists(uint160 tokenId) internal view virtual returns (bool);\n\n    function _isOperatorFor(address operator, address owner) internal view returns (bool) {\n        return owner == operator || operatorApprovals[owner][operator];\n    }\n\n    function _isOperatorForOwner(address operator, uint160 tokenId) internal view returns (bool) {\n        return _isOperatorFor(operator, _ownerOf(tokenId));\n    }\n\n    function ensureOperatorForOwner(address operator, uint160 tokenId) internal view returns (address owner) {\n        owner = _ownerOf(tokenId);\n        require(_isOperatorFor(operator, owner), 'P:B');\n    }\n\n    function _getApproved(uint160 tokenId) internal view returns (address) {\n        require(exists(tokenId), 'T:9:1');\n        return approvals[tokenId];\n    }\n\n    function _ownerOf(uint160 tokenId) internal view returns (address owner) {\n        require(exists(tokenId), 'T:9:2');\n        owner = owners[tokenId];\n        if (owner == address(0)) return address(this);\n    }\n\n    function _isApprovedOrOwner(address spender, uint160 tokenId) internal view returns (bool) {\n        address owner = _ownerOf(tokenId);\n        return (spender == owner || _getApproved(tokenId) == spender || _isOperatorFor(owner, spender));\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRANSFER\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function checkedTransferFromSelf(address to, uint160 tokenId) internal {\n        require(_ownerOf(tokenId) == address(this), 'N:0');\n\n        owners[tokenId] = to;\n\n        emitTransferEvent(address(this), to, tokenId);\n    }\n\n    function approvedTransferToSelf(uint160 tokenId) internal {\n        require(_isOperatorForOwner(msg.sender, tokenId) && _getApproved(tokenId) == address(this), 'N:1');\n\n        delete owners[tokenId];\n\n        // Clear approvals from the previous owner\n        delete approvals[tokenId];\n\n        emitTransferEvent(msg.sender, address(this), tokenId);\n    }\n\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint160 tokenId\n    ) internal {\n        emit Transfer(from, to, tokenId);\n    }\n}\n"
    },
    "src/core/NuggftV1Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Epoch} from '../interfaces/nuggftv1/INuggftV1Epoch.sol';\n\nabstract contract NuggftV1Epoch is INuggftV1Epoch {\n    uint256 public immutable genesis;\n\n    uint32 constant INTERVAL = 69;\n    uint32 constant OFFSET = 3000;\n\n    constructor() {\n        genesis = block.number;\n        emit Genesis(block.number, INTERVAL, OFFSET);\n    }\n\n    /// @inheritdoc INuggftV1Epoch\n    function epoch() public view override returns (uint32 res) {\n        res = toEpoch(block.number);\n    }\n\n    function toStartBlock(uint32 _epoch) internal view returns (uint256 res) {\n        res = ((_epoch - OFFSET) * INTERVAL) + genesis;\n    }\n\n    function toEpoch(uint256 blocknum) internal view returns (uint32 res) {\n        res = (uint32(blocknum - genesis) / INTERVAL) + OFFSET;\n    }\n\n    function toEndBlock(uint32 _epoch) internal view returns (uint256 res) {\n        res = toStartBlock(_epoch + 1) - 1;\n    }\n\n    function calculateSeed() internal view returns (uint256 res, uint32 _epoch) {\n        _epoch = epoch();\n        res = calculateSeedCore(_epoch);\n    }\n\n    function tryCalculateSeed(uint32 _epoch) internal view returns (uint256 res) {\n        res = calculateSeedCore(_epoch);\n    }\n\n    /// @notice gets unique base based on given epoch and converts encoded bytes to object that can be merged\n    /// Note: by using the block hash no one knows what a nugg will look like before it's epoch.\n    /// We considered making this harder to manipulate, but we decided that if someone were able to\n    /// pull it off and make their own custom nugg, that would be really fucking cool.\n    function calculateSeedCore(uint32 _epoch) internal view returns (uint256 res) {\n        uint256 startblock = toStartBlock(_epoch);\n        bytes32 bhash = blockhash(startblock - 2);\n        require(bhash != 0, 'E:0');\n        res = uint256(keccak256(abi.encodePacked(bhash, _epoch, address(this))));\n    }\n}\n"
    },
    "src/interfaces/ITrust.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITrust {\n    event TrustUpdated(address indexed user, bool trust);\n\n    function setIsTrusted(address user, bool trust) external;\n\n    function isTrusted(address user) external view returns (bool);\n}\n"
    },
    "src/_test/mock/MockNuggftV1Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {INuggftV1Migrator} from '../../interfaces/nuggftv1/INuggftV1Migrator.sol';\n\ncontract MockNuggftV1Migrator is INuggftV1Migrator {\n    function nuggftMigrateFromV1(\n        uint160 tokenId,\n        uint256 proof,\n        address owner\n    ) external payable override {\n        emit MigrateV1Accepted(msg.sender, tokenId, proof, owner, uint96(msg.value));\n    }\n}\n"
    },
    "src/_test/NuggftV1.test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTestPlus as t} from './utils/DSTestPlus.sol';\n\nimport './utils/User.sol';\n\nimport {MockDotnuggV1} from './mock/MockDotnuggV1.sol';\n\nimport {MockNuggftV1Migrator} from './mock/MockNuggftV1Migrator.sol';\n\nimport {NuggftV1} from '../NuggftV1.sol';\n\nimport './utils/logger.sol';\n\ncontract RiggedNuggft is NuggftV1 {\n    constructor(address processor) NuggftV1(processor) {\n        featureLengths = 0x0303030303030303;\n    }\n}\n\nlibrary SafeCast {\n    function safeInt(uint96 input) internal pure returns (int192) {\n        return (int192(int256(uint256(input))));\n    }\n}\n\ncontract NuggftV1Test is t {\n    using SafeCast for uint96;\n    using SafeCast for uint256;\n    using SafeCast for uint64;\n\n    using UserTarget for address;\n\n    MockDotnuggV1 public processor;\n\n    MockNuggftV1Migrator public migrator;\n\n    RiggedNuggft public nuggft;\n\n    address public _nuggft;\n\n    User public safe;\n\n    User public frank;\n    User public charlie;\n    User public dennis;\n    User public mac;\n    User public dee;\n\n    User public any;\n\n    constructor() {}\n\n    function reset() public {\n        fvm.roll(1);\n        fvm.roll(2);\n        processor = new MockDotnuggV1();\n        migrator = new MockNuggftV1Migrator();\n        nuggft = new RiggedNuggft(address(processor));\n        _nuggft = address(nuggft);\n        safe = new User();\n\n        frank = new User();\n        charlie = new User();\n        dennis = new User();\n        mac = new User();\n        dee = new User();\n\n        any = new User();\n\n        safeDeal(address(safe), 30 ether);\n        safeDeal(address(dennis), 30 ether);\n        safeDeal(address(mac), 30 ether);\n        safeDeal(address(dee), 30 ether);\n        safeDeal(address(frank), 90000 ether);\n        safeDeal(address(charlie), 30 ether);\n\n        nuggft.setIsTrusted(address(safe), true);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                eth modifiers\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    struct ChangeCheck {\n        int192 before_staked;\n        int192 before_protocol;\n        int192 before_shares;\n        int192 before_minSharePrice;\n        int192 before_eps;\n        //\n        int192 after_staked;\n        int192 after_protocol;\n        int192 after_shares;\n        int192 after_minSharePrice;\n        int192 after_eps;\n    }\n\n    modifier changeInStaked(int192 change, int192 shareChange) {\n        ChangeCheck memory str;\n        str.before_staked = nuggft.stakedEth().safeInt();\n        str.before_protocol = nuggft.protocolEth().safeInt();\n        str.before_shares = nuggft.stakedShares().safeInt();\n        str.before_minSharePrice = nuggft.minSharePrice().safeInt();\n\n        str.before_eps = nuggft.ethPerShare().safeInt();\n\n        assertEq(\n            str.before_eps,\n            str.before_shares > 0 ? str.before_staked / str.before_shares : int256(0),\n            'EPS is starting off with an incorrect value'\n        );\n\n        _;\n        str.after_staked = nuggft.stakedEth().safeInt();\n        str.after_protocol = nuggft.protocolEth().safeInt();\n        str.after_shares = nuggft.stakedShares().safeInt();\n        str.after_minSharePrice = nuggft.minSharePrice().safeInt();\n\n        assertTrue(str.after_minSharePrice >= str.before_minSharePrice, 'minSharePrice is did not increase as expected');\n        assertEq(str.after_protocol - str.before_protocol, take(10, change), 'totalProtocol is not what is expected');\n        assertEq(str.after_staked - str.before_staked, change - take(10, change), 'staked change is not 90 percent of expected change');\n        assertEq(str.after_shares - str.before_shares, shareChange, 'shares difference is not what is expected');\n\n        str.after_eps = nuggft.ethPerShare().safeInt();\n        assertEq(\n            str.after_eps,\n            str.after_shares > 0 ? str.after_staked / str.after_shares : int256(0),\n            'EPS is not ending with correct value'\n        );\n    }\n\n    modifier changeInUserBalance(User user, int192 change) {\n        ChangeCheck memory str;\n\n        str.before_staked = int192(int256(uint256(address(user).balance)));\n        _;\n        str.after_staked = int192(int256(uint256(address(user).balance)));\n\n        assertEq(str.after_staked - str.before_staked, change, 'user balance did not change');\n    }\n\n    modifier changeInNuggftBalance(int192 change) {\n        ChangeCheck memory str;\n\n        str.before_staked = int192(int256(uint256(address(nuggft).balance)));\n        _;\n        str.after_staked = int192(int256(uint256(address(nuggft).balance)));\n\n        assertEq(str.after_staked - str.before_staked, change, 'nuggft balance did not change');\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                encodeWithSelector\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function delegate(address sender, uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.delegate.selector, sender, tokenId);\n    }\n\n    function delegateItem(\n        uint256 buyerTokenId,\n        uint256 sellerTokenId,\n        uint256 itemId\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.delegateItem.selector, buyerTokenId, sellerTokenId, itemId);\n    }\n\n    function claim(address sender, uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.claim.selector, sender, tokenId);\n    }\n\n    function swap(uint256 tokenId, uint96 floor) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.swap.selector, tokenId, floor);\n    }\n\n    function loan(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.loan.selector, tokenId);\n    }\n\n    function payoff(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.payoff.selector, tokenId);\n    }\n\n    function rebalance(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.rebalance.selector, tokenId);\n    }\n\n    function loanInfo(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.loanInfo.selector, tokenId);\n    }\n\n    function swapItem(\n        uint256 tokenId,\n        uint256 itemId,\n        uint96 floor\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.swapItem.selector, tokenId, itemId, floor);\n    }\n\n    function claimItem(\n        uint256 buyerTokenId,\n        uint256 sellerTokenId,\n        uint256 itemId\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.claimItem.selector, buyerTokenId, sellerTokenId, itemId);\n    }\n\n    function rotate(\n        uint256 tokenId,\n        uint8 index0,\n        uint8 index1\n    ) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.rotate.selector, tokenId, index0, index1);\n    }\n\n    function burn(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.burn.selector, tokenId);\n    }\n\n    function migrate(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.migrate.selector, tokenId);\n    }\n\n    function setMigrator(address _migrator) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.setMigrator.selector, _migrator);\n    }\n\n    function approve(address addr, uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.approve.selector, addr, tokenId);\n    }\n\n    function setApprovalForAll(address addr, bool appr) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.setApprovalForAll.selector, addr, appr);\n    }\n\n    function mint(uint256 tokenId) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.mint.selector, tokenId);\n    }\n\n    function trustedMint(uint256 tokenId, address to) public view returns (bytes memory res) {\n        return abi.encodeWithSelector(nuggft.trustedMint.selector, tokenId, to);\n    }\n\n    function take(int256 percent, int256 value) internal pure returns (int256) {\n        return (value * percent) / 100;\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                scenarios\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    function scenario_dee_has_a_token() public payable returns (uint160 tokenId) {\n        tokenId = 2069;\n        _nuggft.shouldPass(dee, mint(tokenId));\n    }\n\n    function scenario_frank_has_a_token_and_spent_50_eth() public payable returns (uint160 tokenId) {\n        tokenId = 2012;\n        _nuggft.shouldPass(frank, mint(tokenId), 50 ether);\n    }\n\n    function scenario_frank_has_a_loaned_token() public payable returns (uint160 tokenId) {\n        scenario_charlie_has_a_token();\n\n        tokenId = scenario_frank_has_a_token_and_spent_50_eth();\n\n        {\n            _nuggft.shouldPass(frank, approve(address(nuggft), tokenId));\n        }\n\n        _nuggft.shouldPass(frank, loan(tokenId));\n    }\n\n    function scenario_frank_has_a_loaned_token_that_has_expired() public payable returns (uint160 tokenId) {\n        tokenId = scenario_frank_has_a_loaned_token();\n\n        fvm.roll(200000);\n    }\n\n    function scenario_dee_has_a_token_2() public payable returns (uint160 tokenId) {\n        tokenId = 2400;\n        _nuggft.shouldPass(dee, mint(tokenId));\n    }\n\n    function scenario_charlie_has_a_token() public payable returns (uint160 tokenId) {\n        tokenId = 2070;\n        _nuggft.shouldPass(charlie, mint(tokenId));\n    }\n\n    function scenario_migrator_set() public payable {\n        _nuggft.shouldPass(safe, setMigrator(address(migrator)));\n    }\n\n    function scenario_dee_has_a_token_and_can_swap() public payable returns (uint160 tokenId) {\n        tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n    }\n\n    function scenario_dee_has_swapped_a_token() public payable returns (uint160 tokenId, uint96 floor) {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        floor = 1 ether;\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor));\n    }\n\n    function scenario_dee_has_swapped_a_token_and_mac_has_delegated() public payable returns (uint160 tokenId, uint96 eth) {\n        (tokenId, ) = scenario_dee_has_swapped_a_token();\n\n        eth = 2 ether;\n\n        _nuggft.shouldPass(mac, delegate(address(mac), tokenId), eth);\n    }\n\n    function scenario_dee_has_swapped_a_token_and_mac_can_claim() public payable returns (uint160 tokenId) {\n        (tokenId, ) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        fvm.roll(2000);\n    }\n\n    function scenario_mac_has_claimed_a_token_dee_swapped() public payable returns (uint160 tokenId) {\n        (tokenId) = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        _nuggft.shouldPass(mac, claim(address(mac), tokenId));\n    }\n\n    function scenario_mac_has_swapped_a_token_dee_swapped() public payable returns (uint160 tokenId, uint96 floor) {\n        (tokenId) = scenario_mac_has_claimed_a_token_dee_swapped();\n        floor = 3 ether;\n\n        _nuggft.shouldPass(mac, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(mac, swap(tokenId, floor));\n    }\n\n    function scenario_dee_has_a_token_and_can_swap_an_item()\n        public\n        payable\n        returns (\n            uint160 tokenId,\n            uint16 itemId,\n            uint8 feature\n        )\n    {\n        (tokenId) = scenario_dee_has_a_token();\n\n        (, uint8[] memory items, , ) = nuggft.proofToDotnuggMetadata(tokenId);\n\n        feature = 1;\n        itemId = items[feature] | (uint16(feature) << 8);\n\n        // _nuggft.shouldPass(dee, rotate(tokenId, feature));\n    }\n\n    function scenario_dee_has_swapped_an_item()\n        public\n        payable\n        returns (\n            uint160 tokenId,\n            uint8 feature,\n            uint16 itemId,\n            uint96 floor\n        )\n    {\n        (tokenId, itemId, feature) = scenario_dee_has_a_token_and_can_swap_an_item();\n        floor = 3 ether;\n\n        _nuggft.shouldPass(dee, swapItem(tokenId, itemId, floor));\n    }\n\n    function scenario_dee_has_swapped_an_item_and_charlie_can_claim()\n        public\n        payable\n        returns (\n            uint160 charliesTokenId,\n            uint160 tokenId,\n            uint16 itemId\n        )\n    {\n        uint256 feature;\n        uint96 floor;\n        (tokenId, feature, itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n\n        fvm.roll(2000);\n    }\n\n    /*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                scenarios\n    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/\n\n    // function environment() public returns (address[] memory users) {\n    //     users = new address[](2000);\n\n    //     User start = new User{value: 69 ether}();\n    //     uint160 count = 501;\n\n    //                 fvm.deal(address(start), 69 ether);\n\n    //     nuggft_call(start, mint(count++), .01 ether);\n    //     nuggft_call(start, mint(count++), nuggft.minSharePrice());\n    //     nuggft_call(start, mint(count++), nuggft.minSharePrice());\n\n    //     users[0] = address(start);\n\n    //     for (uint256 i = 1; i < users.length; i++) {\n    //         User tmp = new User{value: 69 ether}();\n\n    //         fvm.deal(address(tmp), 69 ether);\n\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n    //         nuggft_call(tmp, mint(count++), nuggft.minSharePrice());\n\n    //         users[i] = address(tmp);\n    //     }\n\n    // }\n\n    function environmentForge() public returns (address[] memory users) {\n        users = new address[](9500);\n\n        User start = new User{value: 1000000000 ether}();\n        uint160 count = 501;\n\n        //   fvm.deal(address(start), 10000 *10**18);\n\n        _nuggft.shouldPass(start, mint(count++), .08 ether);\n\n        users[0] = address(start);\n\n        int256 last = 0;\n        int256 lastDiff = 0;\n\n        for (uint256 i = 1; i < users.length; i++) {\n            // User tmp = new User{value: 100000000 ether}();\n\n            // fvm.deal(address(tmp), 10000 *10**18);\n\n            _nuggft.shouldPass(start, mint(count++), nuggft.minSharePrice());\n\n            int256 curr = nuggft.minSharePrice().safeInt();\n\n            users[i] = address(start);\n\n            int256 diff = curr - last;\n            emit log_named_int('diff', curr - last);\n            emit log_named_int('ldif', diff - lastDiff);\n\n            emit log_named_uint('nuggft.ethPerShare()', nuggft.ethPerShare());\n            // emit log_named_uint('nuggft.protocolEth()', nuggft.protocolEth());\n            // emit log_named_uint('nuggft.stakedEth()', nuggft.stakedEth());\n            emit log_named_uint('nuggft.stakedShares()', nuggft.stakedShares());\n            emit log_named_uint('nuggft.minSharePrice()', nuggft.minSharePrice());\n\n            emit log_string('--------');\n\n            last = curr;\n            lastDiff = diff;\n        }\n    }\n\n    function environmentForge2() public returns (address[] memory users) {\n        users = environmentForge();\n\n        uint256 bn = 5000;\n\n        // for (uint256 i = 0; i < 10000; i++) {\n        //     uint256 epoch = nuggft.epoch();\n\n        //     uint256 funner = uint256(keccak256(abi.encodePacked(epoch))) % 100;\n\n        //     nuggft_call(User(payable(users[funner])), delegate(users[funner], epoch), nuggft.minSharePrice());\n\n        //     fvm.roll(bn);\n\n        //     bn += 70;\n\n        //     nuggft_call(User(payable(users[funner])), claim(users[funner], epoch));\n        // }\n\n        assert(false);\n    }\n}\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 36422938319266817\n//   nuggft.protocolEth(): 13721927850988207037\n//   nuggft.stakedEth(): 254960568234867720007\n//   nuggft.stakedShares(): 7000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .220269870602728762\n//   nuggft.protocolEth(): 105.652900187038601090\n//   nuggft.stakedEth(): 3524.317929643660202576\n//   nuggft.stakedShares(): 16000\n\n// Success: test__system1()\n// *10\n//   users length: 2000\n//   nuggft.ethPerShare():  .081046931383505748\n//   nuggft.protocolEth(): 36.036371675422002761\n//   nuggft.stakedEth():  891.516245218563229016\n//   nuggft.stakedShares(): 11000\n\n//   users length: 2000\n//   nuggft.ethPerShare():   .009923420616251655\n//   nuggft.protocolEth():  10.797105517187750828\n//   nuggft.stakedEth():   109.157626778768205405\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .023820112972809680\n//   nuggft.protocolEth(): 23.605706549631210195\n//   nuggft.stakedEth(): 262.021242700906482643\n//   nuggft.stakedShares(): 11000\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 22283800801842573\n//   nuggft.protocolEth(): 12045486919914902312\n//   nuggft.stakedEth(): 133702804811055442627\n//   nuggft.stakedShares(): 6000\n\n//   users length: 2000\n//   nuggft.ethPerShare(): 1.124042581556443270\n//   nuggft.protocolEth(): 658.232592803322633239\n//   nuggft.stakedEth(): 7306.276780116881258328\n//   nuggft.stakedShares(): 6500\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .179846813049030914\n//   nuggft.protocolEth(): 105317214848531614175\n//   nuggft.stakedEth(): 1169004284818700946598\n//   nuggft.stakedShares(): 6500\n\n// .092595956292375926\n\n// .101719406217199627\n\n// Success: test__system1()\n\n//   users length: 2000\n//   nuggft.ethPerShare(): .178270406414740660\n//   nuggft.protocolEth(): 96363895359319273644\n//   nuggft.stakedEth(): 1069622438488443964472\n//   nuggft.stakedShares(): 6000\n\n// Success: test__system1()\n\n//   users length: 1000\n//   nuggft.ethPerShare():   1.425741271002990526\n//   nuggft.protocolEth():  305.518843786355111578\n//   nuggft.stakedEth():   4277.223813008971579744\n//   nuggft.stakedShares(): 3000\n"
    },
    "src/_test/utils/DSTestPlus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {DSTest} from '../../../lib/ds-test/src/test.sol';\n\nimport {Hevm, ForgeVm} from './Vm.sol';\n\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    bytes32 checkpointLabel;\n    uint256 private checkpointGasLeft;\n\n    function startMeasuringGas(bytes32 label) internal virtual {\n        checkpointLabel = label;\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        bytes32 label = checkpointLabel;\n\n        emit log_named_uint(string(abi.encodePacked(label, ' Gas')), checkpointGasLeft - checkpointGasLeft2 - 22134);\n    }\n\n    function fail(bytes32 err) internal virtual {\n        emit log_named_string('Error', string(abi.encodePacked(err)));\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log('Error: a == b not satisfied [bytes]');\n            emit log_named_bytes('  Expected', b);\n            emit log_named_bytes('    Actual', a);\n            fail();\n        }\n    }\n\n    function safeDeal(address user, uint256 amount) internal {\n        if (detectDeal(user, amount)) {\n            fvm.deal(user, amount);\n            return;\n        }\n\n        bool callStatus;\n        assembly {\n            callStatus := call(gas(), user, amount, 0, 0, 0, 0)\n        }\n        assert(callStatus);\n    }\n\n    function detectDeal(address _to, uint256 _amount) public returns (bool) {\n        bool success;\n        bytes memory data = abi.encodeWithSelector(fvm.deal.selector, _to, _amount);\n        address _fvm = address(fvm);\n        assembly {\n            success := call(\n                gas(), // gas remaining\n                _fvm, // destination address\n                0, // no ether\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(data), // input length (loaded from the first 32 bytes in the `data` array)\n                0, // output buffer\n                0 // output length\n            )\n        }\n\n        return success;\n    }\n}\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, 'NO_TARGET_CONTRACTS');\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"
    },
    "src/_test/mock/MockDotnuggV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../../interfaces/dotnuggv1/IDotnuggV1.sol';\nimport '../../interfaces/dotnuggv1/IDotnuggV1Metadata.sol';\nimport '../../interfaces/dotnuggv1/IDotnuggV1Implementer.sol';\n\nimport {SafeCastLib} from '../../libraries/SafeCastLib.sol';\n\nimport '../utils/logger.sol';\n\n\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1;\n\n    function write(bytes memory data) internal returns (address pointer) {\n        bytes memory runtimeCode = abi.encodePacked(hex'00', data);\n\n        bytes memory creationCode = abi.encodePacked(hex'63', uint32(runtimeCode.length), hex'80_60_0E_60_00_39_60_00_F3', runtimeCode);\n\n        assembly {\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), 'DEPLOYMENT_FAILED');\n    }\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, 'OUT_OF_BOUNDS');\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(add(size, add(start, 0x20)), 0x1f), not(0x1f))))\n            mstore(data, size)\n            extcodecopy(pointer, add(data, 0x20), start, size)\n        }\n    }\n}\n\nabstract contract DotnuggV1Storage is IDotnuggV1Storage {\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint16;\n\n    // Mapping from token ID to owner address\n    mapping(address => mapping(uint8 => uint168[])) sstore2Pointers;\n    mapping(address => mapping(uint8 => uint8)) featureLengths;\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                TRUSTED\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function unsafeBulkStore(uint256[][][] calldata data) external override {}\n\n    function store(uint8 feature, uint256[][] calldata data) external override returns (uint8 res) {\n        uint8 len = data.length.safe8();\n\n        require(len > 0, 'F:0');\n\n        address ptr = SSTORE2.write(abi.encode(data));\n\n        sstore2Pointers[msg.sender][feature].push(uint168(uint160(ptr)) | (uint168(len) << 160));\n\n        featureLengths[msg.sender][feature] += len;\n\n        return len;\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                                 GET FILES\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function getBatchFiles(address implementer, uint8[] memory ids) internal view returns (uint256[][] memory data) {\n        data = new uint256[][](ids.length);\n\n        for (uint8 i = 0; i < ids.length; i++) {\n            if (ids[i] == 0) data[i] = new uint256[](0);\n            else data[i] = get(implementer, i, ids[i]);\n        }\n    }\n\n    function get(\n        address implementer,\n        uint8 feature,\n        uint8 pos\n    ) internal view returns (uint256[] memory data) {\n        require(pos != 0, 'F:1');\n\n        pos--;\n\n        uint8 totalLength = featureLengths[implementer][feature];\n\n        require(pos < totalLength, 'F:2');\n\n        uint168[] memory ptrs = sstore2Pointers[implementer][feature];\n\n        address str;\n        uint8 storePos;\n\n        uint8 workingPos;\n\n        for (uint256 i = 0; i < ptrs.length; i++) {\n            uint8 here = uint8(ptrs[i] >> 160);\n            if (workingPos + here > pos) {\n                str = address(uint160(ptrs[i]));\n                storePos = pos - workingPos;\n                break;\n            } else {\n                workingPos += here;\n            }\n        }\n\n        require(str != address(0), 'F:3');\n\n        data = abi.decode(SSTORE2.read(str), (uint256[][]))[storePos];\n    }\n}\n\ncontract MockDotnuggV1 is IDotnuggV1, DotnuggV1Storage {\n    function process(\n        address implementer,\n        uint256 tokenId,\n        uint8 width\n    ) public view override returns (uint256[] memory resp, IDotnuggV1Metadata.Memory memory dat) {\n        IDotnuggV1Metadata.Memory memory data = IDotnuggV1Implementer(implementer).dotnuggV1Callback(tokenId);\n        uint256[][] memory files = getBatchFiles(implementer, data.ids);\n        resp = processCore(files, data, width);\n        dat = data;\n    }\n\n    function stored(address implementer, uint8 feature) public view override returns (uint8 res) {\n        return featureLengths[implementer][feature];\n    }\n\n    function processCore(\n        uint256[][] memory files,\n        IDotnuggV1Metadata.Memory memory,\n        uint8 width\n    ) public view returns (uint256[] memory file) {\n        logger.log(width, 'width');\n\n        for (uint256 i = 0; i < files.length; i++) {\n            logger.log(files[i], 'files[i]');\n        }\n        return files[0];\n    }\n\n    function resolveBytes(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory,\n        uint8\n    ) public pure override returns (bytes memory res) {\n        res = abi.encode(file);\n    }\n\n    function resolveMetadata(\n        uint256[] memory,\n        IDotnuggV1Metadata.Memory memory data,\n        uint8\n    ) public pure override returns (IDotnuggV1Metadata.Memory memory res) {\n        res = data;\n    }\n\n    function resolveString(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory,\n        uint8\n    ) public pure override returns (string memory res) {\n        res = string(abi.encode(file));\n    }\n\n    function resolveUri(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory,\n        uint8\n    ) public pure override returns (string memory res) {\n        res = string(abi.encode(file));\n    }\n\n    function resolveRaw(\n        uint256[] memory file,\n        IDotnuggV1Metadata.Memory memory,\n        uint8\n    ) public pure override returns (uint256[] memory res) {\n        res = file;\n    }\n\n    function dotnuggToRaw(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (address resolvedBy, uint256[] memory res) {\n        (uint256[] memory file, IDotnuggV1Metadata.Memory memory data) = process(implementer, tokenId, width);\n\n        if (resolver != address(0)) {\n            res = IDotnuggV1(resolver).resolveRaw(res, data, zoom);\n        } else {\n            res = file;\n        }\n    }\n\n    function dotnuggToBytes(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (address resolvedBy, bytes memory res) {\n        (uint256[] memory file, IDotnuggV1Metadata.Memory memory data) = process(implementer, tokenId, width);\n\n        res = IDotnuggV1(resolver).resolveBytes(file, data, zoom);\n    }\n\n    function dotnuggToString(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (address resolvedBy, string memory res) {\n        (uint256[] memory file, IDotnuggV1Metadata.Memory memory data) = process(implementer, tokenId, width);\n\n        res = IDotnuggV1(resolver).resolveString(file, data, zoom);\n    }\n\n    function dotnuggToUri(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (address resolvedBy, string memory res) {\n        (uint256[] memory file, IDotnuggV1Metadata.Memory memory data) = process(implementer, tokenId, width);\n\n        res = IDotnuggV1(resolver).resolveString(file, data, zoom);\n    }\n\n    function dotnuggToMetadata(\n        address implementer,\n        uint256 tokenId,\n        address resolver,\n        uint8 width,\n        uint8 zoom\n    ) public view override returns (address resolvedBy, IDotnuggV1Metadata.Memory memory res) {\n        (uint256[] memory file, IDotnuggV1Metadata.Memory memory data) = process(implementer, tokenId, width);\n\n        res = IDotnuggV1(resolver).resolveMetadata(file, data, zoom);\n    }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "src/_test/utils/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface Hevm {\n    function warp(uint256) external;\n\n    function roll(uint256) external;\n\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    function load(address, bytes32) external returns (bytes32);\n\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    function addr(uint256) external returns (address);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n}\n\ninterface ForgeVm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n\n    // Loads a storage slot from an address (who, slot)\n    function load(address, bytes32) external returns (bytes32);\n\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    // Signs data, (privateKey, digest) => (r, v, s)\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    // Calls another contract with a specified `msg.sender`, (newSender, contract, input) => (success, returnData)\n    function prank(\n        address,\n        address,\n        bytes calldata\n    ) external payable returns (bool, bytes memory);\n\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n}\n"
    },
    "src/_test/reverts/swap.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../NuggftV1.test.sol';\n\ncontract revertTest__swap is NuggftV1Test {\n    using SafeCast for uint96;\n\n    using UserTarget for address;\n\n    uint32 epoch;\n\n    uint160 tokenId;\n    uint96 floor;\n    uint16 itemId;\n\n    uint96 eth;\n\n    uint160 charliesTokenId;\n\n    uint96 MIN = 10**13 * 50;\n\n    int96 MININT = int96(int256(uint256(MIN)));\n\n    function setUp() public {\n        reset();\n        fvm.roll(57);\n\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:0] - delegate - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_0__successAsSelf() public {\n\n        _nuggft.shouldPass(frank, delegate(address(frank), epoch), 30 * 10**16);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_0__successAsOperator() public {\n        _nuggft.shouldPass(frank, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldPass(dennis, delegate(address(frank), epoch), 30 * 10**16);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_0__failAsNotOperator() public {\n        _nuggft.shouldFail('S:0', dennis, delegate(address(frank), epoch), 30 * 10**16);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:1] - delegate - \"msg.value >= minimum offer\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_1__successWithExactMinOffer()\n        public\n        changeInUserBalance(frank, -1 * MININT)\n        changeInNuggftBalance(MININT)\n        changeInStaked(MININT, 1)\n    {\n        _nuggft.shouldPass(frank, delegate(address(frank), epoch), MIN);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_1__successWithHigherMinOffer()\n        public\n        changeInUserBalance(frank, -1 * (MININT + 1))\n        changeInNuggftBalance(MININT + 1)\n        changeInStaked(MININT + 1, 1)\n    {\n        _nuggft.shouldPass(frank, delegate(address(frank), epoch), MIN + 1);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_1__failWithOneWeiLessThanMin() public {\n        _nuggft.shouldFail('S:1', frank, delegate(address(frank), epoch), MIN - 1);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_1__failWithZero() public {\n        _nuggft.shouldFail('S:1', frank, delegate(address(frank), epoch), 0);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:3a] - delegate - \"if commiting, offerer should not be owner of swap\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_R__successWithNotOwner() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        wrap__revert__swap__S_R__successWithNotOwner();\n    }\n\n    function wrap__revert__swap__S_R__successWithNotOwner()\n        internal\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInNuggftBalance(floor.safeInt() + 1 ether)\n        changeInStaked(1 ether, 0)\n    {\n        _nuggft.shouldPass(frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_R__successWithOwnerAfterSomeoneElseDelegates() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        wrap__revert__swap__S_R__successWithOwnerAfterSomeoneElseDelegates();\n    }\n\n    function wrap__revert__swap__S_R__successWithOwnerAfterSomeoneElseDelegates()\n        public\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInUserBalance(dee, -1 * (floor.safeInt() + 1 ether * 2))\n        changeInNuggftBalance(3 ether + floor.safeInt() * 2)\n        changeInStaked(3 ether, 0)\n    {\n        _nuggft.shouldPass(frank, delegate(address(frank), tokenId), floor + 1 ether);\n\n        _nuggft.shouldPass(dee, delegate(address(dee), tokenId), floor + 2 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_R__failWithOwnerOnCommit() public {\n        (tokenId, floor) = scenario_dee_has_swapped_a_token();\n\n        _nuggft.shouldFail('S:R', dee, delegate(address(dee), tokenId), floor + 1 ether * 2);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:3b] - delegate - \"if not minting, offerer must claim previous offers for the specific token\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_R__successWithUserWithNoPrevClaim() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        wrap__revert__swap__S_R__successWithUserWithNoPrevClaim();\n    }\n\n    function wrap__revert__swap__S_R__successWithUserWithNoPrevClaim()\n        internal\n        changeInUserBalance(frank, -1 * (floor.safeInt() + 1 ether))\n        changeInNuggftBalance(floor.safeInt() + 1 ether)\n        changeInStaked(1 ether, 0)\n    {\n        _nuggft.shouldPass(frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    // LOL - MASSIVE bug found with this test\n    function test__revert__swap__S_R__successWithPrevClaimUserAfterClaiming() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(dee, claim(address(dee), tokenId));\n\n        _nuggft.shouldPass(dee, delegate(address(dee), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_R__failWtihUserWithPrevClaim() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldFail('S:R', dee, delegate(address(dee), tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:4] - delegate - \"if not minting, swap data must exist\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_4__failWithNoSwap() public {\n        tokenId = scenario_mac_has_claimed_a_token_dee_swapped();\n\n        _nuggft.shouldFail('S:4', frank, delegate(address(frank), tokenId), 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_4__failWithNonexistantToken() public {\n        _nuggft.shouldFail('S:4', frank, delegate(address(frank), 50000), 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_4__successWithSwap() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(dee, claim(address(dee), tokenId));\n\n        _nuggft.shouldPass(dee, delegate(address(dee), tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:5] - delegate - \"if commiting, msg.value must be >= total eth per share\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_5__failWithVeryHighEPS() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(frank, mint(1500), 50 ether);\n\n        _nuggft.shouldFail('S:5', frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_5__successWithLowEPS() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        _nuggft.shouldPass(frank, mint(1500), floor + .5 ether);\n\n        _nuggft.shouldPass(frank, delegate(address(frank), tokenId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:6] - delegateItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_6__successAsOwnerOfBuyerTokenId() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_6__successAsOperator() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(mac, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_6__failAsNotOperator() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldFail('S:6', mac, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:7] - delegateItem - \"offerer should not be owner of swap\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_7__successWithNotOwner() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        charliesTokenId = scenario_charlie_has_a_token();\n\n        _nuggft.shouldPass(charlie, delegateItem(charliesTokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_7__successWithSameUserDifferentToken() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        uint160 tokenId2 = scenario_dee_has_a_token_2();\n\n        _nuggft.shouldPass(dee, delegateItem(tokenId2, tokenId, itemId), floor + 1 ether);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_7__failWithUserAndOwningToken() public {\n        (tokenId, , itemId, floor) = scenario_dee_has_swapped_an_item();\n\n        _nuggft.shouldFail('S:7', dee, delegateItem(tokenId, tokenId, itemId), floor + 1 ether);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:8] - claim - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n    function test__revert__swap__S_8__successAsSelf() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        _nuggft.shouldPass(mac, claim(address(mac), tokenId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_8__successAsOperator() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        _nuggft.shouldPass(mac, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldPass(dennis, claim(address(mac), tokenId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_8__failAsNotOperator() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        _nuggft.shouldFail('S:8', dennis, claim(address(frank), tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:9] - claimItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_9__successAsOwnerOfBuyerTokenId() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        _nuggft.shouldPass(charlie, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_9__successAsOperator() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        _nuggft.shouldPass(charlie, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(mac, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_9__failAsNotOperator() public {\n        (charliesTokenId, tokenId, itemId) = scenario_dee_has_swapped_an_item_and_charlie_can_claim();\n\n        _nuggft.shouldFail('S:9', mac, claimItem(charliesTokenId, tokenId, itemId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:A] - swap - \"msg.sender is operator for sender\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_A__successAsSelf() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        _nuggft.shouldPass(dee, swap(tokenId, 2 ether));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_A__successAsOperator() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldPass(dennis, swap(tokenId, 2 ether));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_A__failAsNotOperator() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        _nuggft.shouldFail('S:A', dennis, swap(tokenId, 2 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:B] - swap - \"floor >= ethPerShare\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_B__successWithEqualEPS() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_B__successWithOneWeiTooHigh() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor + 1));\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n\n    function test__revert__swap__S_B__revertWithOneWeiTooLow() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldFail('S:B', dee, swap(tokenId, floor - 1));\n    }\n\n    function test__revert__swap__S_B__revertWithZero() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        _nuggft.shouldFail('S:B', dee, swap(tokenId, 0));\n    }\n\n    function test__revert__swap__S_B__revertWithHalfFloor() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldFail('S:B', dee, swap(tokenId, floor / 2));\n    }\n\n    function test__revert__swap__S_B__successWithWayTooHigh() public {\n        tokenId = scenario_dee_has_a_token_and_can_swap();\n\n        scenario_frank_has_a_token_and_spent_50_eth();\n\n        floor = nuggft.ethPerShare();\n\n        _nuggft.shouldPass(dee, swap(tokenId, floor + 30 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:C] - swapItem - \"msg.sender is operator for buyerTokenId\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_C__successAsOwnerOfBuyerTokenId() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        _nuggft.shouldPass(dee, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    function test__revert__swap__S_C__successAsOperator() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(dennis), true));\n\n        _nuggft.shouldPass(dennis, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    function test__revert__swap__S_C__failAsNotOperator() public {\n        (tokenId, itemId, ) = scenario_dee_has_a_token_and_can_swap_an_item();\n\n        _nuggft.shouldFail('S:C', dennis, swapItem(tokenId, itemId, 1 ether));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:D] - swapItem - \"cannot sell two of same item at same time\" @todo\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:E] - checkClaimerIsWinnerOrLoser - \"invalid offer\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_E__successPrevSwapperCanClaimAfterNewSwapHasStarted() public {\n        (tokenId, floor) = scenario_mac_has_swapped_a_token_dee_swapped();\n\n        // dee got the token here\n        _nuggft.shouldPass(dee, claim(address(dee), tokenId));\n    }\n\n    function test__revert__swap__S_E__failNoOffer() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        _nuggft.shouldFail('S:E', charlie, claim(address(charlie), tokenId));\n    }\n\n    function test__revert__swap__S_E__successAsLeader() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        _nuggft.shouldPass(mac, claim(address(mac), tokenId));\n    }\n\n    function test__revert__swap__S_E__successAsOwner() public {\n        tokenId = scenario_dee_has_swapped_a_token_and_mac_can_claim();\n\n        // dee got the token here\n        _nuggft.shouldPass(dee, claim(address(dee), tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        [S:F] - offer - \"swap must be total\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    function test__revert__swap__S_F__successOfferInActiveSwap() public {\n        (tokenId, eth) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        // dee got the token here\n        _nuggft.shouldPass(charlie, delegate(address(charlie), tokenId), eth + 1 ether);\n    }\n\n    function test__revert__swap__S_F__failOfferInOldSwap() public {\n        (tokenId, eth) = scenario_dee_has_swapped_a_token_and_mac_has_delegated();\n\n        fvm.roll(2000);\n\n        // dee got the token here\n        _nuggft.shouldFail('S:F', charlie, delegate(address(charlie), tokenId), eth + 1 ether);\n    }\n\n    function test__revert__swap__S_F__failOfferInFutureSwap() public {\n        // dee got the token here\n        _nuggft.shouldFail('S:4', charlie, delegate(address(charlie), 50000), 1 ether);\n    }\n}\n\n// @todo - make sure eth ends up where we want it\n"
    },
    "src/_test/reverts/stake.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../NuggftV1.test.sol';\n\ncontract revertTest__stake is NuggftV1Test {\n    uint32 epoch;\n\n    using UserTarget for address;\n\n    function setUp() public {\n        reset();\n        epoch = nuggft.epoch();\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n            [T:1] - addStakedShareFromMsgValue - \"value of tx too low\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // mint\n    // ────\n\n    function test__revert__stake__T_1__success() public {\n        _nuggft.shouldPass(frank, mint(2099), 30 * 10**16);\n    }\n\n    function test__revert__stake__T_1__fail() public {\n        _nuggft.shouldPass(frank, mint((2099)), 30 * 10**18);\n\n        _nuggft.shouldFail('T:1', dennis, mint(2909), 29 * 10**18);\n    }\n\n    function test__revert__stake__T_1__fail_fromZero() public {\n\n        _nuggft.shouldPass(frank, mint((2099)), 30 * 10**18);\n\n        _nuggft.shouldFail('T:1', dennis, mint(2909));\n    }\n\n    // trustedMint\n    // ────\n\n    function test__revert__stake__T_1__successOnTrusted() public {\n        _nuggft.shouldPass(safe, trustedMint(99, address(frank)), 30 * 10**16);\n    }\n\n    function test__revert__stake__T_1__failOnTrusted() public {\n\n\n        _nuggft.shouldPass(safe, trustedMint(99, address(frank)), 15 * 10**18);\n\n\n\n        _nuggft.shouldFail('T:1', safe, trustedMint(9, address(dennis)), 14 * 10**18);\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                         [T:2] - value of tx too low  @todo\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n             [T:3] - subStakedShare - \"user not granded permission\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // burn\n    // ─────────────\n\n    function test__revert__stake__T_3__burn__fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldFail('T:3', mac, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failOnNoApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldFail('T:3', dee, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(dee, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failOnIncorrectApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(mac), tokenId));\n\n        _nuggft.shouldFail('T:3', dee, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failOnIncorrectOperatorApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldFail('T:3', dennis, burn(tokenId));\n    }\n\n    function test__revert__stake__T_3__burn__failsOnCorrectOperatorApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, setApprovalForAll(address(mac), true));\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldFail('T:3', mac, burn(tokenId));\n    }\n\n    // migrate\n    // ─────────────\n\n    function test__revert__stake__T_3__migrate__fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        scenario_migrator_set();\n\n        _nuggft.shouldFail('T:3', dee, migrate(tokenId));\n    }\n\n    function test__revert__stake__T_3__migrate__succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        scenario_migrator_set();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(dee, migrate(tokenId));\n    }\n\n    /* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n                [T:4] - migrate - \"migrator must be set\"\n       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */\n\n    // migrate\n    // ────────────\n\n    function test__revert__stake__T_4_fail() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldFail('T:4', dee, migrate(tokenId));\n    }\n\n    function test__revert__stake__T_4_succeeds() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(safe, setMigrator(address(migrator)));\n\n        _nuggft.shouldPass(dee, migrate(tokenId));\n    }\n\n    function test__revert__stake__T_4_succeedsWithApproval() public {\n        uint160 tokenId = scenario_dee_has_a_token();\n\n        _nuggft.shouldPass(dee, approve(address(nuggft), tokenId));\n\n        _nuggft.shouldPass(safe, setMigrator(address(migrator)));\n\n        _nuggft.shouldPass(dee, migrate(tokenId));\n    }\n\n    /// values add on top of each other\n}\n"
    },
    "src/_test/utils/User.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {ForgeVm} from './Vm.sol';\n\nlibrary UserTarget {\n    function shouldPass(\n        address target,\n        User user,\n        bytes memory args\n    ) internal {\n        shouldPass(target, user, args, 0);\n    }\n\n    function shouldPass(\n        address target,\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) internal {\n        user.call(target, args, eth);\n    }\n\n    function shouldFail(\n        address target,\n        string memory message,\n        User user,\n        bytes memory args\n    ) internal {\n        shouldFail(target, message, user, args, 0);\n    }\n\n    function shouldFail(\n        address target,\n        string memory message,\n        User user,\n        bytes memory args,\n        uint96 eth\n    ) internal {\n        user.revertCall(target, message, args, eth);\n    }\n}\n\ncontract User {\n    ForgeVm internal constant fvm = ForgeVm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    event log_named_string(string key, string val);\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor() payable {}\n\n    function tryCall(address target, bytes memory data) public payable virtual returns (bool success, bytes memory returnData) {\n        (success, returnData) = target.call{value: msg.value}(data);\n    }\n\n    function call(\n        address target,\n        bytes memory data,\n        uint256 eth\n    ) public payable virtual returns (bytes memory returnData) {\n        require(address(this).balance >= eth, 'INSUFFICIENT_BALANCE_FROM_TARGET');\n        bool success;\n        (success, returnData) = target.call{value: eth}(data);\n\n        if (!success) {\n            if (returnData.length > 0) {\n                assembly {\n                    let returnDataSize := mload(returnData)\n                    revert(add(32, returnData), returnDataSize)\n                }\n            } else {\n                revert('REVERTED_WITHOUT_MESSAGE');\n            }\n        }\n    }\n\n    function revertCall(\n        address target,\n        string memory message,\n        bytes memory data,\n        uint256 eth\n    ) public payable virtual {\n        require(address(this).balance >= eth, 'INSUFFICIENT_BALANCE_FROM_TARGET');\n\n        (bool callSuccess, bytes memory returnData) = target.call{value: eth}(data);\n\n        require(!callSuccess, 'REVERT-CALL SUCCEEDED');\n\n        string memory revertReason = string(extractRevertReason(returnData));\n\n        if (!compareStrings(revertReason, message)) {\n            revert(string(abi.encodePacked('UNEXPECTED REVERT: ', revertReason, ' EXPECTED: ', message)));\n        }\n    }\n\n    function extractRevertReason(bytes memory revertData) internal pure returns (string memory reason) {\n        uint256 l = revertData.length;\n        if (l < 68) return '';\n        uint256 t;\n        assembly {\n            revertData := add(revertData, 4)\n            t := mload(revertData) // Save the content of the length slot\n            mstore(revertData, sub(l, 4)) // Set proper length\n        }\n        reason = abi.decode(revertData, (string));\n        assembly {\n            mstore(revertData, t) // Restore the content of the length slot\n        }\n    }\n\n    function compareStrings(string memory a, string memory b) public pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "src/_test/dev/TrustedMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport '../../interfaces/nuggftv1/INuggftV1.sol';\n\ncontract NuggftV1TrustedMinter {\n    address immutable deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    function mintem(\n        address nuggftv1,\n        address to,\n        uint256 start,\n        uint256 amount\n    ) external payable {\n        for (uint256 i = start; i < start + amount; i++) {\n            INuggftV1(nuggftv1).trustedMint{value: INuggftV1(nuggftv1).minSharePrice()}(uint160(i), to);\n        }\n    }\n\n    function byebye() external {\n        require(msg.sender == deployer);\n        selfdestruct(payable(msg.sender));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}